(dp0
I379906
(dp1
S'def num(s):\n    pass'
p2
(F-2.319727897644043
F-3.775597095489502
tp3
sS'return False'
p4
(F-3.3484840393066406
F-4.287924766540527
tp5
sS'return float(s)'
p6
(F-2.6925719124930247
F-3.0914108753204346
tp7
sS"a = '545.2222'"
p8
(F-3.148320198059082
F-3.5070223808288574
tp9
sS'float(value)'
p10
(F-2.6662047704060874
F-3.0682687759399414
tp11
sS"a = '545.2222'\nfloat(a)\nint(float(a))"
p12
(F-2.204798380533854
F-2.8302481174468994
tp13
sS'return True'
p14
(F-3.2482566833496094
F-4.2058610916137695
tp15
sS'float(a)\nint(float(a))'
p16
(F-2.5579027448381697
F-2.9138476848602295
tp17
sS'float(a)'
p18
(F-2.4943488438924155
F-3.115053176879883
tp19
sS"a = '545.2222'\nfloat(a)"
p20
(F-2.1209690093994142
F-2.9291677474975586
tp21
sS'return int(s)'
p22
(F-2.5930203029087613
F-3.3078155517578125
tp23
sS'int(float(a))'
p24
(F-2.036457273695204
F-2.9174413681030273
tp25
sS'def isfloat(value):\n    pass'
p26
(F-1.6730244954427083
F-4.423684597015381
tp27
ssI3437059
(dp28
S's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p29
(F-1.7352186090805952
F-3.8350941051136362
tp30
sS"if (s.find('is') == (-1)):\n    pass"
p31
(F-2.381165277390253
F-3.9079790982333096
tp32
sS"if ('blah' not in somestring):\n    continue"
p33
(F-2.633453369140625
F-3.8154224048961294
tp34
sS's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p35
(F-1.8754715197014087
F-3.833920565518466
tp36
sS"if ('blah' not in somestring):\n    pass"
p37
(F-2.3867615291050504
F-3.7890208851207388
tp38
sS'print "No \'is\' here!"'
p39
(F-3.5330758094787598
F-3.950208143754439
tp40
sS'continue'
p41
(F-6.198219299316406
F-4.244293559681285
tp42
sS"s = 'This be a string'\nif (s.find('is') == (-1)):\n    pass"
p43
(F-2.148470153808594
F-3.83175312389027
tp44
sS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p45
(F-1.8310253143310546
F-3.8892804926091973
tp46
sS"s = 'This be a string'"
p47
(F-2.264908027648926
F-3.836374109441584
tp48
sS'print "Found \'is\' in the string."'
p49
(F-3.5330755710601807
F-3.950208143754439
tp50
sS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p51
(F-1.997594636062096
F-3.888948613947088
tp52
ssI4265988
(dp53
S'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob'
p54
(F-2.8577282927757084
F-3.4643176396687827
tp55
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p56
(F-3.3541342791389015
F-3.6641101837158203
tp57
sS'numpy.random.choice(numpy.arange(1, 7), p=[0.1, 0.05, 0.05, 0.2, 0.4, 0.2])'
p58
(F-2.400041291207978
F-3.871927579243978
tp59
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p60
(F-3.5633223562529595
F-3.7313359578450522
tp61
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p62
(F-3.5731251109730113
F-3.5885868072509766
tp63
sS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p64
(F-4.945457252296242
F-3.665541966756185
tp65
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p66
(F-2.9557647705078125
F-3.482839266459147
tp67
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]'
p68
(F-2.2371414928901485
F-3.7203661600748696
tp69
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p70
(F-3.4516477842588684
F-3.6781702041625977
tp71
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    pass'
p72
(F-2.465890651795922
F-3.483677864074707
tp73
sS'return item'
p74
(F-4.687789440155029
F-4.423743565877278
tp75
sS's = 0\nfor (item, prob) in l:\n    pass'
p76
(F-3.082868877210115
F-3.7570718129475913
tp77
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p78
(F-3.4187974805955763
F-3.607460339864095
tp79
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p80
(F-3.3726112102640085
F-3.731760025024414
tp81
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p82
(F-2.8436767033168246
F-3.4811134338378906
tp83
sS's = 0\nfor (item, prob) in l:\n    s += prob'
p84
(F-3.7495843796502974
F-3.6410694122314453
tp85
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p86
(F-3.4542973836263022
F-3.7227185567220054
tp87
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0'
p88
(F-2.4241920753761574
F-3.6598663330078125
tp89
sS'if (s >= r):\n    return item'
p90
(F-3.131762368338449
F-4.231255531311035
tp91
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p92
(F-3.247043494022254
F-3.6685447692871094
tp93
sS's += prob'
p94
(F-4.898539352416992
F-4.073510487874349
tp95
sS'if (s >= r):\n    return item\nreturn item'
p96
(F-3.452058231129366
F-4.190114974975586
tp97
sS'R = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p98
(F-3.6152417800005745
F-3.5664313634236655
tp99
sS'for (item, prob) in l:\n    pass'
p100
(F-3.0733731587727866
F-3.8612712224324546
tp101
sS'r = random.uniform(0, 1)'
p102
(F-1.895147482554118
F-3.610319137573242
tp103
sS'def random_distr(l):\n    pass'
p104
(F-1.751894814627511
F-3.8982550303141275
tp105
sS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p106
(F-4.468995884486607
F-3.5844828287760415
tp107
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p108
(F-2.7867562033913353
F-3.4865748087565103
tp109
sS'for (item, prob) in l:\n    s += prob'
p110
(F-3.8568029964671418
F-3.7133312225341797
tp111
sS's = 0'
p112
(F-4.0123435974121096
F-4.361337025960286
tp113
sS'sorted((max((i for r in [random.random()] for (i, c) in cdf if (c <= r))) for _ in range(1000)))'
p114
(F-3.572179395099019
F-3.614929517110189
tp115
sS'def random_distr(l):\n    r = random.uniform(0, 1)'
p116
(F-1.924950309421705
F-3.6288013458251953
tp117
sS'if (s >= r):\n    pass'
p118
(F-2.7656784057617188
F-4.266305605570476
tp119
ssI843277
(dp120
S'my_variable = None'
p121
(F-2.8319178989955356
F-1.5502784035422585
tp122
sS'def InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p123
(F-3.4008443196614584
F-1.562605250965465
tp124
sS'my_variable = None\n\ndef InitMyVariable():\n    pass'
p125
(F-3.2593967437744142
F-1.6948519620028408
tp126
sS'def InitMyVariable():\n    global my_variable'
p127
(F-4.072841167449951
F-1.6976035724986682
tp128
sS'try:\n    myVar\nexcept NameError:\n    myVar = None'
p129
(F-3.264928545270647
F-1.5072917938232422
tp130
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable'
p131
(F-3.6417806874150815
F-1.6464600996537642
tp132
sS"if ('myVar' in globals()):\n    pass"
p133
(F-2.040657806396484
F-1.5121943733908914
tp134
sS'myVar = None'
p135
(F-4.023047765096028
F-1.5521221160888672
tp136
sS'if (my_variable is None):\n    pass'
p137
(F-2.3556116739908854
F-1.5070169622247869
tp138
sS'try:\n    myVar\nexcept NameError:\n    pass'
p139
(F-2.6767957475450306
F-1.5125715082341975
tp140
sS'global my_variable'
p141
(F-3.674236297607422
F-1.5450380498712712
tp142
sS'def InitMyVariable():\n    pass'
p143
(F-3.5658463698167067
F-1.7827301025390625
tp144
sS'myVar'
p145
(F-8.764297485351562
F-1.5260439786044033
tp146
sS"if ('myVar' in locals()):\n    pass"
p147
(F-2.020116678873698
F-1.409163475036621
tp148
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p149
(F-3.23155707281989
F-1.5829734802246094
tp150
sS'pass'
p151
(F-2.6844215393066406
F-1.775752674449574
tp152
sS"if hasattr(obj, 'attr_name'):\n    pass"
p153
(F-1.3614488329206194
F-1.648069901899858
tp154
ssI546321
(dp155
S'import datetime'
p156
(F-3.50300931930542
F-2.7797672271728517
tp157
sS'from datetime import date'
p158
(F-3.1549743016560874
F-2.5580549240112305
tp159
sS'six_months = (date.today() + relativedelta(months=(+ 6)))'
p160
(F-3.586947233780571
F-2.760766792297363
tp161
sS'print (datetime.date.today() + datetime.timedelta(((6 * 365) / 12))).isoformat()'
p162
(F-2.940708283455141
F-2.5385229110717775
tp163
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta'
p164
(F-2.7074191753680887
F-2.569412612915039
tp165
sS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))'
p166
(F-3.766476717862216
F-2.7357879638671876
tp167
sS'(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p168
(F-3.8348447626287285
F-2.742481231689453
tp169
sS'(day, month, year) = (day, ((month + 6) % 12), (year + ((month + 6) / 12)))'
p170
(F-3.846845059781461
F-2.6732303619384767
tp171
sS'from dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p172
(F-3.329712422688802
F-2.5533931732177733
tp173
sS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))\n(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p174
(F-3.8754109227380087
F-2.7149679183959963
tp175
sS'from dateutil.relativedelta import relativedelta'
p176
(F-3.1400513648986816
F-2.5558403015136717
tp177
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p178
(F-3.157405308314732
F-2.5525569915771484
tp179
sS'import datetime\nprint (datetime.date.today() + datetime.timedelta(((6 * 365) / 12))).isoformat()'
p180
(F-2.6839278726016773
F-2.5418283462524416
tp181
sS'date += datetime.timedelta((6 * 30))'
p182
(F-3.4850594656808034
F-2.538883590698242
tp183
ssI237079
(dp184
S'def modification_date(filename):\n    pass'
p185
(F-2.133253370012556
F-3.7924845377604166
tp186
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p187
(F-1.7239496231079101
F-3.694286346435547
tp188
sS"if (platform.system() == 'Windows'):\n    pass"
p189
(F-2.303848715389476
F-3.8402142842610676
tp190
sS"print ('last modified: %s' % time.ctime(os.path.getmtime(file)))"
p191
(F-2.2251277923583985
F-3.671339416503906
tp192
sS'import datetime'
p193
(F-3.8899435997009277
F-3.752180989583333
tp194
sS"(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint ('last modified: %s' % time.ctime(mtime))"
p195
(F-3.448241460890997
F-3.7393567403157553
tp196
sS'return datetime.datetime.fromtimestamp(t)'
p197
(F-2.1743764010342685
F-3.933599853515625
tp198
sS"import os.path, time\nprint ('last modified: %s' % time.ctime(os.path.getmtime(file)))"
p199
(F-2.4410643400969327
F-3.7141756693522137
tp200
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p201
(F-2.4726378242924527
F-3.781550089518229
tp202
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p203
(F-2.754747054156135
F-3.790179697672526
tp204
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p205
(F-1.858308946764147
F-3.7220850626627606
tp206
sS'"\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p207
(F-4.508178075154622
F-3.7809288024902346
tp208
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    pass'
p209
(F-2.4472637939453126
F-3.838275909423828
tp210
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p211
(F-2.8772177124023437
F-3.8232149759928387
tp212
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p213
(F-2.562398672103882
F-3.764850870768229
tp214
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p215
(F-1.7864715576171875
F-3.7012123107910155
tp216
sS'import os, time'
p217
(F-4.230659484863281
F-3.7836517333984374
tp218
sS'stat = os.stat(path_to_file)'
p219
(F-3.117189407348633
F-3.776635487874349
tp220
sS"import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint ('last modified: %s' % time.ctime(mtime))"
p221
(F-3.2534342015043216
F-3.7435208638509114
tp222
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p223
(F-2.425841720015914
F-3.6953748067220054
tp224
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p225
(F-2.4573238439727247
F-3.767839558919271
tp226
sS'import platform\n\ndef creation_date(path_to_file):\n    pass'
p227
(F-2.7137425162575464
F-3.8136337280273436
tp228
sS'import datetime\n\ndef modification_date(filename):\n    pass'
p229
(F-1.86928219265408
F-3.730540466308594
tp230
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p231
(F-2.5680450771165932
F-3.7706764221191404
tp232
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p233
(F-1.9553177573464133
F-3.6992724100748697
tp234
sS'import os\nimport datetime'
p235
(F-2.766204833984375
F-3.7645589192708333
tp236
sS"print ('last modified: %s' % time.ctime(mtime))"
p237
(F-2.98776127741887
F-3.684746805826823
tp238
sS'return stat.st_mtime'
p239
(F-3.8014917373657227
F-3.7429044087727865
tp240
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)'
p241
(F-2.15417944866678
F-3.7547698974609376
tp242
sS'(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p243
(F-3.5944590250651043
F-3.775689188639323
tp244
sS'import os.path, time'
p245
(F-4.189553260803223
F-3.835693613688151
tp246
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p247
(F-2.6380200105554916
F-3.7650782267252603
tp248
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p249
(F-1.9946816055862993
F-3.700763448079427
tp250
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p251
(F-2.4516799029181984
F-3.7463338216145834
tp252
sS'def creation_date(path_to_file):\n    pass'
p253
(F-2.622171825832791
F-3.8803367614746094
tp254
sS'print d'
p255
(F-5.22819709777832
F-3.8243306477864585
tp256
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p257
(F-3.2060165405273438
F-3.877625020345052
tp258
sS'return os.path.getctime(path_to_file)'
p259
(F-2.978838094075521
F-3.788319396972656
tp260
sS"import os.path, time\nprint ('last modified: %s' % time.ctime(os.path.getmtime(file)))\nprint ('created: %s' % time.ctime(os.path.getctime(file)))"
p261
(F-2.4361393140709917
F-3.708876037597656
tp262
sS"print ('created: %s' % time.ctime(os.path.getctime(file)))"
p263
(F-2.3772327423095705
F-3.649181111653646
tp264
sS'import os'
p265
(F-3.9231245517730713
F-3.8263231913248696
tp266
sS'print repr(d)'
p267
(F-3.5850682939801897
F-3.935913340250651
tp268
sS"d = modification_date('/var/log/syslog')\nprint d\nprint repr(d)"
p269
(F-3.1685684605648645
F-3.9188512166341147
tp270
sS'import platform'
p271
(F-4.672947883605957
F-3.8560691833496095
tp272
sS"d = modification_date('/var/log/syslog')"
p273
(F-3.359491729736328
F-3.962352498372396
tp274
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p275
(F-2.6050241088867185
F-3.7680145263671876
tp276
sS't = os.path.getmtime(filename)'
p277
(F-2.0314181645711265
F-3.8008997599283854
tp278
sS'return stat.st_birthtime'
p279
(F-3.5206198692321777
F-3.7405540466308596
tp280
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p281
(F-2.382356751639888
F-3.7678858439127603
tp282
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)"
p283
(F-2.7071172780004042
F-3.786945088704427
tp284
sS'print d\nprint repr(d)'
p285
(F-3.9196403503417967
F-3.9359057108561197
tp286
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    pass'
p287
(F-1.6550845191592263
F-3.6908063252766925
tp288
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)"
p289
(F-2.641318625592171
F-3.774303436279297
tp290
sS'import os\nimport platform'
p291
(F-3.568432399204799
F-3.8614682515462238
tp292
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass"
p293
(F-2.449236925910501
F-3.748595428466797
tp294
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p295
(F-3.1610759388316763
F-3.7967193603515623
tp296
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime"
p297
(F-2.5441708499438143
F-3.7440617879231772
tp298
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p299
(F-2.4968928700869846
F-3.7523778279622397
tp300
sS"d = modification_date('/var/log/syslog')\nprint d"
p301
(F-3.22817376943735
F-3.9160499572753906
tp302
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p303
(F-2.5356708102756076
F-3.741021219889323
tp304
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p305
(F-2.4233174531356148
F-3.756475830078125
tp306
sS'import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p307
(F-3.345117405482701
F-3.766901143391927
tp308
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p309
(F-2.5381559989821745
F-3.7772120157877604
tp310
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p311
(F-2.4971424917156777
F-3.7470293680826825
tp312
sS"print ('last modified: %s' % time.ctime(os.path.getmtime(file)))\nprint ('created: %s' % time.ctime(os.path.getctime(file)))"
p313
(F-2.336275149614383
F-3.676112111409505
tp314
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p315
(F-2.348858133951823
F-3.7800949096679686
tp316
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass"
p317
(F-2.3786824544270835
F-3.7816177368164063
tp318
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p319
(F-1.9922025275952888
F-3.7244720458984375
tp320
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p321
(F-2.6406845464939024
F-3.8010965983072915
tp322
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p323
(F-2.7796092786287008
F-3.7887194315592447
tp324
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p325
(F-2.5710283644655916
F-3.743011728922526
tp326
ssI6159900
(dp327
S"f.write(('hi there' + os.linesep))\nf.close()"
p328
(F-2.066315841674805
F-2.01049145785245
tp329
sS"f.write(('hi there' + os.linesep))"
p330
(F-2.3376759120396207
F-2.0361744273792612
tp331
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
p332
(F-0.6195386803668478
F-1.9477251226251775
tp333
sS"with open('somefile.txt', 'a') as the_file:\n    pass"
p334
(F-1.356201383802626
F-1.950649088079279
tp335
sS'f.close()'
p336
(F-1.038994312286377
F-2.034636757590554
tp337
sS"the_file.write('Hello\\n')"
p338
(F-1.5880505561828613
F-1.9901899857954546
tp339
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p340
(F-1.8673327410662617
F-1.9891907085071912
tp341
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p342
(F-1.600000508626302
F-1.9589816006747158
tp343
sS'os.linesep'
p344
(F-2.6428197860717773
F-2.393849112770774
tp345
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p346
(F-1.9888194856189547
F-1.9511344216086648
tp347
sS"f = open('myfile', 'w')"
p348
(F-1.2748964309692383
F-1.9603287089954724
tp349
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p350
(F-1.6780198562976927
F-1.977230592207475
tp351
sS"f = open('myfile', 'w')\nf.write('hi there\\n')"
p352
(F-1.0553750430836397
F-1.9378516457297585
tp353
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p354
(F-2.0505395777085247
F-1.9645196741277522
tp355
sS"with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
p356
(F-1.1072562408447266
F-1.933317704634233
tp357
sS"open('myfile', 'rb').read()"
p358
(F-1.016866127649943
F-1.9322312094948508
tp359
sS"os.linesep\nf = open('myfile', 'w')"
p360
(F-2.5711312975202287
F-1.9828872680664062
tp361
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p362
(F-1.8482448259989421
F-1.9801571585915305
tp363
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p364
(F-1.959233670621305
F-1.9804905978116123
tp365
sS"import os\nos.linesep\nf = open('myfile', 'w')"
p366
(F-2.3395390230066635
F-2.023424842140891
tp367
sS"f.close()\nopen('myfile', 'rb').read()"
p368
(F-1.2788622114393446
F-1.964393442327326
tp369
sS"from __future__ import print_function\nprint('hi there', file=f)"
p370
(F-2.131536182604338
F-2.4339523315429688
tp371
sS'import os'
p372
(F-4.324676990509033
F-2.4722116643732246
tp373
sS"f.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p374
(F-1.9066516507056452
F-1.9701621315696023
tp375
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p376
(F-1.3266725540161133
F-1.9577475461092861
tp377
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p378
(F-1.7894333287289268
F-1.9664663835005327
tp379
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p380
(F-1.6607996622721355
F-1.9615199349143289
tp381
sS"f.write('hi there\\n')\nf.close()"
p382
(F-1.03564453125
F-1.9839021509343928
tp383
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p384
(F-1.3826358876329787
F-1.9431261582808061
tp385
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p386
(F-1.7454912185668945
F-1.963718761097301
tp387
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p388
(F-2.1333950587681363
F-1.993442708795721
tp389
sS'from __future__ import print_function'
p390
(F-1.871976089477539
F-2.6044233495538887
tp391
sS"f.write('hi there\\n')"
p392
(F-1.2588368654251099
F-1.9785835959694602
tp393
sS'import os\nos.linesep'
p394
(F-2.577040195465088
F-2.353555505925959
tp395
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p396
(F-1.7245912738874847
F-1.9487601193514736
tp397
ssI899103
(dp398
S"for item in thelist:\n    thefile.write(('%s\\n' % item))"
p399
(F-2.416651153564453
F-1.6310379028320312
tp400
sS'pickle.dump(itemlist, outfile)'
p401
(F-3.050881195068359
F-2.029805374145508
tp402
sS'print  >> thefile, item'
p403
(F-4.872284480503628
F-1.915176773071289
tp404
sS'itemlist = pickle.load(infile)'
p405
(F-3.436353302001953
F-1.7852855682373048
tp406
sS'for item in thelist:\n    pass'
p407
(F-2.153575377030806
F-2.106362152099609
tp408
sS'import pickle'
p409
(F-5.524491786956787
F-2.088490676879883
tp410
sS"outfile.write('\\n'.join(itemlist))"
p411
(F-1.9498175107515776
F-1.5342521667480469
tp412
sS"thefile.write(('%s\\n' % item))"
p413
(F-2.8371149698893228
F-1.6010154724121093
tp414
sS'import pickle\npickle.dump(itemlist, outfile)'
p415
(F-2.8033966651329627
F-1.9925775527954102
tp416
ssI3939361
(dp417
S"string = 'ab1cd1ef'"
p418
(F-2.7315059661865235
F-1.5209014892578125
tp419
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p420
(F-1.9263694517074093
F-1.3152645111083985
tp421
sS"line = 'abc#@!?efg12;:?'"
p422
(F-3.0010549545288088
F-1.6616004943847655
tp423
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p424
(F-1.9691287449428014
F-1.3168411254882812
tp425
sS"string.replace('1', '')"
p426
(F-1.1176637649536132
F-1.3100393295288086
tp427
sS"b = '!@#$'"
p428
(F-3.1594268798828127
F-1.6462881088256835
tp429
sS"a = 'a!b@c#d$'"
p430
(F-3.1015968322753906
F-1.6263093948364258
tp431
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)"
p432
(F-3.3541805869654606
F-1.575465202331543
tp433
sS"''.join((c for c in line if (c not in '?:!/;')))"
p434
(F-3.247647240048363
F-1.3732397079467773
tp435
sS"b = '!@#$'\nfor char in b:\n    pass"
p436
(F-1.9695665995279947
F-1.3589559555053712
tp437
sS"import string\nline = line.translate(string.maketrans('', ''), '!@#$')"
p438
(F-2.536145643754439
F-1.3722980499267579
tp439
sS"for char in b:\n    a = a.replace(char, '')\nprint a"
p440
(F-2.2363470326299253
F-1.3507371902465821
tp441
sS'import re'
p442
(F-4.37827205657959
F-1.395915412902832
tp443
sS"line = line.translate(string.maketrans('', ''), '!@#$')"
p444
(F-2.4101566515470805
F-1.3612680435180664
tp445
sS"import re\nline = re.sub('[!@#$]', '', line)"
p446
(F-1.189614688648897
F-1.318458652496338
tp447
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    pass"
p448
(F-1.7328424955669202
F-1.350287628173828
tp449
sS'print a'
p450
(F-4.905135154724121
F-1.796309471130371
tp451
sS"string = 'ab1cd1ef'\nstring.replace('1', '')"
p452
(F-1.2766914367675781
F-1.318331241607666
tp453
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p454
(F-2.1686952908833823
F-1.314865493774414
tp455
sS'import string'
p456
(F-5.055610179901123
F-1.7250381469726563
tp457
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)\nunicode_line = unicode_line.translate(translation_table)"
p458
(F-3.6082023171817554
F-1.3694327354431153
tp459
sS'for char in b:\n    pass'
p460
(F-1.9935337413441052
F-1.737628173828125
tp461
sS"line = 'abc#@!?efg12;:?'\n''.join((c for c in line if (c not in '?:!/;')))"
p462
(F-3.214730224609375
F-1.3773277282714844
tp463
sS"line = re.sub('[!@#$]', '', line)"
p464
(F-1.2773933410644531
F-1.3397762298583984
tp465
sS"for char in b:\n    a = a.replace(char, '')"
p466
(F-2.2141576766967774
F-1.3476667404174805
tp467
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p468
(F-2.114036136203342
F-1.3138593673706054
tp469
sS"unicode_line = unicode_line.translate({ord(c): None for c in '!@#$'})"
p470
(F-3.9711007690429687
F-1.373055648803711
tp471
sS'unicode_line = unicode_line.translate(translation_table)'
p472
(F-3.621509552001953
F-1.44079532623291
tp473
sS"a = 'a!b@c#d$'\nb = '!@#$'"
p474
(F-2.4259336259629993
F-1.562301254272461
tp475
sS"a = a.replace(char, '')"
p476
(F-2.4652371406555176
F-1.3226707458496094
tp477
sS"line = line.translate(None, '!@#$')"
p478
(F-2.6504953702290854
F-1.389693832397461
tp479
ssI9001509
(dp480
S'od[1]\nod[3]\nfor (k, v) in od.iteritems():\n    pass'
p481
(F-2.9868908586173224
F-2.1375181024724785
tp482
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p483
(F-2.1217132959610376
F-1.4679487401788884
tp484
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p485
(F-2.2974364451872997
F-1.6549966985529119
tp486
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p487
(F-1.910822868347168
F-2.037813186645508
tp488
sS'print k, v'
p489
(F-3.5080490112304688
F-2.2102794647216797
tp490
sS'keylist.sort()\nfor key in keylist:\n    pass'
p491
(F-2.697239595301011
F-1.9511743025346235
tp492
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p493
(F-2.055946187770113
F-1.4993447390469639
tp494
sS'for key in sorted(mydict):\n    pass'
p495
(F-1.5635969979422433
F-1.6068545254794033
tp496
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p497
(F-2.9761744412508877
F-2.227471785111861
tp498
sS'od[1]\nod[3]'
p499
(F-4.4802117781205615
F-2.4149951934814453
tp500
sS'print (k, v)'
p501
(F-2.2540135383605957
F-2.2448043823242188
tp502
sS'for key in keylist:\n    pass'
p503
(F-2.0080257762562144
F-2.0488641912286933
tp504
sS'keylist.sort()'
p505
(F-2.8704215458461215
F-2.197880831631747
tp506
sS'keylist = mydict.keys()\nkeylist.sort()'
p507
(F-3.3022125244140623
F-1.9380300695245916
tp508
sS"print ('%s: %s' % (key, mydict[key]))"
p509
(F-1.8605865478515624
F-1.871943560513583
tp510
sS'od = collections.OrderedDict(sorted(d.items()))\nod'
p511
(F-2.670772171020508
F-1.468428525057706
tp512
sS'keylist = mydict.keys()'
p513
(F-3.4237164391411676
F-2.0742719823663887
tp514
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p515
(F-2.4315719604492188
F-1.4270000457763672
tp516
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p517
(F-2.4085140952581092
F-1.4234502098777078
tp518
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p519
(F-2.3332435971214656
F-1.7401872114701704
tp520
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p521
(F-2.7106667495355374
F-1.6652658635919744
tp522
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p523
(F-2.2485133361816407
F-1.4353972348299893
tp524
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p525
(F-2.17223760816786
F-1.4524808363481
tp526
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }"
p527
(F-2.4096606861461294
F-2.1021766662597656
tp528
sS'OrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p529
(F-2.235357350316541
F-1.4331704053011807
tp530
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))'
p531
(F-2.2299508314866285
F-1.4022355513139204
tp532
sS'for (k, v) in od.items():\n    pass'
p533
(F-1.9948369076377468
F-2.030761025168679
tp534
sS'keylist = mydict.keys()\nkeylist.sort()\nfor key in keylist:\n    pass'
p535
(F-2.7399557495117186
F-1.8400507840243252
tp536
sS'import collections'
p537
(F-5.080528736114502
F-2.2897633639248935
tp538
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p539
(F-1.985999197330115
F-1.503870877352628
tp540
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }\nfor key in sorted(mydict):\n    pass"
p541
(F-1.9651053292410714
F-1.625792763449929
tp542
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p543
(F-2.3928099987553617
F-1.4171612479469993
tp544
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p545
(F-2.2198847644733934
F-1.4578801935369319
tp546
sS'od[3]\nfor (k, v) in od.iteritems():\n    pass'
p547
(F-2.728120485941569
F-2.022406144575639
tp548
sS'od[3]'
p549
(F-4.490041097005208
F-2.4269896420565518
tp550
sS'from collections import OrderedDict'
p551
(F-2.586088180541992
F-1.8945983539928088
tp552
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p553
(F-2.2939705481896033
F-1.402509255842729
tp554
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p555
(F-2.021686553955078
F-2.2379528392444956
tp556
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p557
(F-2.6837680123069068
F-1.751006386496804
tp558
sS'od'
p559
(F-10.264949162801107
F-2.633609078147195
tp560
sS'od[1]'
p561
(F-4.076402028401692
F-2.446091738614169
tp562
sS'for (k, v) in od.iteritems():\n    pass'
p563
(F-1.9891787077251233
F-1.8891003348610618
tp564
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p565
(F-2.9622293090820313
F-2.2450634349476206
tp566
sS'od = collections.OrderedDict(sorted(d.items()))'
p567
(F-1.7188131544325087
F-1.4364856373180042
tp568
ssI2990121
(dp569
S'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p570
(F-3.096985556862571
F-1.890235607440655
tp571
sS'for i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p572
(F-1.9886941348805147
F-1.782792018010066
tp573
sS'pass'
p574
(F-2.944417635599772
F-2.0270664508526144
tp575
sS'return izip_longest(fillvalue=fillvalue, *args)'
p576
(F-3.5373118264334544
F-1.84638184767503
tp577
sS'"grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p578
(F-6.626489003499349
F-1.94268065232497
tp579
sS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p580
(F-3.116758285030242
F-1.892246099618765
tp581
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'
p582
(F-1.8385429382324219
F-1.7847116910494292
tp583
sS'print i,'
p584
(F-5.989450836181641
F-1.8506123469426081
tp585
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p586
(F-2.2334671020507812
F-1.8299073439378004
tp587
sS'print i'
p588
(F-4.223397254943848
F-1.8800940880408654
tp589
sS'for i in xrange(0, 10, 2):\n    pass'
p590
(F-1.5691799587673612
F-1.8257901118351862
tp591
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    pass'
p592
(F-1.5540071487426759
F-1.7886004814734826
tp593
sS'for i in mylist[1::2]:\n    pass'
p594
(F-1.839841281666475
F-1.7505641350379357
tp595
sS'def grouper(n, iterable, fillvalue=None):\n    pass'
p596
(F-2.2354100545247397
F-1.8921485314002404
tp597
sS'for i in mylist[::2]:\n    pass'
p598
(F-1.792394995689392
F-1.7601698361910307
tp599
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p600
(F-2.759339552659255
F-1.848535391000601
tp601
sS'args = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p602
(F-3.697640313042535
F-1.815147693340595
tp603
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p604
(F-1.7532624869511044
F-1.792250706599309
tp605
sS'from itertools import izip_longest'
p606
(F-2.3719089031219482
F-1.7892831655649037
tp607
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    pass'
p608
(F-1.8969987722543569
F-1.8364392794095552
tp609
sS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p610
(F-2.737168206108941
F-1.8941964369553785
tp611
sS'args = ([iter(iterable)] * n)'
p612
(F-3.5031942640032088
F-1.805335705096905
tp613
sS'for (item1, item2) in grouper(2, l):\n    pass'
p614
(F-3.325846481323242
F-1.829858633188101
tp615
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p616
(F-2.702332716721755
F-1.825258548443134
tp617
sS'for i in range(0, 10, 2):\n    pass'
p618
(F-1.4618423249986436
F-1.8460843012883112
tp619
ssI26443308
(dp620
S"'abcd}def}'.rfind('}')"
p621
(F-2.298283576965332
F-2.4691612243652346
tp622
ssI4174941
(dp623
S'l.sort(key=(lambda x: x[2]))'
p624
(F-1.8895517985026042
F-1.8372226291232638
tp625
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nl.sort(key=(lambda x: x[2]))"
p626
(F-2.1956626228664233
F-1.7926404741075304
tp627
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p628
(F-2.3048637204053923
F-1.8066092597113714
tp629
sS'sorted(l, key=(lambda x: x[2]))'
p630
(F-2.042538113064236
F-1.8068576388888888
tp631
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p632
(F-2.5927702805091597
F-2.0861208173963757
tp633
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p634
(F-2.4913392908432903
F-2.071965535481771
tp635
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p636
(F-2.169578386389691
F-1.823794682820638
tp637
sS'sorted_list = sorted(list_to_sort, key=itemgetter(2, 0, 1))'
p638
(F-2.238375701904297
F-1.8202122582329645
tp639
sS'from operator import itemgetter'
p640
(F-3.2854398091634116
F-2.269765430026584
tp641
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p642
(F-2.640740230165679
F-2.0917852189805775
tp643
sS'sorted(L, key=itemgetter(2))'
p644
(F-1.6119750096247747
F-1.8471707238091364
tp645
ssI3207219
(dp646
S"os.listdir('somedirectory')"
p647
(F-1.2396471500396729
F-1.777767817179362
tp648
sS'onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p649
(F-2.7400690714518228
F-1.8887265523274739
tp650
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)\nq'
p651
(F-3.5509124263640373
F-2.613506317138672
tp652
sS"print glob.glob('/home/adam/*.txt')"
p653
(F-1.8377744886610243
F-1.8284358978271484
tp654
sS'w = [4, 5, 6]\nq = (q + w)\nq'
p655
(F-4.513759068080357
F-2.6378904978434243
tp656
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p657
(F-2.993302001953125
F-2.248323122660319
tp658
sS'q = (q + w)\nq'
p659
(F-6.521744467995384
F-2.551650365193685
tp660
sS'from os.path import isfile, join'
p661
(F-2.6921209335327148
F-1.830788294474284
tp662
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p663
(F-2.859641204009185
F-1.6949342091878254
tp664
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p665
(F-3.0551185607910156
F-1.9469769795735676
tp666
sS'from os import walk\nf = []'
p667
(F-3.682361602783203
F-1.9872937202453613
tp668
sS'w = [4, 5, 6]'
p669
(F-3.4998578158291904
F-2.567882855733236
tp670
sS'from os import walk'
p671
(F-3.0970369974772134
F-1.96833070119222
tp672
sS'q = (q + w)'
p673
(F-5.074701097276476
F-2.5540297826131186
tp674
sS"import glob\nprint glob.glob('/home/adam/*.txt')"
p675
(F-1.3704894383748372
F-1.790784200032552
tp676
sS'from os import listdir\nfrom os.path import isfile, join'
p677
(F-1.8967071533203126
F-1.7408742904663086
tp678
sS"import os\nos.listdir('somedirectory')"
p679
(F-0.9934640364213423
F-1.8427418073018391
tp680
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p681
(F-2.972575887044271
F-1.952606201171875
tp682
sS'q = [1, 2, 3]\nw = [4, 5, 6]'
p683
(F-2.6418369838169644
F-2.5879494349161782
tp684
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p685
(F-2.8416265869140624
F-1.7238394419352214
tp686
sS'break'
p687
(F-3.199003219604492
F-2.4051106770833335
tp688
sS'import os'
p689
(F-3.695314407348633
F-2.311373233795166
tp690
sS'f = []'
p691
(F-4.661675135294597
F-2.4491554896036782
tp692
sS'from os import listdir'
p693
(F-2.6385658582051597
F-1.8863534927368164
tp694
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p695
(F-3.0446381745515048
F-1.7190796534220378
tp696
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p697
(F-2.7718360900878904
F-1.741075038909912
tp698
sS'from os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p699
(F-2.2911589773077714
F-1.6845297813415527
tp700
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)'
p701
(F-2.9908541975350214
F-2.616906007130941
tp702
sS'f.extend(filenames)'
p703
(F-2.898231029510498
F-1.9526058832804363
tp704
sS'q'
p705
(F-10.437931060791016
F-2.467064539591471
tp706
sS'from os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p707
(F-2.505779150760535
F-1.6795063018798828
tp708
sS'w = [4, 5, 6]\nq = (q + w)'
p709
(F-3.7422099866365133
F-2.637968381245931
tp710
sS'q = [1, 2, 3]'
p711
(F-3.004492326216264
F-2.5763940811157227
tp712
sS'import glob'
p713
(F-4.586779594421387
F-1.9988185564676921
tp714
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p715
(F-2.7686148507254464
F-1.6954887708028157
tp716
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p717
(F-2.8164337158203123
F-1.7913710276285808
tp718
ssI2972212
(dp719
sI53513
(dp720
S"print 'List is empty'"
p721
(F-4.68285608291626
F-2.2649295113303443
tp722
sS"print 'the list is empty'"
p723
(F-4.68285608291626
F-2.2649295113303443
tp724
sS'if (len(li) == 0):\n    pass'
p725
(F-1.7984942197799683
F-1.9110932783647017
tp726
sS'if (not a):\n    pass'
p727
(F-2.1386760075887046
F-2.0780856392600318
tp728
ssI1514553
(dp729
S'f = []\nfor i in range(30):\n    pass'
p730
(F-1.9004661158511513
F-1.508775234222412
tp731
sS'for i in range(30):\n    f.append(0)'
p732
(F-1.6758786251670437
F-1.523110294342041
tp733
sS'for i in range(30):\n    pass'
p734
(F-1.482560157775879
F-1.5601184844970704
tp735
sS"intarray = array('i')"
p736
(F-3.345400094985962
F-1.4585083961486816
tp737
sS'f = []\nfor i in range(30):\n    f.append(0)'
p738
(F-1.8583040237426758
F-1.5229669570922852
tp739
sS'f = []'
p740
(F-3.952502886454264
F-1.4981372833251954
tp741
sS'from array import array'
p742
(F-3.915315310160319
F-1.4531173706054688
tp743
sS"from array import array\nintarray = array('i')"
p744
(F-3.2677298325758715
F-1.468180274963379
tp745
sS'variable = []'
p746
(F-3.8164052963256836
F-1.5759940147399902
tp747
sS'f.append(0)'
p748
(F-2.5426149368286133
F-1.5261266708374024
tp749
ssI2612802
(dp750
S"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p751
(F-2.9308274969997177
F-3.298089599609375
tp752
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p753
(F-3.1186310390256486
F-3.2448604583740233
tp754
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p755
(F-3.0927674010559754
F-3.297087478637695
tp756
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p757
(F-2.847796595373819
F-3.298984909057617
tp758
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p759
(F-3.0117407626793034
F-3.0597661972045898
tp760
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p761
(F-2.7468999056208054
F-3.303411102294922
tp762
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p763
(F-2.896157035614525
F-3.33077392578125
tp764
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p765
(F-2.6468793551127114
F-3.1465187072753906
tp766
sS"a = ['foo', foo]"
p767
(F-4.040045844184028
F-3.004700469970703
tp768
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p769
(F-2.7133059692382813
F-3.2928115844726564
tp770
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p771
(F-3.0869305323040677
F-3.297964096069336
tp772
sS't = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p773
(F-2.884675056703629
F-3.419124984741211
tp774
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p775
(F-2.9586967856197033
F-3.3131645202636717
tp776
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p777
(F-3.0277964624865303
F-3.3223499298095702
tp778
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p779
(F-3.186492751316471
F-3.294324493408203
tp780
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p781
(F-2.9294641428980333
F-3.291861724853516
tp782
sS'from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        pass'
p783
(F-2.0855795542399087
F-3.028024673461914
tp784
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p785
(F-2.884384765625
F-3.189285659790039
tp786
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p787
(F-3.1117589167044866
F-3.2936767578125
tp788
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p789
(F-2.953297604796707
F-3.223653030395508
tp790
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p791
(F-3.084246563655074
F-3.2901050567626955
tp792
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p793
(F-2.972121378580729
F-3.2952903747558593
tp794
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p795
(F-2.951957133278918
F-3.327447509765625
tp796
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p797
(F-2.8216734070708784
F-3.0138067245483398
tp798
sS'if (t == tuple):\n    pass'
p799
(F-2.7368492713341346
F-3.015052604675293
tp800
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p801
(F-2.9429003741290116
F-3.288521575927734
tp802
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p803
(F-2.8817508095189144
F-3.332170104980469
tp804
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p805
(F-3.0588167699550954
F-3.3605224609375
tp806
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p807
(F-3.1764022163722827
F-3.305295944213867
tp808
sS'if (t == tuple):\n    is_tuple = True'
p809
(F-3.13798994176528
F-3.035286521911621
tp810
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p811
(F-3.0706181107111044
F-3.320560836791992
tp812
sS"print 'Custom Copy:', (time() - t)\nt = time()"
p813
(F-3.6342646280924478
F-3.2723644256591795
tp814
sS'L[:]'
p815
(F-4.063699086507161
F-3.064434814453125
tp816
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p817
(F-2.936333769111223
F-3.3274696350097654
tp818
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p819
(F-3.901861337515024
F-3.1320228576660156
tp820
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p821
(F-1.9245414251013646
F-3.0076499938964845
tp822
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p823
(F-2.936484948912663
F-3.3282752990722657
tp824
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p825
(F-3.59494470666956
F-3.205622100830078
tp826
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p827
(F-3.029418047736673
F-3.3487918853759764
tp828
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p829
(F-2.7148447672526044
F-3.30023193359375
tp830
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p831
(F-2.965743955761317
F-3.3525535583496096
tp832
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p833
(F-3.050370872919284
F-3.3017604827880858
tp834
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p835
(F-3.076912434895833
F-3.325384521484375
tp836
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p837
(F-2.7138765396610385
F-3.2500194549560546
tp838
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p839
(F-3.1620287214006697
F-3.3260101318359374
tp840
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p841
(F-3.023924097521552
F-3.2983646392822266
tp842
sS'class old_class:\n\n    def __init__(self):\n        pass'
p843
(F-1.852709562882133
F-3.103581428527832
tp844
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p845
(F-3.136559276527681
F-3.328159713745117
tp846
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p847
(F-3.004258113120919
F-3.2321685791015624
tp848
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p849
(F-2.8927755644827178
F-3.0742605209350584
tp850
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p851
(F-2.9099744524274556
F-3.3138301849365233
tp852
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p853
(F-2.588686261858259
F-3.1626548767089844
tp854
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p855
(F-3.063336052563255
F-3.3673988342285157
tp856
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p857
(F-3.8174174626668296
F-3.1749187469482423
tp858
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p859
(F-2.504781750665195
F-3.165746307373047
tp860
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p861
(F-3.0765661782776283
F-3.275634765625
tp862
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p863
(F-2.980857101141238
F-3.255487060546875
tp864
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p865
(F-3.019497485871011
F-3.3394256591796876
tp866
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p867
(F-3.1752288089270477
F-3.323530578613281
tp868
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p869
(F-3.3730505666425152
F-3.0598209381103514
tp870
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p871
(F-2.4802003748276653
F-3.2584938049316405
tp872
sS"print 'list append:', (time() - t)\nt = time()"
p873
(F-3.6342646280924478
F-3.2723644256591795
tp874
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p875
(F-2.8676363188644935
F-3.311822509765625
tp876
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p877
(F-2.9924928287515664
F-3.318988800048828
tp878
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p879
(F-3.3039783477783202
F-3.2292572021484376
tp880
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p881
(F-3.4291104722297057
F-3.237557220458984
tp882
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p883
(F-2.9731106880383615
F-3.2228389739990235
tp884
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p885
(F-3.0128405862603307
F-3.292877197265625
tp886
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p887
(F-3.109206199645996
F-3.313954162597656
tp888
sS"a.append('baz')\nfoo.val = 5"
p889
(F-3.1272980826241628
F-3.0298179626464843
tp890
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p891
(F-3.0407288566468256
F-3.3422592163085936
tp892
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p893
(F-3.078551639784251
F-3.250681686401367
tp894
sS'pass'
p895
(F-2.9266134897867837
F-3.4425033569335937
tp896
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p897
(F-2.9598188257929103
F-3.3031990051269533
tp898
sS'copy.copy(L)'
p899
(F-2.980029582977295
F-3.12445182800293
tp900
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p901
(F-3.044078855586231
F-3.290288543701172
tp902
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p903
(F-2.9449332101004466
F-3.3082351684570312
tp904
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p905
(F-3.2061194303993865
F-3.003484344482422
tp906
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p907
(F-2.827574187634038
F-3.2951229095458983
tp908
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p909
(F-3.002910807291667
F-3.296833801269531
tp910
sS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p911
(F-2.774199444314708
F-2.9883234024047853
tp912
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p913
(F-3.7362818717956543
F-3.07711124420166
tp914
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p915
(F-3.3355935903695912
F-3.199026870727539
tp916
sS'if is_tuple:\n    pass'
p917
(F-2.3432561700994317
F-3.0042673110961915
tp918
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p919
(F-2.8992669748705486
F-3.314960479736328
tp920
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p921
(F-3.1363257659724884
F-3.299542999267578
tp922
sS"return obj\nif (__name__ == '__main__'):\n    import copy"
p923
(F-3.6108221756784538
F-3.1141937255859373
tp924
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p925
(F-2.7658858829074435
F-3.3001216888427733
tp926
sS"return obj\nif (__name__ == '__main__'):\n    pass"
p927
(F-2.8079081641303167
F-3.1512378692626952
tp928
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p929
(F-3.128921127319336
F-3.3022838592529298
tp930
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p931
(F-2.983650690392603
F-3.28637809753418
tp932
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p933
(F-3.096030718014564
F-3.2933692932128906
tp934
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p935
(F-2.503558588962929
F-3.15272216796875
tp936
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p937
(F-3.024690769586462
F-3.338372802734375
tp938
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p939
(F-3.2379748286033165
F-3.1503969192504884
tp940
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p941
(F-3.070801880982545
F-3.3228076934814452
tp942
sS'for i in xrange(num_times):\n    [i for i in L]'
p943
(F-2.5388669100674717
F-3.2263580322265626
tp944
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p945
(F-2.959879021895559
F-3.083724784851074
tp946
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p947
(F-3.2212918599446616
F-3.1747247695922853
tp948
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p949
(F-2.8665042676423726
F-3.206666946411133
tp950
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p951
(F-2.9723534104926737
F-3.313802719116211
tp952
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p953
(F-3.031154278197575
F-3.2983287811279296
tp954
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p955
(F-2.8831322472374716
F-3.3431446075439455
tp956
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p957
(F-2.900767224900266
F-3.233490753173828
tp958
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p959
(F-3.762954439435686
F-3.460316467285156
tp960
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p961
(F-2.978123256138393
F-3.211927032470703
tp962
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p963
(F-3.062875458688447
F-3.307306671142578
tp964
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p965
(F-3.3504778718295163
F-3.1525199890136717
tp966
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p967
(F-3.138855639121515
F-3.335457611083984
tp968
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p969
(F-2.785404920578003
F-3.1746715545654296
tp970
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p971
(F-1.225810750325521
F-3.024161148071289
tp972
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p973
(F-4.092611109956782
F-3.0990777969360352
tp974
sS"print 'list expression(L):', (time() - t)\nt = time()"
p975
(F-3.6342646280924478
F-3.2723644256591795
tp976
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p977
(F-3.086894295432351
F-3.3547958374023437
tp978
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p979
(F-2.6909913093813005
F-3.2268348693847657
tp980
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p981
(F-3.5347811070884148
F-3.129556655883789
tp982
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p983
(F-3.2807076194069604
F-3.2804771423339845
tp984
sS't = time()\nfor i in xrange(num_times):\n    L[:]'
p985
(F-3.0970187377929688
F-3.2194080352783203
tp986
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p987
(F-2.870293056841978
F-3.331246566772461
tp988
sS'for i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p989
(F-2.725747585296631
F-3.1998538970947266
tp990
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass'
p991
(F-3.7373912722565406
F-3.1688919067382812
tp992
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p993
(F-3.229400789677189
F-3.2769161224365235
tp994
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p995
(F-2.9015159606933594
F-3.287080764770508
tp996
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p997
(F-3.079096287856867
F-3.32286376953125
tp998
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p999
(F-3.098039762241634
F-3.321146774291992
tp1000
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1001
(F-2.9995920723731366
F-3.329513168334961
tp1002
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1003
(F-2.981644314585008
F-3.2985095977783203
tp1004
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1005
(F-2.993023747983186
F-3.3056640625
tp1006
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1007
(F-2.6449636298919392
F-3.0415576934814452
tp1008
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1009
(F-3.4639433137663116
F-3.079703712463379
tp1010
sS'def __init__(self, val):\n    pass'
p1011
(F-1.3965860605239868
F-3.15430908203125
tp1012
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1013
(F-3.0521374643924863
F-3.295157623291016
tp1014
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1015
(F-3.3358985849674916
F-3.2760986328125
tp1016
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        pass'
p1017
(F-1.5823499618038055
F-3.01574592590332
tp1018
sS"print 'list(L):', (time() - t)"
p1019
(F-3.2260869344075522
F-3.2515541076660157
tp1020
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1021
(F-2.867945606352517
F-3.312363052368164
tp1022
sS'Copy(L, use_deepcopy=False)'
p1023
(F-3.6059719721476235
F-3.4197559356689453
tp1024
sS'obj[k] = Copy(obj[k], use_deepcopy)'
p1025
(F-4.0705006917317705
F-3.4028785705566404
tp1026
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1027
(F-3.258145617200183
F-3.2270713806152345
tp1028
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1029
(F-3.1891619544529037
F-3.319293975830078
tp1030
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1031
(F-3.0647853105917746
F-3.2578033447265624
tp1032
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1033
(F-3.015246021504305
F-3.188351058959961
tp1034
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1035
(F-3.176680822095436
F-3.304762268066406
tp1036
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1037
(F-2.1840801816998106
F-3.0209030151367187
tp1038
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1039
(F-3.011370950493931
F-3.3089256286621094
tp1040
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1041
(F-2.854426066080729
F-3.190970230102539
tp1042
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1043
(F-2.9415843042834053
F-3.284812164306641
tp1044
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1045
(F-2.941848693602535
F-3.305775451660156
tp1046
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p1047
(F-2.8835892288773146
F-3.0235042572021484
tp1048
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1049
(F-2.620342765886759
F-3.0448583602905273
tp1050
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1051
(F-2.9476573405416966
F-3.3028736114501953
tp1052
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1053
(F-3.068564981908842
F-3.3200592041015624
tp1054
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1055
(F-3.006236399974193
F-3.2895839691162108
tp1056
sS'b = a[:]\nc = list(a)'
p1057
(F-2.2613820393880206
F-3.1355621337890627
tp1058
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1059
(F-2.7744240138841714
F-3.3115798950195314
tp1060
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1061
(F-2.9847188810022867
F-3.2986732482910157
tp1062
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1063
(F-3.1678209991894812
F-3.3213821411132813
tp1064
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1065
(F-2.9752969299720613
F-3.3063453674316405
tp1066
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1067
(F-2.9206280624657346
F-3.300078582763672
tp1068
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1069
(F-3.1467918901077963
F-3.3226062774658205
tp1070
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1071
(F-2.6401000604396914
F-3.096653366088867
tp1072
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1073
(F-2.9362932743916983
F-3.2810169219970704
tp1074
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1075
(F-2.837022771882774
F-3.329241180419922
tp1076
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1077
(F-3.0500482010514767
F-3.2988002777099608
tp1078
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1079
(F-2.9993688795301647
F-3.018169975280762
tp1080
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1081
(F-3.193697461894914
F-3.2902908325195312
tp1082
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1083
(F-2.89407211475158
F-3.210274887084961
tp1084
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p1085
(F-2.046829454826586
F-3.000343132019043
tp1086
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1087
(F-2.7314931084127987
F-3.298427963256836
tp1088
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1089
(F-2.408946058485243
F-3.13682861328125
tp1090
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1091
(F-3.0395425730738146
F-3.2375766754150392
tp1092
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1093
(F-2.9680550427940804
F-3.3279369354248045
tp1094
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p1095
(F-2.806501305621603
F-3.179269027709961
tp1096
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1097
(F-3.9993178204792303
F-3.0268325805664062
tp1098
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1099
(F-2.921432826829993
F-3.3136016845703127
tp1100
sS'return obj'
p1101
(F-5.7922539710998535
F-3.1305728912353517
tp1102
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1103
(F-2.984650494301156
F-3.323316955566406
tp1104
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1105
(F-2.9824547237820096
F-3.36132698059082
tp1106
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1107
(F-3.0847234816778273
F-3.3171043395996094
tp1108
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1109
(F-3.1277680358055178
F-3.3421756744384767
tp1110
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1111
(F-2.9339372350814497
F-3.2737449645996093
tp1112
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1113
(F-2.969825674634461
F-3.2901519775390624
tp1114
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1115
(F-2.9094581886574074
F-3.3241729736328125
tp1116
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1117
(F-3.0523177083333333
F-3.2995883941650392
tp1118
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1119
(F-2.753254672937226
F-3.1431636810302734
tp1120
sS'def __repr__(self):\n    pass'
p1121
(F-1.3593033381870814
F-3.113538932800293
tp1122
sS'class old_class:\n    pass'
p1123
(F-3.371116291392933
F-3.120041084289551
tp1124
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1125
(F-2.905241341426455
F-3.307051086425781
tp1126
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p1127
(F-3.163064936155914
F-3.0010147094726562
tp1128
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1129
(F-3.0987089349982444
F-3.3478157043457033
tp1130
sS't = time()\nfor i in xrange(num_times):\n    a = []'
p1131
(F-2.580633544921875
F-3.1754058837890624
tp1132
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1133
(F-2.819227818080357
F-3.3002967834472656
tp1134
sS'b = a[:]'
p1135
(F-2.3743858337402344
F-3.1739738464355467
tp1136
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1137
(F-3.034696306501116
F-3.3435020446777344
tp1138
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1139
(F-3.2451404047947303
F-3.2893402099609377
tp1140
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1141
(F-2.982146665274379
F-3.288127899169922
tp1142
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1143
(F-3.0351865381226504
F-3.3192302703857424
tp1144
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1145
(F-2.8556430957935475
F-3.3431591033935546
tp1146
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1147
(F-3.0373547182881775
F-3.3414066314697264
tp1148
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1149
(F-3.0247027904956374
F-3.370008087158203
tp1150
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1151
(F-2.9374257680532097
F-3.306340789794922
tp1152
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1153
(F-2.7675883769989014
F-3.2021636962890625
tp1154
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1155
(F-2.8943250424393985
F-3.3400360107421876
tp1156
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p1157
(F-2.8116212801168894
F-3.025726318359375
tp1158
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1159
(F-2.918850164038897
F-3.3033977508544923
tp1160
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1161
(F-3.241117883901127
F-3.2856929779052733
tp1162
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p1163
(F-1.8949953715006511
F-3.0116340637207033
tp1164
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1165
(F-3.4013853726321703
F-3.2551456451416017
tp1166
sS"print 'list append:', (time() - t)"
p1167
(F-3.2260869344075522
F-3.2515541076660157
tp1168
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1169
(F-3.085444775577706
F-3.335905075073242
tp1170
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1171
(F-3.1309972426470587
F-3.2403549194335937
tp1172
sS'class new_class(object):\n\n    def __init__(self):\n        pass'
p1173
(F-1.6156294896052434
F-3.065900421142578
tp1174
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1175
(F-2.918895841899671
F-3.3246231079101562
tp1176
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1177
(F-2.8957840890595405
F-3.2055057525634765
tp1178
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1179
(F-2.801365727963655
F-3.3339988708496096
tp1180
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1181
(F-2.9817704713217306
F-3.3041664123535157
tp1182
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1183
(F-2.9219604068332248
F-3.1615230560302736
tp1184
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1185
(F-2.721679426665999
F-3.251799774169922
tp1186
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1187
(F-2.874843631170492
F-3.2934803009033202
tp1188
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1189
(F-2.9964725167410715
F-3.2738407135009764
tp1190
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1191
(F-2.830474369109623
F-3.293721008300781
tp1192
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1193
(F-2.9415204549573133
F-3.2625179290771484
tp1194
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1195
(F-3.08233496386134
F-3.361347198486328
tp1196
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1197
(F-2.9904418296002326
F-3.30570068359375
tp1198
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1199
(F-2.9265300958806817
F-3.314869689941406
tp1200
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1201
(F-3.1296499343145463
F-3.232379150390625
tp1202
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1203
(F-3.021515732511468
F-3.324350357055664
tp1204
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1205
(F-2.806107804581926
F-3.159889030456543
tp1206
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1207
(F-3.0087955918422966
F-3.2986095428466795
tp1208
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1209
(F-2.793275303994456
F-3.311066818237305
tp1210
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p1211
(F-2.814878983931108
F-3.27354736328125
tp1212
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1213
(F-2.532750216397372
F-3.051606369018555
tp1214
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1215
(F-3.2217067443218426
F-3.1604408264160155
tp1216
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1217
(F-3.2515256669786243
F-3.2730621337890624
tp1218
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1219
(F-2.8327790471433683
F-3.232868957519531
tp1220
sS't = time()\nfor i in xrange(num_times):\n    Copy(L)'
p1221
(F-2.519700927734375
F-3.365304183959961
tp1222
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1223
(F-3.0183040364583333
F-3.3074413299560548
tp1224
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1225
(F-2.830809093656994
F-3.263151168823242
tp1226
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1227
(F-3.709356856672731
F-3.05247802734375
tp1228
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1229
(F-2.6124058865952766
F-3.207989501953125
tp1230
sS'e = copy.deepcopy(a)'
p1231
(F-2.783288764953613
F-2.9866992950439455
tp1232
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1233
(F-3.1469458204172254
F-3.3426334381103517
tp1234
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1235
(F-2.990493894562008
F-3.320263671875
tp1236
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1237
(F-2.9467175542091835
F-3.145335578918457
tp1238
sS"print 'copy.copy:', (time() - t)"
p1239
(F-3.2260869344075522
F-3.2515541076660157
tp1240
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1241
(F-2.999445988581731
F-3.290292739868164
tp1242
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1243
(F-2.4508280754089355
F-3.161531448364258
tp1244
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1245
(F-3.0291169689547632
F-3.334061050415039
tp1246
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1247
(F-2.8355822355850884
F-3.2716175079345704
tp1248
sS'for i in xrange(num_times):\n    copy.deepcopy(L)'
p1249
(F-2.119680858793713
F-3.0873529434204103
tp1250
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1251
(F-3.444443347407322
F-3.2421806335449217
tp1252
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1253
(F-2.7067252022879464
F-3.059940719604492
tp1254
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1255
(F-2.920717153976213
F-3.325438690185547
tp1256
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1257
(F-3.0769056412617015
F-3.32122802734375
tp1258
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1259
(F-2.9105866207604523
F-3.319174957275391
tp1260
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1261
(F-1.7405492146809896
F-3.0277210235595704
tp1262
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1263
(F-3.0376312535837156
F-3.2838466644287108
tp1264
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1265
(F-2.958715504613416
F-3.2287151336669924
tp1266
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1267
(F-2.9553525390625
F-3.3243453979492186
tp1268
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1269
(F-3.07037132144592
F-3.3189933776855467
tp1270
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1271
(F-2.989092179840686
F-3.3078166961669924
tp1272
sS'def __init__(self, val):\n    self.val = val'
p1273
(F-1.4805633544921875
F-3.098917770385742
tp1274
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1275
(F-2.7562054951985675
F-3.283483123779297
tp1276
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1277
(F-3.126208799105164
F-3.2820068359375
tp1278
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1279
(F-2.819933819514449
F-3.202016067504883
tp1280
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p1281
(F-2.319056975535857
F-3.0370954513549804
tp1282
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1283
(F-3.4579181523286096
F-3.2646415710449217
tp1284
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1285
(F-2.5875926115074934
F-3.038066864013672
tp1286
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1287
(F-2.740854735015541
F-3.2024139404296874
tp1288
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1289
(F-2.9540813400084716
F-3.2644882202148438
tp1290
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1291
(F-2.8487037336322625
F-3.2846168518066405
tp1292
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1293
(F-3.0700176936323924
F-3.3375099182128904
tp1294
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1295
(F-3.0143391337371677
F-3.283231735229492
tp1296
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1297
(F-3.1826249792220747
F-3.3226470947265625
tp1298
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1299
(F-2.982020366622741
F-3.2941890716552735
tp1300
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1301
(F-3.0345950879548726
F-3.182028579711914
tp1302
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1303
(F-2.756771511501736
F-3.2211685180664062
tp1304
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1305
(F-2.9293473072541065
F-3.3322219848632812
tp1306
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1307
(F-2.7457824021242976
F-3.288618469238281
tp1308
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1309
(F-3.0972722041142453
F-3.3364654541015626
tp1310
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1311
(F-2.990562022816051
F-3.320607376098633
tp1312
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1313
(F-2.9169053773622253
F-3.2469402313232423
tp1314
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1315
(F-3.1638243140243905
F-3.2909519195556642
tp1316
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1317
(F-3.2850413602941178
F-3.2985202789306642
tp1318
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1319
(F-3.411285945347377
F-3.2970001220703127
tp1320
sS'a.extend(L)'
p1321
(F-2.277947425842285
F-3.1888757705688477
tp1322
sS'for y in L:\n    a.append(y)'
p1323
(F-1.8264696598052979
F-3.089954376220703
tp1324
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1325
(F-3.053615204275471
F-3.2828601837158202
tp1326
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1327
(F-2.6919131588626217
F-3.2445758819580077
tp1328
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1329
(F-3.0746931853117765
F-3.2528564453125
tp1330
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1331
(F-4.08469635585569
F-3.0859676361083985
tp1332
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1333
(F-2.9983107288431676
F-3.2855148315429688
tp1334
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1335
(F-3.156378989277581
F-3.268390655517578
tp1336
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1337
(F-2.8632079167152518
F-3.2968990325927736
tp1338
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1339
(F-3.0496002197265626
F-3.237493896484375
tp1340
sS'if (type(obj[x]) in dignore):\n    pass'
p1341
(F-2.606205990439967
F-3.027574157714844
tp1342
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1343
(F-3.0850187440963475
F-3.3145687103271486
tp1344
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1345
(F-2.9036749301675977
F-3.3342594146728515
tp1346
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p1347
(F-1.717678931451613
F-3.016030502319336
tp1348
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1349
(F-3.0197714443864494
F-3.2076454162597656
tp1350
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1351
(F-2.9165118963068184
F-3.3263214111328123
tp1352
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1353
(F-2.6025173302852744
F-3.254250335693359
tp1354
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1355
(F-3.297439193725586
F-3.271598052978516
tp1356
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1357
(F-3.3288916532324735
F-3.271367645263672
tp1358
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1359
(F-2.8967767140221974
F-3.252740478515625
tp1360
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1361
(F-2.823798725623211
F-3.284113311767578
tp1362
sS"print 'Custom Copy:', (time() - t)"
p1363
(F-3.2260869344075522
F-3.2515541076660157
tp1364
sS'c = list(a)'
p1365
(F-2.232936143875122
F-3.0313690185546873
tp1366
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1367
(F-2.7938485193734217
F-3.33375244140625
tp1368
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1369
(F-2.973572777920082
F-3.3007366180419924
tp1370
sS'import copy\n\n\nclass Foo(object):\n    pass'
p1371
(F-2.031076767865349
F-3.0193546295166014
tp1372
sS"foo = Foo(1)\na = ['foo', foo]"
p1373
(F-4.22853946685791
F-2.9938180923461912
tp1374
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1375
(F-2.9767477101293105
F-3.273269271850586
tp1376
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1377
(F-3.2984272484640473
F-3.2136436462402345
tp1378
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1379
(F-3.1809898171845066
F-3.2650341033935546
tp1380
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1381
(F-2.7800989975163968
F-3.3242076873779296
tp1382
sS'for i in xrange(num_times):\n    L[:]'
p1383
(F-2.913332085860403
F-3.1654899597167967
tp1384
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1385
(F-2.5510231300636574
F-3.102507209777832
tp1386
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1387
(F-3.0565415419541395
F-3.2377010345458985
tp1388
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1389
(F-2.716387488625266
F-3.221099090576172
tp1390
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1391
(F-3.263670794731748
F-3.2756793975830076
tp1392
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1393
(F-3.15351641619647
F-3.0110116958618165
tp1394
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1395
(F-3.156933349609375
F-3.2648635864257813
tp1396
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1397
(F-2.7181453704833984
F-3.2356822967529295
tp1398
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1399
(F-3.0986030392530486
F-3.304352951049805
tp1400
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1401
(F-2.982287497186857
F-3.3143218994140624
tp1402
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1403
(F-3.647921932444853
F-3.071055603027344
tp1404
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1405
(F-3.0523958478655135
F-3.246926498413086
tp1406
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1407
(F-3.6174247048117896
F-3.1877361297607423
tp1408
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1409
(F-2.9410895070722027
F-3.329354476928711
tp1410
sS'from time import time\nnum_times = 100000'
p1411
(F-4.167303085327148
F-3.453042221069336
tp1412
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1413
(F-3.0715383714245212
F-3.1230770111083985
tp1414
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)'
p1415
(F-2.591914176940918
F-3.224867248535156
tp1416
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1417
(F-2.9068270834730416
F-3.3462799072265623
tp1418
sS'if is_tuple:\n    obj = tuple(obj)'
p1419
(F-2.9725992679595947
F-3.005951690673828
tp1420
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1421
(F-3.1595636183215725
F-3.290828323364258
tp1422
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1423
(F-3.0666763190936326
F-3.2858795166015624
tp1424
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1425
(F-2.8603675045184236
F-3.221237564086914
tp1426
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1427
(F-3.097029549734933
F-3.333505630493164
tp1428
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1429
(F-2.9826158627059107
F-3.2872085571289062
tp1430
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1431
(F-3.028214518229167
F-3.2915096282958984
tp1432
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1433
(F-3.190097730986926
F-3.3205795288085938
tp1434
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1435
(F-3.0992374420166016
F-3.2682395935058595
tp1436
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1437
(F-2.974632105334052
F-3.292631912231445
tp1438
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1439
(F-3.059848541909076
F-3.3598522186279296
tp1440
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1441
(F-2.800593376159668
F-3.181502342224121
tp1442
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1443
(F-2.6025173302852744
F-3.254250335693359
tp1444
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1445
(F-3.0904627386129127
F-3.2489273071289064
tp1446
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1447
(F-3.1353893094849816
F-3.2884811401367187
tp1448
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1449
(F-3.106768063849804
F-3.3053268432617187
tp1450
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1451
(F-2.92852783203125
F-3.304545593261719
tp1452
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1453
(F-3.1220207767210146
F-3.3220863342285156
tp1454
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1455
(F-3.14452756331271
F-3.317465972900391
tp1456
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1457
(F-2.83100665057147
F-3.2575153350830077
tp1458
sS'c = list(a)\nd = copy.copy(a)'
p1459
(F-2.6333952511058136
F-3.0962095260620117
tp1460
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1461
(F-3.0572507858276365
F-3.2806121826171877
tp1462
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1463
(F-3.0394426364343143
F-3.298778533935547
tp1464
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1465
(F-2.963346466304749
F-3.3035232543945314
tp1466
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1467
(F-2.9625784737723215
F-3.3021141052246095
tp1468
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1469
(F-2.944999786744635
F-3.3400508880615236
tp1470
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1471
(F-2.947811362184124
F-3.2595653533935547
tp1472
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1473
(F-3.163231102195946
F-3.3226226806640624
tp1474
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1475
(F-3.035884962556112
F-3.307726287841797
tp1476
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1477
(F-2.703749254014757
F-3.228831100463867
tp1478
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1479
(F-2.67693599577873
F-3.1398504257202147
tp1480
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1481
(F-2.941425835908349
F-3.277263641357422
tp1482
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1483
(F-2.994601990125194
F-3.3342971801757812
tp1484
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1485
(F-2.9782343997231013
F-3.2507999420166014
tp1486
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1487
(F-3.0908753517592884
F-3.2872894287109373
tp1488
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1489
(F-3.0735451989140072
F-3.3360618591308593
tp1490
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1491
(F-2.622708740234375
F-3.0681249618530275
tp1492
sS'import copy\nnew_list = copy.deepcopy(old_list)'
p1493
(F-2.3943315393784466
F-3.0155929565429687
tp1494
sS'class Foo(object):\n    pass'
p1495
(F-1.6167132059733074
F-3.0863620758056642
tp1496
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1497
(F-3.248001918997816
F-3.2902454376220702
tp1498
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1499
(F-2.8370377735425065
F-3.221563720703125
tp1500
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1501
(F-3.34967041015625
F-3.250375747680664
tp1502
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1503
(F-2.9479583589901477
F-3.3187389373779297
tp1504
sS't = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)'
p1505
(F-2.4623240718135126
F-3.1109546661376952
tp1506
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1507
(F-2.8635942285711113
F-3.272212600708008
tp1508
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1509
(F-2.7641955659589694
F-3.2927711486816404
tp1510
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1511
(F-2.637711129537443
F-3.2051681518554687
tp1512
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1513
(F-2.8852161911298646
F-3.2610710144042967
tp1514
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1515
(F-3.093258792406892
F-3.218941879272461
tp1516
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1517
(F-3.204634956691576
F-3.2303890228271483
tp1518
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1519
(F-3.0845824650355746
F-3.2825523376464845
tp1520
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1521
(F-2.9453977857317244
F-3.197433853149414
tp1522
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p1523
(F-2.839862999549279
F-3.234244155883789
tp1524
sS'num_times = 100000'
p1525
(F-5.1820526123046875
F-3.353757858276367
tp1526
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1527
(F-2.954880478802849
F-3.2976005554199217
tp1528
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1529
(F-2.845340080980985
F-3.218458557128906
tp1530
sS'a.append(y)'
p1531
(F-1.8133537769317627
F-3.041423034667969
tp1532
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1533
(F-2.854426066080729
F-3.190970230102539
tp1534
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1535
(F-3.148416519165039
F-3.319057846069336
tp1536
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1537
(F-3.0674434500330823
F-3.3264389038085938
tp1538
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1539
(F-3.0108092261142416
F-3.274342346191406
tp1540
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1541
(F-3.2265280646246834
F-3.3040889739990233
tp1542
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1543
(F-2.9248153023097827
F-3.311946487426758
tp1544
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1545
(F-3.0907319304230927
F-3.0186418533325194
tp1546
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1547
(F-2.9767675342674025
F-3.3039215087890623
tp1548
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1549
(F-3.215055193219866
F-3.231578826904297
tp1550
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1551
(F-3.2884492792634883
F-3.3212047576904298
tp1552
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1553
(F-2.9341583251953125
F-3.2815692901611326
tp1554
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1555
(F-2.573201017559699
F-3.2679283142089846
tp1556
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1557
(F-3.014116499159071
F-3.3283157348632812
tp1558
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1559
(F-2.983856201171875
F-3.3126895904541014
tp1560
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1561
(F-3.208266391549059
F-3.2748157501220705
tp1562
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1563
(F-2.9793335670648617
F-3.3378879547119142
tp1564
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1565
(F-3.212660197970233
F-3.229043960571289
tp1566
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1567
(F-3.0859998477402555
F-3.3280059814453127
tp1568
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1569
(F-2.831129738136574
F-3.2473388671875
tp1570
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1571
(F-2.895622802734375
F-3.270682144165039
tp1572
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1573
(F-2.63611054002193
F-3.2576553344726564
tp1574
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1575
(F-3.598924379091005
F-3.0700897216796874
tp1576
sS'for i in xrange(num_times):\n    a = []\na.extend(L)'
p1577
(F-2.2759824899526744
F-3.1991657257080077
tp1578
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1579
(F-2.951626556088226
F-3.3105236053466798
tp1580
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1581
(F-2.8785045726879224
F-3.323052978515625
tp1582
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1583
(F-2.9845122697288424
F-3.337736129760742
tp1584
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1585
(F-2.898438122807717
F-3.295608901977539
tp1586
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)"
p1587
(F-2.5702101665994395
F-3.0865684509277345
tp1588
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1589
(F-2.660776491518374
F-3.2703475952148438
tp1590
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1591
(F-2.9577712561251848
F-3.2634281158447265
tp1592
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1593
(F-2.76588134765625
F-3.292127227783203
tp1594
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1595
(F-2.993901097497275
F-3.2739097595214846
tp1596
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1597
(F-2.886835474167427
F-3.2480709075927736
tp1598
sS"if (__name__ == '__main__'):\n    pass"
p1599
(F-1.7831123352050782
F-3.268680191040039
tp1600
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1601
(F-2.9744574273382867
F-3.3216529846191407
tp1602
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1603
(F-3.079662109375
F-3.2947540283203125
tp1604
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1605
(F-3.0906181685421443
F-3.3156784057617186
tp1606
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1607
(F-2.808169962565104
F-3.3155582427978514
tp1608
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1609
(F-3.10865441147162
F-3.1735374450683596
tp1610
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1611
(F-3.226866595512998
F-3.249110794067383
tp1612
sS"print 'copy.copy:', (time() - t)\nt = time()"
p1613
(F-3.6342646280924478
F-3.2723644256591795
tp1614
sS'import copy\nnew_list = copy.copy(old_list)'
p1615
(F-2.6098217683679916
F-3.0854625701904297
tp1616
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1617
(F-2.8737468013057
F-3.0870609283447266
tp1618
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1619
(F-2.943597903196839
F-3.3048755645751955
tp1620
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1621
(F-2.812380777994792
F-3.2334430694580076
tp1622
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1623
(F-3.016975497022087
F-3.1959907531738283
tp1624
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1625
(F-3.0427298597110215
F-3.270587158203125
tp1626
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1627
(F-3.469594975953461
F-3.244109344482422
tp1628
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1629
(F-3.017927531954608
F-3.2404243469238283
tp1630
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1631
(F-3.179331789734543
F-3.303472900390625
tp1632
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1633
(F-3.691011657714844
F-3.1533674240112304
tp1634
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1635
(F-3.0121243990384614
F-3.3322357177734374
tp1636
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1637
(F-3.0104463084644038
F-3.2848236083984377
tp1638
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1639
(F-2.992911960767663
F-3.259510803222656
tp1640
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1641
(F-2.9475157981695133
F-3.2112388610839844
tp1642
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1643
(F-2.78062392726089
F-3.216405487060547
tp1644
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p1645
(F-2.8914006192919235
F-3.012923240661621
tp1646
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1647
(F-3.1385062636843153
F-3.3367893218994142
tp1648
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1649
(F-3.0050751019421043
F-3.311395263671875
tp1650
sS"a = ['foo', foo]\nb = a[:]"
p1651
(F-2.810150384902954
F-3.0538002014160157
tp1652
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1653
(F-2.1848438609730114
F-3.0144628524780273
tp1654
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1655
(F-3.1735531277126734
F-3.2274436950683594
tp1656
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1657
(F-2.671809164325843
F-3.057867240905762
tp1658
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1659
(F-3.105018947435462
F-3.2877391815185546
tp1660
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1661
(F-3.1219916380274935
F-3.3323528289794924
tp1662
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1663
(F-2.6139436919113685
F-3.029158592224121
tp1664
sS"def __init__(self):\n    self.blah = 'blah'"
p1665
(F-1.6508547465006511
F-3.09371280670166
tp1666
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1667
(F-3.1173089629975124
F-3.3089752197265625
tp1668
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1669
(F-2.8530122275664427
F-3.3423297882080076
tp1670
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1671
(F-2.94543060054624
F-3.3058570861816405
tp1672
sS't = type(obj)'
p1673
(F-3.875032424926758
F-3.164645767211914
tp1674
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1675
(F-3.303541660308838
F-3.3074462890625
tp1676
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1677
(F-2.810189016241776
F-3.3260471343994142
tp1678
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1679
(F-3.0545232937420685
F-3.2715965270996095
tp1680
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1681
(F-2.9625256108302698
F-3.3022796630859377
tp1682
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1683
(F-2.772062995217063
F-3.230097198486328
tp1684
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1685
(F-3.15089111328125
F-3.2358123779296877
tp1686
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1687
(F-3.09175907799957
F-3.3069881439208983
tp1688
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1689
(F-2.591427436241737
F-3.0410478591918944
tp1690
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p1691
(F-2.812278053977273
F-3.0348371505737304
tp1692
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1693
(F-3.186816334019046
F-3.286588668823242
tp1694
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1695
(F-3.124441727347996
F-3.3275119781494142
tp1696
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1697
(F-2.727736166857798
F-3.2978183746337892
tp1698
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1699
(F-2.837658250188253
F-3.2903987884521486
tp1700
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1701
(F-2.9227827703673706
F-3.3274959564208983
tp1702
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1703
(F-3.0536182817206323
F-3.2955432891845704
tp1704
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1705
(F-3.161868008700284
F-3.3297046661376952
tp1706
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1707
(F-3.2260869344075522
F-3.2515541076660157
tp1708
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1709
(F-3.434113753469367
F-3.25723876953125
tp1710
sS"self.blah = 'blah'"
p1711
(F-3.924874714442662
F-3.097148132324219
tp1712
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1713
(F-2.173381581025965
F-3.008268928527832
tp1714
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p1715
(F-1.3791695334694603
F-3.014551544189453
tp1716
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1717
(F-3.2762481894269087
F-3.2731868743896486
tp1718
sS'for i in xrange(num_times):\n    copy.copy(L)'
p1719
(F-2.1612062000093006
F-3.204163360595703
tp1720
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1721
(F-2.984511515299479
F-3.1975059509277344
tp1722
sS'from copy import deepcopy\n\n\nclass old_class:\n    pass'
p1723
(F-3.1140189700656467
F-3.009940338134766
tp1724
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1725
(F-2.48690434506065
F-3.224558639526367
tp1726
sS'for x in xrange(len(obj)):\n    pass'
p1727
(F-1.65679090163287
F-3.022184944152832
tp1728
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1729
(F-2.9438444696755774
F-3.350925064086914
tp1730
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1731
(F-2.942133072319381
F-3.3105072021484374
tp1732
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1733
(F-3.232815636528863
F-3.2168354034423827
tp1734
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1735
(F-2.987808381668245
F-3.3239269256591797
tp1736
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1737
(F-3.235033195970696
F-3.306280517578125
tp1738
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1739
(F-2.6025173302852744
F-3.254250335693359
tp1740
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1741
(F-3.571695839486471
F-3.1814552307128907
tp1742
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1743
(F-3.0492050022754853
F-3.30091552734375
tp1744
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1745
(F-3.0759796899212293
F-3.3215049743652343
tp1746
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1747
(F-2.765405520044192
F-3.284328842163086
tp1748
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1749
(F-3.02543510824947
F-3.305916595458984
tp1750
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1751
(F-2.8285310164741846
F-3.1956939697265625
tp1752
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1753
(F-2.0927755373333574
F-3.007493019104004
tp1754
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1755
(F-3.231276505476945
F-3.2318859100341797
tp1756
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1757
(F-3.1792023147361865
F-3.307485580444336
tp1758
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1759
(F-2.891400146484375
F-3.2757720947265625
tp1760
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1761
(F-3.017690420150757
F-3.3099334716796873
tp1762
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1763
(F-3.1764448797423706
F-3.2867183685302734
tp1764
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1765
(F-2.987982893789281
F-3.2996021270751954
tp1766
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p1767
(F-2.0471505924147
F-3.1157459259033202
tp1768
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1769
(F-2.9560266584797477
F-3.312890625
tp1770
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1771
(F-2.9679508418827267
F-3.30064697265625
tp1772
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1773
(F-2.9603312045713013
F-3.287508010864258
tp1774
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1775
(F-2.9911107262899708
F-3.332611083984375
tp1776
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1777
(F-2.9889596254770994
F-3.3028839111328123
tp1778
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1779
(F-3.102897780630595
F-3.3479381561279298
tp1780
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1781
(F-3.095455071864984
F-3.067158508300781
tp1782
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1783
(F-2.924650753245634
F-3.2596302032470703
tp1784
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1785
(F-3.0919581326571377
F-3.2167423248291014
tp1786
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1787
(F-3.678484403170072
F-3.074041748046875
tp1788
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1789
(F-2.9596832182632027
F-3.306121063232422
tp1790
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1791
(F-2.70522964209841
F-3.254754638671875
tp1792
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1793
(F-2.8718162933526012
F-3.3211528778076174
tp1794
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1795
(F-3.0888878809262628
F-3.2206661224365236
tp1796
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1797
(F-3.1685106489393444
F-3.2840099334716797
tp1798
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1799
(F-3.2124928792317706
F-3.2847156524658203
tp1800
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1801
(F-2.93391540708457
F-3.3027999877929686
tp1802
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1803
(F-3.052104949951172
F-3.290147399902344
tp1804
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1805
(F-3.097645826018258
F-3.3167625427246095
tp1806
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1807
(F-3.0656850035761445
F-3.271961975097656
tp1808
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1809
(F-2.9020375218884698
F-3.3551651000976563
tp1810
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1811
(F-3.154514676802386
F-3.2885311126708983
tp1812
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1813
(F-2.9495525621388055
F-3.224834442138672
tp1814
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1815
(F-3.2404857211642795
F-3.224070739746094
tp1816
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1817
(F-3.251378026501886
F-3.296041488647461
tp1818
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1819
(F-2.816143922131471
F-3.2236045837402343
tp1820
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1821
(F-2.9991710277384582
F-3.30374755859375
tp1822
sS'foo = Foo(1)'
p1823
(F-4.010275840759277
F-3.0512739181518556
tp1824
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1825
(F-2.858881632486979
F-3.2692291259765627
tp1826
sS"print 'copy.deepcopy:', (time() - t)\nt = time()"
p1827
(F-3.6342646280924478
F-3.2723644256591795
tp1828
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1829
(F-3.0880349524935387
F-3.2269073486328126
tp1830
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1831
(F-3.352634645857901
F-3.150149917602539
tp1832
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1833
(F-2.73213619656033
F-3.225666809082031
tp1834
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1835
(F-3.0226862707803415
F-3.1451391220092773
tp1836
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1837
(F-3.0940501933195153
F-3.2616512298583986
tp1838
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1839
(F-3.0329022763380364
F-3.206349182128906
tp1840
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1841
(F-3.4764934339021383
F-3.121590423583984
tp1842
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1843
(F-3.1943052217557835
F-3.271562957763672
tp1844
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1845
(F-3.17103422753062
F-3.2895885467529298
tp1846
sS'new_list = old_list[:]'
p1847
(F-2.421266714731852
F-3.081250762939453
tp1848
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1849
(F-2.949824850357587
F-3.280173110961914
tp1850
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1851
(F-3.136545683208265
F-3.0822505950927734
tp1852
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1853
(F-2.9974543195650627
F-3.3549449920654295
tp1854
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1855
(F-3.006532457139757
F-3.1768041610717774
tp1856
sS'obj[x] = Copy(obj[x], use_deepcopy)'
p1857
(F-4.138344234890408
F-3.5788646697998048
tp1858
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1859
(F-2.8751405569223256
F-3.328189468383789
tp1860
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1861
(F-3.0402084006402728
F-3.304766845703125
tp1862
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1863
(F-2.8072304725646973
F-3.0229333877563476
tp1864
sS'class new_class(object):\n    pass'
p1865
(F-2.3257083892822266
F-3.0864063262939454
tp1866
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1867
(F-2.7856473650251115
F-3.297247314453125
tp1868
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1869
(F-2.9397520876216316
F-3.2983066558837892
tp1870
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p1871
(F-2.7422662130216273
F-3.1438385009765626
tp1872
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1873
(F-3.162652822641226
F-3.306792068481445
tp1874
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1875
(F-3.33984816217997
F-3.2750995635986326
tp1876
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1877
(F-3.0037911837218236
F-3.340060806274414
tp1878
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1879
(F-3.015010135274538
F-3.2884273529052734
tp1880
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1881
(F-2.8180434535926495
F-3.2846454620361327
tp1882
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p1883
(F-4.015722910563151
F-3.148868942260742
tp1884
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1885
(F-2.9027182089315877
F-3.288040542602539
tp1886
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1887
(F-3.0098110409233514
F-3.2235649108886717
tp1888
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1889
(F-3.06348904350452
F-3.343882751464844
tp1890
sS'from time import time'
p1891
(F-4.1410064697265625
F-3.4202308654785156
tp1892
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1893
(F-3.1298464120152487
F-3.3594261169433595
tp1894
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1895
(F-3.1141878453696648
F-3.282470703125
tp1896
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1897
(F-3.17557610405816
F-3.2820507049560548
tp1898
sS'import copy'
p1899
(F-5.46120548248291
F-3.2127090454101563
tp1900
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1901
(F-2.6685699462890624
F-3.0215404510498045
tp1902
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1903
(F-3.1339725542672072
F-3.3525970458984373
tp1904
sS'if (t in (list, tuple)):\n    pass'
p1905
(F-3.03614335901597
F-3.0540313720703125
tp1906
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1907
(F-3.421109154110863
F-3.2370861053466795
tp1908
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1909
(F-3.105952984720304
F-3.3014877319335936
tp1910
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1911
(F-3.0692833906767385
F-3.2452144622802734
tp1912
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1913
(F-3.0563948178860922
F-3.3503868103027346
tp1914
sS'self.val = val'
p1915
(F-3.2567806243896484
F-3.145328712463379
tp1916
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1917
(F-2.927875370942345
F-3.2877128601074217
tp1918
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1919
(F-3.007478060787671
F-3.300035858154297
tp1920
sS'list(L)'
p1921
(F-2.035118738810221
F-3.0413738250732423
tp1922
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1923
(F-3.1187135732857283
F-3.3154541015625
tp1924
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1925
(F-3.0128965831938244
F-3.233265686035156
tp1926
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1927
(F-2.959390314275568
F-3.306881332397461
tp1928
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1929
(F-2.9752801691444173
F-3.317499542236328
tp1930
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1931
(F-2.959647981033109
F-3.3015350341796874
tp1932
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1933
(F-2.952079441236413
F-3.2985183715820314
tp1934
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1935
(F-2.920574889932588
F-3.2941043853759764
tp1936
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1937
(F-3.004808349609375
F-3.1784902572631837
tp1938
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1939
(F-2.833907859912817
F-3.2036571502685547
tp1940
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1941
(F-3.017206639419367
F-3.261920928955078
tp1942
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1943
(F-2.7776603407532203
F-3.2894874572753907
tp1944
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1945
(F-3.0052238670555322
F-3.250937271118164
tp1946
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1947
(F-2.968353788731462
F-3.2943775177001955
tp1948
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1949
(F-1.6816410196238551
F-3.1784271240234374
tp1950
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1951
(F-2.8973874918619793
F-3.2675552368164062
tp1952
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1953
(F-3.233213636610243
F-3.246487045288086
tp1954
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1955
(F-2.911553134437369
F-3.310589599609375
tp1956
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p1957
(F-2.7186737060546875
F-3.099182891845703
tp1958
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1959
(F-2.6433721318975225
F-3.2222599029541015
tp1960
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1961
(F-2.6753665857147753
F-3.341951370239258
tp1962
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1963
(F-2.919517339662064
F-3.1821149826049804
tp1964
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1965
(F-1.976610678213614
F-3.042733383178711
tp1966
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1967
(F-3.051177978515625
F-3.2624515533447265
tp1968
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1969
(F-3.1285083128674196
F-3.30452880859375
tp1970
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1971
(F-3.284913083340259
F-3.2266471862792967
tp1972
sS'[i for i in L]'
p1973
(F-2.6798523796929254
F-3.1664865493774412
tp1974
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1975
(F-3.1965118892609126
F-3.318126678466797
tp1976
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p1977
(F-1.9886300223214286
F-2.9968685150146483
tp1978
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1979
(F-2.6025173302852744
F-3.254250335693359
tp1980
sS't = time()'
p1981
(F-4.03106198992048
F-3.2915557861328124
tp1982
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1983
(F-3.1722393669750755
F-3.3419185638427735
tp1984
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1985
(F-3.181087586937881
F-3.2393550872802734
tp1986
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1987
(F-3.0200341796875
F-3.333396148681641
tp1988
sS't = time()\nfor i in xrange(num_times):\n    [i for i in L]'
p1989
(F-2.7576206752232144
F-3.2380550384521483
tp1990
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1991
(F-2.955109546802662
F-3.3281631469726562
tp1992
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1993
(F-3.034113738496425
F-3.3193077087402343
tp1994
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1995
(F-3.0540463027133735
F-3.3146480560302733
tp1996
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1997
(F-3.1390048828125
F-3.277103805541992
tp1998
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p1999
(F-3.2294129488760963
F-3.0085704803466795
tp2000
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p2001
(F-2.2481575990334535
F-3.0433244705200195
tp2002
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2003
(F-2.1036580403645835
F-3.007031059265137
tp2004
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2005
(F-2.944848114589475
F-3.327001190185547
tp2006
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2007
(F-2.6963058997844827
F-3.219934844970703
tp2008
sS'is_tuple = True'
p2009
(F-4.082812990461077
F-3.038915252685547
tp2010
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2011
(F-2.7094448012793624
F-3.3005626678466795
tp2012
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2013
(F-3.4402738131009616
F-3.129100036621094
tp2014
sS'copy.deepcopy(L)'
p2015
(F-2.641183614730835
F-3.0048118591308595
tp2016
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2017
(F-3.081539602840648
F-3.287881088256836
tp2018
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2019
(F-2.7987792036915553
F-3.2999061584472655
tp2020
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2021
(F-3.3606785668267145
F-3.1831865310668945
tp2022
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2023
(F-2.7835194998924884
F-3.1918405532836913
tp2024
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2025
(F-2.6880286229799872
F-3.3042724609375
tp2026
sS'd = copy.copy(a)\ne = copy.deepcopy(a)'
p2027
(F-2.7573685897024056
F-3.037876510620117
tp2028
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2029
(F-2.0148752997903263
F-3.165438652038574
tp2030
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2031
(F-3.0840016446372336
F-3.3402938842773438
tp2032
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2033
(F-3.0895678791778765
F-3.318828582763672
tp2034
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2035
(F-2.870349746152579
F-3.2141258239746096
tp2036
sS'from copy import deepcopy'
p2037
(F-4.068200429280599
F-3.0847171783447265
tp2038
sS"e = copy.deepcopy(a)\na.append('baz')"
p2039
(F-2.424503102022059
F-2.992501068115234
tp2040
sS'class Foo(object):\n\n    def __init__(self, val):\n        pass'
p2041
(F-1.273854475754958
F-3.0462045669555664
tp2042
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2043
(F-3.275239557142002
F-3.2932479858398436
tp2044
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2045
(F-3.130786764210668
F-3.2482879638671873
tp2046
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2047
(F-3.4109851868172
F-3.22552490234375
tp2048
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2049
(F-3.061384781547215
F-3.223291778564453
tp2050
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2051
(F-2.8709748158812993
F-3.3238761901855467
tp2052
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2053
(F-3.0431843761311534
F-3.302600860595703
tp2054
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2055
(F-3.136346493127211
F-3.2941749572753904
tp2056
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2057
(F-3.053129546496333
F-3.313993453979492
tp2058
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2059
(F-3.0057779274239445
F-3.328609848022461
tp2060
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2061
(F-3.021127335148154
F-3.3565994262695313
tp2062
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2063
(F-3.5173119078291224
F-3.1471651077270506
tp2064
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2065
(F-3.0883509531742384
F-3.3073955535888673
tp2066
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2067
(F-2.9945126488095237
F-3.3157596588134766
tp2068
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2069
(F-2.9026548862457275
F-3.265851593017578
tp2070
sS'for i in xrange(num_times):\n    pass'
p2071
(F-1.6709026098251343
F-3.1658370971679686
tp2072
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2073
(F-2.5242096523068986
F-3.202201080322266
tp2074
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2075
(F-2.874213462652162
F-3.3060981750488283
tp2076
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2077
(F-2.9173636300223214
F-3.292000579833984
tp2078
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2079
(F-2.9537559509277345
F-3.3194332122802734
tp2080
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2081
(F-2.9317047119140627
F-3.2065006256103517
tp2082
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2083
(F-2.5326346603094363
F-3.147303581237793
tp2084
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2085
(F-2.872283935546875
F-3.2195766448974608
tp2086
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2087
(F-2.7323466796875
F-3.287572479248047
tp2088
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2089
(F-2.6025173302852744
F-3.254250335693359
tp2090
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2091
(F-2.9476069196870056
F-3.2959659576416014
tp2092
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2093
(F-3.022646004813058
F-3.285863494873047
tp2094
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2095
(F-2.9672083328198937
F-3.3234718322753904
tp2096
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p2097
(F-3.254167307978091
F-3.378961181640625
tp2098
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2099
(F-2.909624689275568
F-3.2117694854736327
tp2100
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2101
(F-2.9851734998219372
F-3.296766662597656
tp2102
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2103
(F-3.1204554909153988
F-3.282044219970703
tp2104
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2105
(F-3.0648910847116024
F-3.297566604614258
tp2106
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2107
(F-2.763516186392881
F-3.330424499511719
tp2108
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2109
(F-2.7684402465820312
F-3.3326656341552736
tp2110
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2111
(F-2.985369694282819
F-3.3004207611083984
tp2112
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2113
(F-3.13744776382059
F-3.328337860107422
tp2114
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2115
(F-2.871315837776574
F-3.287008285522461
tp2116
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2117
(F-2.857059927547679
F-3.1475091934204102
tp2118
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2119
(F-3.045192644863055
F-3.333955764770508
tp2120
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2121
(F-2.7632124314614392
F-3.1733570098876953
tp2122
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2123
(F-3.0021861683238638
F-3.2355533599853517
tp2124
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2125
(F-2.942892007894449
F-3.3221057891845702
tp2126
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2127
(F-3.1709769112723216
F-3.3137485504150392
tp2128
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }'
p2129
(F-4.393468017578125
F-3.082432174682617
tp2130
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2131
(F-2.854799829348169
F-3.290030670166016
tp2132
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2133
(F-3.144324760932427
F-3.2357559204101562
tp2134
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2135
(F-3.041317362180898
F-3.289632034301758
tp2136
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2137
(F-3.2596422831217446
F-3.3089370727539062
tp2138
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2139
(F-3.007654975442325
F-3.297136688232422
tp2140
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2141
(F-3.6342646280924478
F-3.2723644256591795
tp2142
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2143
(F-2.9009162284232475
F-3.2594512939453124
tp2144
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2145
(F-2.8755436153202267
F-3.261163330078125
tp2146
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2147
(F-2.9416921515213814
F-3.3024215698242188
tp2148
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2149
(F-2.8897166660853792
F-3.01029052734375
tp2150
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2151
(F-2.8302375579548773
F-3.260049819946289
tp2152
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2153
(F-3.107652485664255
F-3.2714332580566405
tp2154
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2155
(F-3.1056559472110683
F-3.3535415649414064
tp2156
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2157
(F-3.156859515464469
F-3.217593765258789
tp2158
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2159
(F-2.9617583605707907
F-3.3337135314941406
tp2160
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2161
(F-3.0261843607305936
F-3.345572280883789
tp2162
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2163
(F-3.0973120963219367
F-3.324590301513672
tp2164
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2165
(F-2.8148514388443586
F-3.195521926879883
tp2166
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2167
(F-3.2036409413769897
F-3.306703567504883
tp2168
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2169
(F-2.8638507888977784
F-3.291417694091797
tp2170
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2171
(F-3.1608070373535155
F-3.1792850494384766
tp2172
sS't = time()\nfor i in xrange(num_times):\n    copy.copy(L)'
p2173
(F-2.4779880664966725
F-3.236903762817383
tp2174
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2175
(F-2.799811673451619
F-3.307630157470703
tp2176
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2177
(F-3.0319078008201825
F-3.3023067474365235
tp2178
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2179
(F-3.0338586952995223
F-3.329054260253906
tp2180
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2181
(F-3.1490431978555717
F-3.29136962890625
tp2182
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p2183
(F-2.6416570490056817
F-3.180271530151367
tp2184
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2185
(F-3.8835039640727795
F-3.0398719787597654
tp2186
sS'new_list = copy.copy(old_list)'
p2187
(F-2.4388694763183594
F-3.103596878051758
tp2188
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2189
(F-2.8986105016759924
F-3.3321327209472655
tp2190
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2191
(F-2.9951565446524784
F-3.3369842529296876
tp2192
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2193
(F-2.784779158882473
F-3.2982624053955076
tp2194
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2195
(F-3.05669114569656
F-3.2744274139404297
tp2196
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2197
(F-3.140316040368093
F-3.3246246337890626
tp2198
sS'if (type(obj[k]) in dignore):\n    pass'
p2199
(F-2.6288861726459705
F-3.0499832153320314
tp2200
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2201
(F-2.8021986219618054
F-3.132487106323242
tp2202
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2203
(F-1.9585376446063703
F-3.020949363708496
tp2204
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2205
(F-3.122621902422099
F-3.3491119384765624
tp2206
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2207
(F-3.01260736937164
F-3.2727901458740236
tp2208
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2209
(F-3.1936001864346593
F-3.307756805419922
tp2210
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2211
(F-2.854426066080729
F-3.190970230102539
tp2212
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2213
(F-3.12234374105712
F-3.3265354156494142
tp2214
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2215
(F-3.9827591916348073
F-3.0268024444580077
tp2216
sS'obj = tuple(obj)'
p2217
(F-3.0622305870056152
F-2.999368667602539
tp2218
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2219
(F-2.6824522941343245
F-3.224410629272461
tp2220
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2221
(F-3.1458187595137894
F-3.3354976654052733
tp2222
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2223
(F-2.6025173302852744
F-3.254250335693359
tp2224
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2225
(F-3.0527797488571644
F-3.336583709716797
tp2226
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2227
(F-2.655627144707574
F-3.2440044403076174
tp2228
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2229
(F-2.9712391168298855
F-3.2965377807617187
tp2230
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2231
(F-2.9834500083440467
F-3.31412353515625
tp2232
sS'd = copy.copy(a)'
p2233
(F-2.9151357650756835
F-3.0972526550292967
tp2234
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2235
(F-3.228995860706676
F-3.272149658203125
tp2236
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2237
(F-2.9377689484627014
F-3.3331577301025392
tp2238
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2239
(F-2.9135744936831363
F-3.263917922973633
tp2240
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2241
(F-3.1209398905436196
F-3.313043212890625
tp2242
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2243
(F-3.0105287939085996
F-3.30181999206543
tp2244
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2245
(F-2.9265356845543034
F-3.3090362548828125
tp2246
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2247
(F-2.8986330032348633
F-3.320705795288086
tp2248
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2249
(F-3.1014812558789715
F-3.3509429931640624
tp2250
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2251
(F-3.262015770221579
F-3.252139663696289
tp2252
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2253
(F-3.0878472749420274
F-3.2940547943115233
tp2254
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2255
(F-3.193087864349776
F-3.294786071777344
tp2256
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2257
(F-2.9837334526909722
F-3.3233646392822265
tp2258
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2259
(F-2.9637437260728277
F-3.299368667602539
tp2260
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2261
(F-3.301206575407015
F-3.272917938232422
tp2262
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2263
(F-3.068469692372128
F-3.3215965270996093
tp2264
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2265
(F-3.048344496654288
F-3.3216621398925783
tp2266
sS'a = []'
p2267
(F-3.070863723754883
F-3.0292331695556642
tp2268
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2269
(F-2.470735055428964
F-3.0889423370361326
tp2270
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2271
(F-3.1081146164508375
F-3.3130538940429686
tp2272
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2273
(F-2.6258478876370104
F-3.0267240524291994
tp2274
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p2275
(F-1.9796265110825046
F-3.000428009033203
tp2276
sS"print ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2277
(F-2.0349371168348522
F-3.1616495132446287
tp2278
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2279
(F-2.674270371259269
F-3.290216827392578
tp2280
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2281
(F-2.8014333624588814
F-3.2483104705810546
tp2282
sS"print 'list slicing [:]:', (time() - t)"
p2283
(F-3.2260869344075522
F-3.2515541076660157
tp2284
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2285
(F-3.040713675746834
F-3.3410850524902345
tp2286
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2287
(F-2.8985200361772017
F-3.3192657470703124
tp2288
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2289
(F-3.0627367231580944
F-3.3294029235839844
tp2290
sS'def __init__(self):\n    pass'
p2291
(F-1.2085725239345007
F-3.205215835571289
tp2292
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2293
(F-3.4095394736842106
F-3.2497737884521483
tp2294
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2295
(F-2.419130597795759
F-3.1854070663452148
tp2296
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2297
(F-3.012954970537606
F-3.288603973388672
tp2298
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2299
(F-3.0730424360795454
F-3.36004638671875
tp2300
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p2301
(F-1.322878156389509
F-3.0111919403076173
tp2302
sS't = time()\nfor i in xrange(num_times):\n    list(L)'
p2303
(F-2.2758099365234377
F-3.2403186798095702
tp2304
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2305
(F-3.0700975643691195
F-3.260192108154297
tp2306
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2307
(F-1.775879656682249
F-3.1149444580078125
tp2308
sS'def Copy(obj, use_deepcopy=True):\n    pass'
p2309
(F-2.896048651801215
F-3.5008129119873046
tp2310
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p2311
(F-3.3008533824573862
F-3.09095458984375
tp2312
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2313
(F-3.1389886765252974
F-3.3266681671142577
tp2314
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2315
(F-2.7173484455455434
F-3.0685104370117187
tp2316
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2317
(F-2.549281529017857
F-3.0522348403930666
tp2318
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2319
(F-2.964869754415163
F-3.3751522064208985
tp2320
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2321
(F-3.072745893912886
F-3.3078983306884764
tp2322
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2323
(F-2.937015320824795
F-3.293547439575195
tp2324
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2325
(F-2.884957483572553
F-3.311477279663086
tp2326
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p2327
(F-3.493035035974839
F-3.116170120239258
tp2328
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2329
(F-2.654024538786515
F-3.1714145660400392
tp2330
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2331
(F-3.269533053994766
F-3.280020904541016
tp2332
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2333
(F-3.1101303100585938
F-3.335429382324219
tp2334
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p2335
(F-3.1274766644227854
F-3.0010311126708986
tp2336
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2337
(F-3.5213405064174106
F-3.157306098937988
tp2338
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2339
(F-2.575468557852286
F-3.0587940216064453
tp2340
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2341
(F-2.891391827793195
F-3.3207576751708983
tp2342
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2343
(F-3.1520777191290876
F-3.322114944458008
tp2344
sS'for k in obj:\n    pass'
p2345
(F-2.24947773326527
F-2.984501838684082
tp2346
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2347
(F-3.000086752216468
F-3.3180973052978517
tp2348
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2349
(F-3.829125606652462
F-3.3568962097167967
tp2350
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2351
(F-2.872165111785239
F-3.276775360107422
tp2352
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2353
(F-2.3677130034475615
F-3.181888961791992
tp2354
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2355
(F-3.2143653367093936
F-3.3222522735595703
tp2356
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2357
(F-3.2229930227592445
F-3.3217498779296877
tp2358
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2359
(F-2.869671754162721
F-3.2170166015625
tp2360
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2361
(F-2.926317693536932
F-3.3237319946289063
tp2362
sS"print 'copy.deepcopy:', (time() - t)"
p2363
(F-3.2260869344075522
F-3.2515541076660157
tp2364
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2365
(F-2.70092724609375
F-3.25667724609375
tp2366
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2367
(F-3.230044002421418
F-3.309339141845703
tp2368
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2369
(F-3.2155806667120883
F-3.3125770568847654
tp2370
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2371
(F-3.0071107202646683
F-3.303263473510742
tp2372
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2373
(F-2.90099990199989
F-3.254425811767578
tp2374
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2375
(F-3.151767520453986
F-3.2705921173095702
tp2376
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2377
(F-3.0260416666666665
F-3.2582717895507813
tp2378
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p2379
(F-2.9270154709783975
F-3.0143030166625975
tp2380
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p2381
(F-1.9121308099655878
F-3.2117244720458986
tp2382
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2383
(F-2.9865699067783815
F-3.3279487609863283
tp2384
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2385
(F-2.900236869770321
F-3.313468170166016
tp2386
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2387
(F-2.845333602077277
F-3.3177703857421874
tp2388
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2389
(F-3.0340480189169607
F-3.2966304779052735
tp2390
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2391
(F-3.07503689322502
F-3.2973709106445312
tp2392
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2393
(F-2.8454961510343924
F-3.329906463623047
tp2394
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2395
(F-2.959767449762403
F-3.3234626770019533
tp2396
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2397
(F-3.0063047588996166
F-3.3080974578857423
tp2398
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2399
(F-2.8076139751233553
F-3.3137088775634767
tp2400
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2401
(F-3.150059291294643
F-3.249118423461914
tp2402
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2403
(F-3.0240919325086804
F-3.2862178802490236
tp2404
sS'obj = deepcopy(obj)'
p2405
(F-3.62577748298645
F-3.074271583557129
tp2406
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2407
(F-2.943358997073336
F-3.3362659454345702
tp2408
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2409
(F-2.726712336305712
F-3.1932973861694336
tp2410
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2411
(F-2.7704541887555805
F-3.2290676116943358
tp2412
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2413
(F-2.988637869698661
F-3.327424240112305
tp2414
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2415
(F-2.9558845132084217
F-3.307402420043945
tp2416
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2417
(F-2.9643565586635043
F-3.328662109375
tp2418
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2419
(F-2.9705571619217084
F-3.314351272583008
tp2420
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p2421
(F-3.733656925941581
F-3.0538057327270507
tp2422
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2423
(F-3.0003420362285538
F-3.2973354339599608
tp2424
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2425
(F-3.165551089950608
F-3.3277488708496095
tp2426
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2427
(F-3.135480408274799
F-3.2999671936035155
tp2428
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2429
(F-2.731585741043091
F-3.1646656036376952
tp2430
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2431
(F-2.7351375379060445
F-3.3146034240722657
tp2432
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2433
(F-2.7628528683684594
F-3.1972278594970702
tp2434
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2435
(F-2.872949523925781
F-3.2674346923828126
tp2436
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2437
(F-3.028115112857042
F-3.32342529296875
tp2438
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2439
(F-2.7730573687637063
F-3.2605587005615235
tp2440
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2441
(F-2.6025173302852744
F-3.254250335693359
tp2442
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2443
(F-2.936784733952703
F-3.3315147399902343
tp2444
sS'a.extend((i for i in L))'
p2445
(F-2.98312132699149
F-3.1914159774780275
tp2446
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2447
(F-2.9797920245087175
F-3.358712387084961
tp2448
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p2449
(F-2.797015053885324
F-3.31412353515625
tp2450
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2451
(F-2.9644923700350465
F-3.3115943908691405
tp2452
sS'for i in xrange(num_times):\n    a = []'
p2453
(F-2.1876752753006783
F-3.1170434951782227
tp2454
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    pass'
p2455
(F-2.1475616123365318
F-3.082179641723633
tp2456
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2457
(F-3.0362204618232194
F-3.1876800537109373
tp2458
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2459
(F-2.914708438836014
F-3.3379852294921877
tp2460
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2461
(F-2.9341467832907653
F-3.213648223876953
tp2462
sS'if (type(obj[k]) in dignore):\n    continue'
p2463
(F-2.7577301828484786
F-3.0865243911743163
tp2464
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)'
p2465
(F-2.5141756534576416
F-3.210870361328125
tp2466
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2467
(F-2.8538029988606772
F-3.415361785888672
tp2468
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2469
(F-2.624190673828125
F-3.1870887756347654
tp2470
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p2471
(F-2.913164173473011
F-3.070689582824707
tp2472
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2473
(F-2.1790063792261583
F-3.16241569519043
tp2474
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2475
(F-2.2481101989746093
F-3.1776617050170897
tp2476
sS'c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p2477
(F-2.6591864365797777
F-3.054908561706543
tp2478
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2479
(F-3.0678477226933345
F-3.224430465698242
tp2480
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2481
(F-3.268718654826536
F-3.2852516174316406
tp2482
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2483
(F-2.0640347388482865
F-3.0051624298095705
tp2484
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2485
(F-3.3385358212599114
F-3.3051311492919924
tp2486
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2487
(F-3.2195014421329944
F-3.2423057556152344
tp2488
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2489
(F-2.770972149188702
F-3.2806316375732423
tp2490
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2491
(F-2.639441172281901
F-3.1555919647216797
tp2492
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2493
(F-3.1491504505368098
F-3.3328842163085937
tp2494
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2495
(F-2.863253611438679
F-3.325117492675781
tp2496
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2497
(F-2.7671510796797905
F-3.140869903564453
tp2498
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2499
(F-3.1087199549521167
F-3.352035140991211
tp2500
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2501
(F-3.3871792063993564
F-3.177775001525879
tp2502
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2503
(F-2.903177160965769
F-3.2766613006591796
tp2504
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2505
(F-3.1364565567231515
F-3.247268295288086
tp2506
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p2507
(F-1.133290550925515
F-3.0282333374023436
tp2508
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2509
(F-2.869086440728635
F-3.344303512573242
tp2510
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2511
(F-3.184187350589018
F-3.3176536560058594
tp2512
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2513
(F-3.05739186950822
F-3.3259651184082033
tp2514
sS'obj = obj[:]'
p2515
(F-3.407139778137207
F-3.0049314498901367
tp2516
sS'for y in L:\n    pass'
p2517
(F-2.0667232166637075
F-3.0605836868286134
tp2518
sS"print 'list slicing [:]:', (time() - t)\nt = time()"
p2519
(F-3.6342646280924478
F-3.2723644256591795
tp2520
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2521
(F-2.923818636341255
F-3.352593994140625
tp2522
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2523
(F-2.6025173302852744
F-3.254250335693359
tp2524
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2525
(F-2.5460073433670343
F-3.321875
tp2526
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2527
(F-3.0817506829263954
F-3.29453125
tp2528
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2529
(F-2.038026983087713
F-3.009796905517578
tp2530
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2531
(F-3.478045654296875
F-3.2544235229492187
tp2532
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2533
(F-2.914284939236111
F-3.33728141784668
tp2534
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2535
(F-3.0552266438802085
F-3.0100894927978517
tp2536
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2537
(F-2.988519287109375
F-3.2882011413574217
tp2538
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2539
(F-3.417624372776931
F-3.271004486083984
tp2540
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2541
(F-2.9942192994725065
F-3.354373550415039
tp2542
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2543
(F-2.979263379378019
F-3.3245079040527346
tp2544
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2545
(F-3.1439121513609676
F-3.2509033203125
tp2546
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2547
(F-3.056449839610927
F-3.315852737426758
tp2548
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time"
p2549
(F-3.340438479468936
F-3.2454082489013674
tp2550
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2551
(F-2.8004983814839783
F-3.331186294555664
tp2552
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2553
(F-3.015079936043161
F-3.291056442260742
tp2554
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2555
(F-2.9763529123353565
F-3.332205581665039
tp2556
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2557
(F-2.9682877604166666
F-3.1781242370605467
tp2558
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2559
(F-2.996954345703125
F-3.346710205078125
tp2560
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2561
(F-2.6390680051317403
F-3.1405481338500976
tp2562
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2563
(F-2.920831019582312
F-3.3254283905029296
tp2564
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2565
(F-2.782897295270647
F-3.271990203857422
tp2566
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2567
(F-2.849574545155401
F-3.3356300354003907
tp2568
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2569
(F-2.5595972489337533
F-3.007341003417969
tp2570
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2571
(F-2.0406611851283483
F-3.006256103515625
tp2572
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2573
(F-2.936962580276748
F-3.3419952392578125
tp2574
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2575
(F-2.971248851102941
F-3.3300281524658204
tp2576
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2577
(F-3.0167989408052884
F-3.331770324707031
tp2578
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2579
(F-2.9857505515769676
F-3.274798583984375
tp2580
sS"foo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2581
(F-2.949166933695475
F-3.1842361450195313
tp2582
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2583
(F-3.2408506132019355
F-3.2312774658203125
tp2584
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2585
(F-3.0911192717375577
F-3.251203918457031
tp2586
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p2587
(F-1.503672572544643
F-3.0187505722045898
tp2588
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2589
(F-3.059330531529018
F-3.289670944213867
tp2590
sS"a.append('baz')"
p2591
(F-2.1981444358825684
F-3.0892993927001955
tp2592
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2593
(F-3.1464404139871385
F-3.317220687866211
tp2594
sS'if (type(obj[x]) in dignore):\n    continue'
p2595
(F-2.73946119609632
F-3.0669410705566404
tp2596
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2597
(F-2.99570071042239
F-3.297684097290039
tp2598
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2599
(F-3.102216796875
F-3.3148597717285155
tp2600
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p2601
(F-3.3499471028645833
F-3.1569128036499023
tp2602
sS"print 'list(L):', (time() - t)\nt = time()"
p2603
(F-3.6342646280924478
F-3.2723644256591795
tp2604
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2605
(F-3.110180545162845
F-3.2163108825683593
tp2606
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2607
(F-2.970808141371783
F-3.3185359954833986
tp2608
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2609
(F-3.1481755574544272
F-3.244342803955078
tp2610
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p2611
(F-3.4291048403139466
F-3.1923521041870115
tp2612
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2613
(F-2.7413927161175273
F-3.1663528442382813
tp2614
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2615
(F-3.1759986029730904
F-3.2177169799804686
tp2616
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2617
(F-2.97542964390346
F-3.3218242645263674
tp2618
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2619
(F-2.8526654484296086
F-3.2134750366210936
tp2620
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2621
(F-3.148241795531107
F-3.293265533447266
tp2622
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2623
(F-3.2134733164355103
F-3.265578842163086
tp2624
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2625
(F-3.29370784238388
F-3.2673736572265626
tp2626
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2627
(F-2.8864695581896553
F-3.322772979736328
tp2628
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2629
(F-2.9972090510479417
F-3.3220088958740233
tp2630
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2631
(F-2.983731024279566
F-3.3340003967285154
tp2632
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2633
(F-3.029215161266223
F-3.3126495361328123
tp2634
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2635
(F-3.0275523546006946
F-3.351531219482422
tp2636
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2637
(F-2.8169157845633372
F-3.3345977783203127
tp2638
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2639
(F-3.01307373046875
F-3.2609573364257813
tp2640
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p2641
(F-3.9161856515066966
F-3.0401819229125975
tp2642
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2643
(F-2.9539697581324083
F-3.2868297576904295
tp2644
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2645
(F-2.7228418986002603
F-3.0343624114990235
tp2646
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2647
(F-3.0504015106515787
F-3.3127067565917967
tp2648
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2649
(F-3.2452693611248584
F-3.290635681152344
tp2650
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p2651
(F-2.8776899638928866
F-3.208675765991211
tp2652
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2653
(F-3.393048321759259
F-3.2630943298339843
tp2654
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2655
(F-2.8128317974983377
F-3.280481719970703
tp2656
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2657
(F-2.799905979886968
F-3.2550323486328123
tp2658
sS'def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2659
(F-2.32647055166739
F-3.032507133483887
tp2660
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2661
(F-2.97775202689411
F-3.263605499267578
tp2662
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2663
(F-2.9384984785985764
F-3.3195186614990235
tp2664
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p2665
(F-3.1091261364164806
F-3.3339805603027344
tp2666
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2667
(F-2.646663590973499
F-3.126677703857422
tp2668
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2669
(F-2.727413282868612
F-3.3146221160888674
tp2670
sS't = time()\nfor i in xrange(num_times):\n    pass'
p2671
(F-2.1900757876309482
F-3.2553970336914064
tp2672
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2673
(F-1.6381844414605036
F-3.2037525177001953
tp2674
sS'continue'
p2675
(F-8.795010884602865
F-3.5905609130859375
tp2676
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2677
(F-2.752749929120464
F-3.3162025451660155
tp2678
sS'Copy(L)'
p2679
(F-3.5289748509724936
F-3.5544612884521483
tp2680
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2681
(F-3.0685497527426864
F-3.2929714202880858
tp2682
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2683
(F-2.8953115609975963
F-3.328705596923828
tp2684
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2685
(F-2.5847271126760565
F-3.225056457519531
tp2686
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2687
(F-2.8290462399938425
F-3.3437618255615233
tp2688
sS"if (__name__ == '__main__'):\n    import copy"
p2689
(F-2.7479021549224854
F-3.20379753112793
tp2690
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2691
(F-2.9291802563713594
F-3.342154693603516
tp2692
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2693
(F-2.9189755971195135
F-3.3160980224609373
tp2694
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2695
(F-2.909067334227301
F-3.332244110107422
tp2696
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2697
(F-3.0429018887606536
F-3.2428855895996094
tp2698
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2699
(F-2.8299173548601675
F-3.170474815368652
tp2700
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2701
(F-2.8315807277873413
F-3.310696029663086
tp2702
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2703
(F-3.197712178132972
F-3.1967327117919924
tp2704
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p2705
(F-2.7261039188929965
F-3.0369403839111326
tp2706
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2707
(F-3.1471813025841344
F-3.339824676513672
tp2708
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2709
(F-2.5884186317180764
F-3.201755142211914
tp2710
sS'obj = list(obj)'
p2711
(F-2.8099427223205566
F-3.094208908081055
tp2712
sS'for i in xrange(num_times):\n    list(L)'
p2713
(F-1.8592591536672491
F-3.198766326904297
tp2714
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2715
(F-2.6986584663391113
F-3.067801284790039
tp2716
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2717
(F-3.031515611490242
F-3.3097381591796875
tp2718
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2719
(F-3.203241467085041
F-3.287542724609375
tp2720
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2721
(F-2.955288011200574
F-3.29580078125
tp2722
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2723
(F-2.8258247760811237
F-3.1947092056274413
tp2724
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2725
(F-2.8660229879712302
F-3.2889373779296873
tp2726
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2727
(F-2.913795753761574
F-3.3125564575195314
tp2728
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2729
(F-2.959847828698537
F-3.2429134368896486
tp2730
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2731
(F-3.067317562639866
F-3.288441848754883
tp2732
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2733
(F-2.891141244493392
F-3.3061138153076173
tp2734
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2735
(F-3.0955948788895564
F-3.317713165283203
tp2736
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2737
(F-3.104893678874639
F-3.354958343505859
tp2738
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2739
(F-2.981438497895176
F-3.314300537109375
tp2740
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2741
(F-2.7020578384399414
F-3.2827423095703123
tp2742
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2743
(F-2.9821021340110083
F-3.2585990905761717
tp2744
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2745
(F-3.8544850842706087
F-3.1169143676757813
tp2746
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2747
(F-3.0132134406121223
F-3.2986000061035154
tp2748
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2749
(F-2.9388631858573055
F-3.318231964111328
tp2750
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2751
(F-2.655894764682703
F-3.2989990234375
tp2752
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2753
(F-2.9868041546675412
F-3.3179325103759765
tp2754
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2755
(F-3.2945157314868685
F-3.282784271240234
tp2756
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2757
(F-2.6769259222622575
F-3.181706428527832
tp2758
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2759
(F-3.1222813436429795
F-3.297627258300781
tp2760
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2761
(F-2.8423215498835406
F-3.318720245361328
tp2762
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2763
(F-3.03171630859375
F-3.3133590698242186
tp2764
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p2765
(F-2.749217987060547
F-3.257266616821289
tp2766
sS"print 'list extend:', (time() - t)\nt = time()"
p2767
(F-3.6342646280924478
F-3.2723644256591795
tp2768
sS"a.extend(L)\nprint 'list extend:', (time() - t)"
p2769
(F-3.441189816123561
F-3.1482704162597654
tp2770
sS'new_list = copy.deepcopy(old_list)'
p2771
(F-2.2594092232840404
F-3.01254940032959
tp2772
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2773
(F-3.3581241146548764
F-3.1710483551025392
tp2774
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2775
(F-3.0605777393687856
F-3.126322937011719
tp2776
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2777
(F-2.9235719312138917
F-3.3007431030273438
tp2778
sS"print 'generator expression extend:', (time() - t)"
p2779
(F-3.2260869344075522
F-3.2515541076660157
tp2780
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2781
(F-2.9356226659083102
F-3.319113540649414
tp2782
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2783
(F-3.072845458984375
F-3.2633636474609373
tp2784
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2785
(F-2.825737091432135
F-3.308491516113281
tp2786
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2787
(F-2.8197218371975805
F-3.250788116455078
tp2788
sS'return str(self.val)'
p2789
(F-2.8484583960639105
F-3.1164459228515624
tp2790
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2791
(F-2.8416753915640025
F-3.069228935241699
tp2792
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2793
(F-3.0008431570870537
F-3.342108154296875
tp2794
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2795
(F-3.0615826416015626
F-3.2183914184570312
tp2796
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2797
(F-2.804429895737592
F-3.274076461791992
tp2798
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2799
(F-2.9935990718373082
F-3.326688766479492
tp2800
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2801
(F-3.0520639519942434
F-3.2926849365234374
tp2802
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2803
(F-2.9489360000147964
F-3.4025295257568358
tp2804
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2805
(F-3.042217673948559
F-3.363805389404297
tp2806
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2807
(F-2.888946957058377
F-3.3307426452636717
tp2808
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2809
(F-3.0090107324704602
F-3.3498069763183596
tp2810
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2811
(F-3.129022216796875
F-3.1659412384033203
tp2812
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2813
(F-2.9495403583233175
F-3.303987503051758
tp2814
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2815
(F-3.561466270769146
F-3.186355209350586
tp2816
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2817
(F-3.2237458662553267
F-3.287192535400391
tp2818
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2819
(F-3.198255928399051
F-3.2286907196044923
tp2820
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2821
(F-3.0705609764557718
F-3.2887344360351562
tp2822
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2823
(F-2.7535413106282554
F-3.112029266357422
tp2824
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2825
(F-3.041416291267641
F-3.3358432769775392
tp2826
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2827
(F-2.6025173302852744
F-3.254250335693359
tp2828
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2829
(F-3.0856021521226413
F-3.332666778564453
tp2830
sS'foo.val = 5'
p2831
(F-4.08955683026995
F-3.0909027099609374
tp2832
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2833
(F-3.11908476858428
F-3.29571647644043
tp2834
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2835
(F-3.3021298363095237
F-3.219009017944336
tp2836
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2837
(F-2.9102953375493725
F-3.330365753173828
tp2838
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2839
(F-2.91528076171875
F-3.3398563385009767
tp2840
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2841
(F-2.173354439113451
F-3.0074848175048827
tp2842
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2843
(F-2.9705231168376867
F-3.3259273529052735
tp2844
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2845
(F-3.029764615572416
F-3.2917861938476562
tp2846
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2847
(F-3.058605105377907
F-3.3037437438964843
tp2848
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2849
(F-2.9234183175223216
F-3.230962371826172
tp2850
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2851
(F-2.8837271163712686
F-3.2918655395507814
tp2852
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2853
(F-3.0294330303485575
F-3.2879974365234377
tp2854
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2855
(F-3.051796315986419
F-3.2971332550048826
tp2856
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2857
(F-2.7926095661364103
F-3.2357200622558593
tp2858
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2859
(F-2.875295302447151
F-3.254607009887695
tp2860
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2861
(F-2.952505700875327
F-3.306671905517578
tp2862
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2863
(F-3.004413052262931
F-3.2756183624267576
tp2864
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2865
(F-2.7169569148573767
F-3.1844856262207033
tp2866
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2867
(F-2.861256306966146
F-3.2174476623535155
tp2868
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2869
(F-2.8245052538420024
F-3.1071006774902346
tp2870
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2871
(F-3.007026849791061
F-3.2992233276367187
tp2872
sS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2873
(F-2.5284713745117187
F-3.0672983169555663
tp2874
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2875
(F-3.0440786568222533
F-3.3066905975341796
tp2876
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2877
(F-3.180853843688965
F-3.3080718994140623
tp2878
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2879
(F-2.761470207801232
F-3.2157272338867187
tp2880
sS"for i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2881
(F-3.1393549719522165
F-3.189516067504883
tp2882
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2883
(F-3.0333865551238364
F-3.2903953552246095
tp2884
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2885
(F-3.0974645441228694
F-3.2353893280029298
tp2886
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2887
(F-3.1804068946084487
F-3.312447738647461
tp2888
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2889
(F-2.7756330966949463
F-3.247658920288086
tp2890
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2891
(F-2.9809849330357143
F-3.2831165313720705
tp2892
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2893
(F-2.594483352288967
F-3.2432266235351563
tp2894
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2895
(F-2.963533556139147
F-3.259501647949219
tp2896
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2897
(F-3.0224628534017657
F-3.315227508544922
tp2898
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2899
(F-2.6080110784162556
F-3.296891784667969
tp2900
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2901
(F-3.210696863785885
F-3.2706062316894533
tp2902
sS'for i in xrange(num_times):\n    Copy(L)'
p2903
(F-2.1554603576660156
F-3.394001770019531
tp2904
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2905
(F-2.7650330861409507
F-3.240418243408203
tp2906
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2907
(F-3.1981830465382544
F-3.303533935546875
tp2908
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2909
(F-3.00527836726262
F-3.2487239837646484
tp2910
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2911
(F-2.4875564575195312
F-3.209097671508789
tp2912
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2913
(F-3.006937467134916
F-3.230453109741211
tp2914
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p2915
(F-3.5598254504504503
F-3.171619415283203
tp2916
sS"print 'list expression(L):', (time() - t)"
p2917
(F-3.2260869344075522
F-3.2515541076660157
tp2918
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2919
(F-3.1906392167254194
F-3.3202747344970702
tp2920
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2921
(F-3.167352803548177
F-3.1548675537109374
tp2922
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2923
(F-3.2361042460457226
F-3.2263748168945314
tp2924
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2925
(F-1.577801085354989
F-3.028687858581543
tp2926
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2927
(F-3.1066261948339196
F-3.238519287109375
tp2928
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2929
(F-3.085067277102126
F-3.2906986236572267
tp2930
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2931
(F-3.0059934804137325
F-3.298356628417969
tp2932
sS'def __repr__(self):\n    return str(self.val)'
p2933
(F-1.559001350402832
F-3.105763626098633
tp2934
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2935
(F-2.9417957225879587
F-3.326287841796875
tp2936
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2937
(F-2.99842038928953
F-3.2589160919189455
tp2938
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2939
(F-2.9537943351168594
F-3.307209777832031
tp2940
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2941
(F-2.777440881216398
F-3.185787391662598
tp2942
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2943
(F-2.946966552734375
F-3.288113021850586
tp2944
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2945
(F-2.8788615901295733
F-3.2867637634277345
tp2946
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2947
(F-2.9855283477602628
F-3.336587905883789
tp2948
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p2949
(F-2.828005075454712
F-3.019215965270996
tp2950
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2951
(F-3.4324694939379423
F-3.2505874633789062
tp2952
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2953
(F-2.6531679832329185
F-3.219773864746094
tp2954
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time"
p2955
(F-3.907409985860189
F-3.1599220275878905
tp2956
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p2957
(F-2.8385371932064194
F-3.196898651123047
tp2958
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2959
(F-3.015613151999081
F-3.2933208465576174
tp2960
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2961
(F-2.114709441194829
F-3.012132263183594
tp2962
sS'for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p2963
(F-2.623071594238281
F-3.4856456756591796
tp2964
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p2965
(F-1.2009480285644532
F-3.0235490798950195
tp2966
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2967
(F-3.2758757125499636
F-3.269449996948242
tp2968
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2969
(F-2.6031391189759034
F-3.209490966796875
tp2970
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2971
(F-3.0863682068500324
F-3.3521759033203127
tp2972
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2973
(F-2.994903284475344
F-3.287486267089844
tp2974
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2975
(F-2.984882715329602
F-3.3023048400878907
tp2976
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2977
(F-2.7849172864641463
F-2.9990732192993166
tp2978
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2979
(F-3.0707537541623977
F-3.2255569458007813
tp2980
sS'obj = obj.copy()'
p2981
(F-2.9082717895507812
F-3.0791324615478515
tp2982
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2983
(F-2.819333076477051
F-3.205120849609375
tp2984
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2985
(F-3.0567951111131877
F-3.3231658935546875
tp2986
sS"print 'list extend:', (time() - t)"
p2987
(F-3.2260869344075522
F-3.2515541076660157
tp2988
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2989
(F-2.977326221955128
F-3.218810272216797
tp2990
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2991
(F-2.89012451171875
F-3.3339565277099608
tp2992
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2993
(F-2.916412240067379
F-3.3069042205810546
tp2994
sS'new_list = list(old_list)'
p2995
(F-2.06097141901652
F-3.061956214904785
tp2996
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2997
(F-3.0034347755321558
F-3.3109203338623048
tp2998
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2999
(F-3.0718107713172373
F-3.3221389770507814
tp3000
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3001
(F-2.6168806893484935
F-3.0036188125610352
tp3002
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p3003
(F-2.9796789697853914
F-3.34948844909668
tp3004
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3005
(F-2.939033598058364
F-3.3240310668945314
tp3006
sS"a.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p3007
(F-2.5927451349073842
F-3.1370162963867188
tp3008
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3009
(F-3.1517101469494047
F-3.253894805908203
tp3010
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p3011
(F-2.2146097018024116
F-3.028201866149902
tp3012
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3013
(F-2.888031702607734
F-3.3419448852539064
tp3014
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3015
(F-3.033843994140625
F-3.2122230529785156
tp3016
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p3017
(F-2.984403939082705
F-3.2250698089599608
tp3018
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p3019
(F-3.0283095041910806
F-3.0702936172485353
tp3020
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p3021
(F-2.9519746568467884
F-3.313669967651367
tp3022
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3023
(F-2.1071036412165713
F-3.012618064880371
tp3024
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3025
(F-3.18311049221965
F-3.3245704650878904
tp3026
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p3027
(F-2.918120048415493
F-3.0244705200195314
tp3028
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3029
(F-2.995232667161825
F-3.3554622650146486
tp3030
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p3031
(F-2.9333045959472654
F-3.2821887969970702
tp3032
sS"a.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p3033
(F-3.677005615234375
F-3.150903511047363
tp3034
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3035
(F-2.987157968374399
F-3.3302940368652343
tp3036
sS'is_tuple = False'
p3037
(F-4.035260881696429
F-3.0364456176757812
tp3038
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p3039
(F-2.8281436246984146
F-3.0531373977661134
tp3040
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3041
(F-2.767653783162435
F-3.290480041503906
tp3042
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3043
(F-3.0918786035825128
F-3.284469985961914
tp3044
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p3045
(F-2.651981407487896
F-3.128126335144043
tp3046
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3047
(F-2.5790328979492188
F-3.0257213592529295
tp3048
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3049
(F-2.928385925292969
F-3.312667465209961
tp3050
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p3051
(F-3.3651123046875
F-3.230784225463867
tp3052
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p3053
(F-3.1365217729048296
F-3.2305416107177733
tp3054
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3055
(F-3.041364635120739
F-3.2537487030029295
tp3056
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3057
(F-3.1464733022504148
F-3.3188011169433596
tp3058
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p3059
(F-1.812017118013822
F-3.1022953033447265
tp3060
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3061
(F-3.008229710111682
F-3.3086658477783204
tp3062
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3063
(F-1.977710079837155
F-2.9991481781005858
tp3064
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3065
(F-2.772618580449578
F-3.314231109619141
tp3066
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3067
(F-3.2565329545986152
F-3.2734100341796877
tp3068
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p3069
(F-3.0368050023129114
F-3.310894775390625
tp3070
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p3071
(F-3.105757878979607
F-3.3161495208740233
tp3072
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p3073
(F-2.9600760522391383
F-3.3175830841064453
tp3074
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3075
(F-3.3309127144191577
F-2.986603927612305
tp3076
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3077
(F-3.113835652669271
F-3.1971813201904298
tp3078
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p3079
(F-3.197104932441086
F-3.3215587615966795
tp3080
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3081
(F-3.14589254184404
F-3.296152877807617
tp3082
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3083
(F-2.8432398886576187
F-3.31787223815918
tp3084
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3085
(F-3.0109997690799863
F-3.31387939453125
tp3086
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p3087
(F-3.136259533110119
F-3.324972915649414
tp3088
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3089
(F-2.5589240745261863
F-3.2251163482666017
tp3090
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3091
(F-2.980391497773249
F-3.285986328125
tp3092
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3093
(F-2.5481096267700196
F-3.184225845336914
tp3094
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3095
(F-2.789388633636107
F-3.3174224853515626
tp3096
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p3097
(F-3.0575594664698813
F-3.296317291259766
tp3098
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p3099
(F-3.1175443415056194
F-3.2579509735107424
tp3100
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p3101
(F-3.184991987924727
F-3.3081901550292967
tp3102
ssI402504
(dp3103
S'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p3104
(F-3.570730209350586
F-2.2837819186123935
tp3105
sS'(type(i) is float)'
p3106
(F-3.761274719238281
F-2.2708329287442295
tp3107
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3108
(F-3.815169988893995
F-2.2678042325106533
tp3109
sS'type(i)\n(type(i) is long)\ni = 123.456'
p3110
(F-4.283874913265831
F-2.2893056002530185
tp3111
sS'(type(i) is int)\ni = 123456789L\ntype(i)'
p3112
(F-3.8191592567845394
F-2.2859250848943535
tp3113
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3114
(F-3.8398515181107955
F-2.27610275962136
tp3115
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3116
(F-4.2844133377075195
F-2.2824244065718218
tp3117
sS"v = 'hi'"
p3118
(F-3.9023773193359377
F-2.387459494850852
tp3119
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3120
(F-3.816261085304054
F-2.288995222611861
tp3121
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3122
(F-3.9630344935825894
F-2.2753096493807705
tp3123
sS'i = 123'
p3124
(F-4.6543128967285154
F-2.4931359724564985
tp3125
sS'v = 10\ntype(v)'
p3126
(F-3.45982666015625
F-2.2652499459006568
tp3127
sS'i = 123.456\ntype(i)'
p3128
(F-2.979929733276367
F-2.295640078457919
tp3129
sS'v = 100000000000000'
p3130
(F-4.0319671630859375
F-2.298156044699929
tp3131
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p3132
(F-3.6602112906319753
F-2.302670218727805
tp3133
sS'i = 123\ntype(i)'
p3134
(F-3.3089038848876955
F-2.352137478915128
tp3135
sS'(type(i) is long)\ni = 123.456'
p3136
(F-4.82763181413923
F-2.296151941472834
tp3137
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3138
(F-4.137055106784986
F-2.2853768088600854
tp3139
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L'
p3140
(F-4.110135617463485
F-2.3143612254749644
tp3141
sS'v = 100000000000000\ntype(v)'
p3142
(F-3.181048583984375
F-2.2833487770774146
tp3143
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3144
(F-4.0877186844988564
F-2.292805238203569
tp3145
sS'(type(i) is int)\ni = 123456789L'
p3146
(F-4.5555330004010886
F-2.291818445379084
tp3147
sS'(type(i) is long)\ni = 123.456\ntype(i)'
p3148
(F-4.0398206208881575
F-2.286840092052113
tp3149
sS'type(i)\n(type(i) is long)'
p3150
(F-3.6965784708658855
F-2.281977046619762
tp3151
sS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3152
(F-3.7998349738843515
F-2.2697632529518823
tp3153
sS'type(i)\n(type(i) is int)'
p3154
(F-3.379222615559896
F-2.290919217196378
tp3155
sS'i = 123456789L\ntype(i)\n(type(i) is long)'
p3156
(F-3.6197806910464636
F-2.274075594815341
tp3157
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3158
(F-3.7905956449962797
F-2.273984042080966
tp3159
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3160
(F-3.9432154475031673
F-2.273355484008789
tp3161
sS'i = 123456789L\ntype(i)'
p3162
(F-2.979929733276367
F-2.295640078457919
tp3163
sS'type(v)'
p3164
(F-2.4248005549112954
F-2.300734606656161
tp3165
sS'i = 123.456'
p3166
(F-3.8726875305175783
F-2.328188115900213
tp3167
sS'print type(variable_name)'
p3168
(F-3.4668184916178384
F-2.256323727694425
tp3169
sS'v = (-10)\ntype(v)'
p3170
(F-3.63422364455003
F-2.3123214028098364
tp3171
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3172
(F-3.7811778675426138
F-2.2759793021462182
tp3173
sS'type(i)\n(type(i) is int)\ni = 123456789L'
p3174
(F-4.081469084087171
F-2.2867279052734375
tp3175
sS'type(i)'
p3176
(F-2.332282066345215
F-2.305031169544567
tp3177
sS'i = 123.456\ntype(i)\n(type(i) is float)'
p3178
(F-3.439632616545025
F-2.2689214186234907
tp3179
sS'v = (-10)'
p3180
(F-4.480216026306152
F-2.3228437250310723
tp3181
sS'(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3182
(F-3.994434356689453
F-2.2701648365367544
tp3183
sS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3184
(F-3.741044362386068
F-2.281328894875266
tp3185
sS'type(i)\n(type(i) is float)'
p3186
(F-3.463068135579427
F-2.2658427845348013
tp3187
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3188
(F-4.07164207664696
F-2.28032094782049
tp3189
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3190
(F-3.6936122349330356
F-2.277341669256037
tp3191
sS'(type(i) is int)'
p3192
(F-3.6419837951660154
F-2.3006362915039062
tp3193
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3194
(F-3.74769097405511
F-2.2671878121115943
tp3195
sS'(type(i) is long)'
p3196
(F-4.143413162231445
F-2.288516304709695
tp3197
sS'v = 10'
p3198
(F-4.409488677978516
F-2.2867426438765093
tp3199
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3200
(F-3.936247784158458
F-2.2673587799072266
tp3201
sS'i = 123456789L'
p3202
(F-3.8726875305175783
F-2.328188115900213
tp3203
sS'i = 123\ntype(i)\n(type(i) is int)'
p3204
(F-3.557496321828742
F-2.329690759832209
tp3205
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3206
(F-3.827830107315727
F-2.284492319280451
tp3207
sS"v = 'hi'\ntype(v)"
p3208
(F-2.969163513183594
F-2.325415697964755
tp3209
ssI275018
(dp3210
S's.strip()'
p3211
(F-1.7081584930419922
F-2.2818810599190846
tp3212
sS's.rstrip()'
p3213
(F-2.1155666623796736
F-2.3809362139020647
tp3214
sS"'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3215
(F-2.574312686920166
F-2.3369252341134206
tp3216
sS"s = ' \\n  abc   def   '"
p3217
(F-2.9101776123046874
F-2.384122576032366
tp3218
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'\ntext.splitlines()"
p3219
(F-2.413062875921076
F-2.348341805594308
tp3220
sS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p3221
(F-3.077743183482777
F-2.345343998500279
tp3222
sS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3223
(F-3.004979960123698
F-2.342138017926897
tp3224
sS's.strip()\ns.rstrip()\ns.lstrip()'
p3225
(F-2.574703618099815
F-2.3450698852539062
tp3226
sS"s = ' \\n  abc   def   '\ns.strip()"
p3227
(F-1.882368261163885
F-2.2961128779820035
tp3228
sS"'Hello\\n\\n\\n'.rstrip('\\n')"
p3229
(F-2.574312686920166
F-2.3369252341134206
tp3230
sS's.rstrip()\ns.lstrip()'
p3231
(F-2.675503657414363
F-2.347601754324777
tp3232
sS's.strip()\ns.rstrip()'
p3233
(F-2.404646506676307
F-2.359376907348633
tp3234
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'"
p3235
(F-3.061427688598633
F-2.3551652090890065
tp3236
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()"
p3237
(F-2.281717637005974
F-2.348494393484933
tp3238
sS'text.splitlines()'
p3239
(F-2.3534676688058034
F-2.4133404323032925
tp3240
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()\ns.lstrip()"
p3241
(F-2.393801481827446
F-2.3362791878836497
tp3242
sS's.lstrip()'
p3243
(F-2.358916691371373
F-2.3074095589773997
tp3244
sS"'test string\\n'.rstrip()"
p3245
(F-2.6519192286900113
F-2.3425140380859375
tp3246
sS"'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p3247
(F-3.004979960123698
F-2.342138017926897
tp3248
sS"'Mac EOL\\r'.rstrip('\\r\\n')"
p3249
(F-2.574312686920166
F-2.3369252341134206
tp3250
sS"'test string \\n\\n'.rstrip('\\n')"
p3251
(F-2.574312686920166
F-2.3369252341134206
tp3252
sS"'Unix EOL\\n'.rstrip('\\r\\n')"
p3253
(F-2.574312686920166
F-2.3369252341134206
tp3254
ssI276052
(dp3255
S'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3256
(F-2.961379653297811
F-3.048326932466947
tp3257
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3258
(F-3.080362546371982
F-3.1182594299316406
tp3259
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3260
(F-2.8594514973958334
F-3.1331792978140025
tp3261
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3262
(F-3.5092291581003288
F-3.156941633958083
tp3263
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3264
(F-2.5411429603259785
F-3.039517035851112
tp3265
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3266
(F-3.475503817471591
F-3.4918295053335338
tp3267
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3268
(F-3.8662045127467106
F-3.160527155949519
tp3269
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3270
(F-3.6081109046936035
F-3.31850345318134
tp3271
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3272
(F-3.3287276513943644
F-3.1907574580265927
tp3273
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3274
(F-3.169678329839939
F-3.1003021827110877
tp3275
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3276
(F-3.1266668629606365
F-3.065984872671274
tp3277
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3278
(F-3.586267245017876
F-3.1474938025841346
tp3279
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3280
(F-3.268068326936735
F-3.115918673001803
tp3281
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p3282
(F-2.2711325252757355
F-3.32341795701247
tp3283
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3284
(F-3.7282286423903246
F-3.152327610896184
tp3285
sS'return proc_results_list\n\ndef get_sys_stats():\n    pass'
p3286
(F-3.4219589233398438
F-3.2080462529109073
tp3287
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3288
(F-3.795843453242861
F-3.2953162560096154
tp3289
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3290
(F-3.603978331659881
F-3.1022256704477162
tp3291
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3292
(F-3.3020255348899146
F-2.9841666588416467
tp3293
sS'import psutil'
p3294
(F-4.956544876098633
F-2.9762323819673977
tp3295
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3296
(F-3.23731978567023
F-3.1650704603928785
tp3297
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p3298
(F-1.675459871587065
F-2.9627852806678185
tp3299
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p3300
(F-4.076875574448529
F-3.208264570969802
tp3301
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3302
(F-2.208015773607337
F-3.004622826209435
tp3303
sS"eval_str = ('objItem.%s' % attribute)"
p3304
(F-4.9442055442116475
F-3.485194573035607
tp3305
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3306
(F-3.811349103550711
F-3.0965725825383115
tp3307
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3308
(F-4.07447624206543
F-3.3751590435321512
tp3309
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p3310
(F-4.2369436490333685
F-3.0590303861177883
tp3311
sS'import psutil\nprint psutil.cpu_percent()'
p3312
(F-2.8604513315054088
F-2.8914002638596754
tp3313
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3314
(F-2.955976951181592
F-3.083892822265625
tp3315
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3316
(F-3.221022970952337
F-3.0589288564828725
tp3317
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3318
(F-3.446846420700486
F-3.1615929236778846
tp3319
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3320
(F-3.3100438717022613
F-3.141325437105619
tp3321
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3322
(F-2.951144319624718
F-3.1020977313701925
tp3323
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3324
(F-2.8166326992753623
F-3.203809004563552
tp3325
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3326
(F-3.819248787799285
F-3.187999725341797
tp3327
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p3328
(F-3.7193065296519885
F-2.964605771578275
tp3329
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3330
(F-3.366802150920286
F-3.1926014239971456
tp3331
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p3332
(F-3.2637166732396836
F-3.2025299072265625
tp3333
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3334
(F-3.322971781746286
F-3.15141853919396
tp3335
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3336
(F-3.757189692283163
F-3.140361785888672
tp3337
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3338
(F-3.24841207150277
F-3.149505615234375
tp3339
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3340
(F-3.9971145880026895
F-3.36533208993765
tp3341
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3342
(F-3.8862276803418463
F-3.0552203838641825
tp3343
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3344
(F-2.599215110636646
F-3.072855729323167
tp3345
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3346
(F-3.890843418666295
F-3.075717339148888
tp3347
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3348
(F-2.625023569772154
F-3.0369802621694713
tp3349
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3350
(F-3.5947390636765815
F-3.2264049236591044
tp3351
sS'colItems = objSWbemServices.ExecQuery(query_str)'
p3352
(F-4.9649977684021
F-3.2952244098369894
tp3353
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p3354
(F-2.9569094383110435
F-3.414607414832482
tp3355
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3356
(F-3.3346343865374473
F-3.1713494520920973
tp3357
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3358
(F-2.1682559967041017
F-3.000285808856671
tp3359
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3360
(F-2.901733111213235
F-3.0283531775841346
tp3361
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p3362
(F-2.670543670654297
F-3.037115243765024
tp3363
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3364
(F-2.969030707943282
F-3.065248049222506
tp3365
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3366
(F-3.512982490735176
F-3.288058354304387
tp3367
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3368
(F-3.6226674996170343
F-3.3969896756685696
tp3369
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3370
(F-4.642008180971499
F-3.1560504619891825
tp3371
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3372
(F-3.9294794522798977
F-3.614956782414363
tp3373
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3374
(F-2.7518291766826923
F-3.319592695969802
tp3375
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3376
(F-2.973731256300403
F-3.0799484252929688
tp3377
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3378
(F-3.090899913483246
F-3.194201249342698
tp3379
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list"
p3380
(F-3.301536051432292
F-3.1284839923565206
tp3381
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3382
(F-3.40048444763688
F-3.1936217087965746
tp3383
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3384
(F-3.7955128223220735
F-3.0556719853327823
tp3385
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p3386
(F-1.219511970641121
F-3.0400763291579027
tp3387
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3388
(F-3.166531054079996
F-3.1269598740797777
tp3389
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3390
(F-4.110598415798611
F-3.2886331998384914
tp3391
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3392
(F-3.6999928951263428
F-3.423207796536959
tp3393
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3394
(F-3.3713571648848686
F-3.165096869835487
tp3395
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3396
(F-2.6952027058804
F-3.0815960810734677
tp3397
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3398
(F-2.532134729787844
F-3.0513135469876804
tp3399
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3400
(F-3.8637824164496526
F-3.090314718393179
tp3401
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3402
(F-3.051380778833763
F-3.060881101168119
tp3403
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3404
(F-2.7209347195095486
F-3.050855196439303
tp3405
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3406
(F-2.62714466073895
F-3.314585172213041
tp3407
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3408
(F-3.1399112718941424
F-3.077613537128155
tp3409
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p3410
(F-3.3482442979494107
F-3.1543526282677283
tp3411
sS'import pythoncom\nimport pywintypes'
p3412
(F-4.675945281982422
F-2.9714390681340146
tp3413
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3414
(F-3.4145809311464608
F-3.153132805457482
tp3415
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3416
(F-2.2663875579833985
F-2.9577178955078125
tp3417
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3418
(F-3.745972115652902
F-3.0602276141826925
tp3419
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3420
(F-3.9651706454990148
F-3.1315037653996396
tp3421
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3422
(F-3.335002899169922
F-3.153349069448618
tp3423
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3424
(F-3.3198442677202444
F-3.169881673959585
tp3425
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3426
(F-3.7956483364105225
F-3.131378467266376
tp3427
sS'import os\nimport psutil\npid = os.getpid()'
p3428
(F-2.6014801025390626
F-2.907803168663612
tp3429
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3430
(F-3.1142778240266393
F-3.1171963031475363
tp3431
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3432
(F-2.6472306024460566
F-3.102214813232422
tp3433
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3434
(F-3.20574028775623
F-3.094091562124399
tp3435
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3436
(F-3.844256207659528
F-3.144360762376052
tp3437
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3438
(F-3.236611106178977
F-3.208889594444862
tp3439
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3440
(F-3.7085009765625
F-3.3254300631009617
tp3441
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3442
(F-2.4108811415635145
F-3.004564725435697
tp3443
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3444
(F-3.7650126581606655
F-3.084715036245493
tp3445
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3446
(F-3.0430486505681817
F-3.0712347764235277
tp3447
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3448
(F-2.1980805030235877
F-3.48105709369366
tp3449
sS'def winmem():\n    x = MEMORYSTATUS()'
p3450
(F-2.009807332356771
F-3.2578612107496996
tp3451
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3452
(F-3.97776927118716
F-3.4441317044771633
tp3453
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3454
(F-3.2493231269750704
F-3.149701631986178
tp3455
sS'break'
p3456
(F-2.9274508158365884
F-3.3011509821965146
tp3457
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3458
(F-3.990146852889151
F-3.1593202444223256
tp3459
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p3460
(F-3.409894423051314
F-3.075601724477915
tp3461
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3462
(F-4.001516443519777
F-3.2597691462590146
tp3463
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3464
(F-2.9256162643432617
F-3.2472138038048377
tp3465
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3466
(F-2.9269211303153537
F-3.002299969012921
tp3467
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3468
(F-3.3319276478897604
F-3.14868897658128
tp3469
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3470
(F-3.5750825223866958
F-3.307737790621244
tp3471
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3472
(F-3.1461821541762314
F-3.0671463012695312
tp3473
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            eval_str = ('objItem.%s' % attribute)"
p3474
(F-4.004900778493574
F-3.421050731952374
tp3475
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3476
(F-2.9559334291851442
F-3.0672613290640025
tp3477
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3478
(F-3.872778387017589
F-3.246050614577073
tp3479
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3480
(F-3.465764691752772
F-3.1621422400841346
tp3481
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3482
(F-3.780448230787938
F-3.2482789846567006
tp3483
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3484
(F-3.6097195647483646
F-3.2148942213792067
tp3485
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p3486
(F-3.1253141051930937
F-3.0534063485952525
tp3487
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())'
p3488
(F-2.2608839670817056
F-2.958313281719501
tp3489
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3490
(F-3.777108086480035
F-3.1492779071514425
tp3491
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3492
(F-3.7235900584050423
F-3.097666520338792
tp3493
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3494
(F-2.6819512110998094
F-3.049024141751803
tp3495
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3496
(F-3.3393090877221736
F-3.1639058039738583
tp3497
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3498
(F-2.859160772644647
F-3.0666574331430287
tp3499
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3500
(F-3.7384544735863097
F-3.060958275428185
tp3501
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p3502
(F-2.9583170125772664
F-3.4197927621694713
tp3503
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3504
(F-2.77001953125
F-3.1482840317946215
tp3505
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3506
(F-2.410605179636102
F-3.128497783954327
tp3507
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3508
(F-3.1793781831904497
F-3.1458570040189304
tp3509
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3510
(F-3.7496107066761364
F-3.1538396982046275
tp3511
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3512
(F-3.205998470908717
F-3.1991019615760217
tp3513
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3514
(F-3.169045598560591
F-3.19513673048753
tp3515
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3516
(F-3.6215670340401784
F-3.072647681603065
tp3517
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3518
(F-1.7629716981132075
F-2.990831521841196
tp3519
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3520
(F-3.0821499227292497
F-3.0743807279146633
tp3521
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3522
(F-3.818648091862711
F-3.1116787837101865
tp3523
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3524
(F-3.183886795163341
F-3.0966438880333533
tp3525
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3526
(F-3.3313933504787783
F-3.175990178034856
tp3527
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3528
(F-2.990463116847047
F-3.0795076810396633
tp3529
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3530
(F-3.6984965466805715
F-3.0998670137845554
tp3531
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3532
(F-3.209244666466346
F-3.1327039278470554
tp3533
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3534
(F-2.9626661278735633
F-3.2522239685058594
tp3535
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p3536
(F-2.4199903794935533
F-3.344929915208083
tp3537
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3538
(F-3.2903150209508145
F-3.2254277742826023
tp3539
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3540
(F-3.072455322265625
F-3.0759623600886417
tp3541
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3542
(F-2.5073549224109186
F-2.975003169133113
tp3543
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3544
(F-2.5808262308315597
F-3.034547072190505
tp3545
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3546
(F-3.9925701664943323
F-3.0122909545898438
tp3547
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3548
(F-2.9432236782340118
F-3.0532798767089844
tp3549
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3550
(F-3.611452774262764
F-3.3005526616023135
tp3551
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3552
(F-2.9613490960536857
F-3.5565851651705227
tp3553
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3554
(F-2.814256217611495
F-2.991620283860427
tp3555
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3556
(F-3.431161376953125
F-3.145284212552584
tp3557
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3558
(F-3.3626967628403466
F-3.1616351787860575
tp3559
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3560
(F-2.6607674046566614
F-2.9669124896709738
tp3561
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3562
(F-3.233275296395285
F-3.1429243821364183
tp3563
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3564
(F-3.0830760478107986
F-3.0979667076697717
tp3565
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3566
(F-2.9595454653720896
F-3.0576151334322414
tp3567
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3568
(F-1.7586283164449257
F-2.9669967064490685
tp3569
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3570
(F-2.4741355399408285
F-2.9600384051983175
tp3571
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3572
(F-2.7472978071732954
F-3.034163548396184
tp3573
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3574
(F-2.442783721505779
F-3.0346207251915565
tp3575
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3576
(F-3.378951234766324
F-3.1792159447303185
tp3577
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3578
(F-3.354967683330736
F-3.1986160278320312
tp3579
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3580
(F-3.7237518310546873
F-3.078188969538762
tp3581
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3582
(F-3.3291726452126844
F-3.1545771085298977
tp3583
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3584
(F-3.3216367145677195
F-3.22084955068735
tp3585
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p3586
(F-4.67070574079241
F-3.6257881751427283
tp3587
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3588
(F-3.1983406810553925
F-3.1421869718111477
tp3589
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p3590
(F-3.7904091971261162
F-3.0494974576509914
tp3591
sS'__revision__ = 3'
p3592
(F-5.093345097133091
F-3.4462925837590146
tp3593
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3594
(F-3.257401758310746
F-3.191070850078876
tp3595
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3596
(F-2.792819341023763
F-3.01229007427509
tp3597
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p3598
(F-2.9429111305726776
F-3.3826707693246694
tp3599
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3600
(F-2.551740837097168
F-3.0296011704664965
tp3601
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3602
(F-2.351591796875
F-2.974116398737981
tp3603
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3604
(F-3.132516072591146
F-3.068823007436899
tp3605
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3606
(F-3.3037861739054764
F-3.175738994891827
tp3607
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3608
(F-4.748995267427885
F-3.1045279869666467
tp3609
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3610
(F-3.8295686783329135
F-3.0935079134427586
tp3611
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3612
(F-3.3453787557733885
F-3.163014925443209
tp3613
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3614
(F-2.301012279369213
F-2.9827810434194713
tp3615
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3616
(F-3.952879654733758
F-3.1300333463228664
tp3617
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3618
(F-4.105574174360796
F-3.3862850482647238
tp3619
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3620
(F-3.8772517337074763
F-3.107343526986929
tp3621
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3622
(F-3.1366252657733384
F-3.082962623009315
tp3623
sS'import os'
p3624
(F-4.504017353057861
F-3.0734613858736477
tp3625
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3626
(F-2.9280380002345554
F-3.098989046536959
tp3627
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p3628
(F-2.5688994835162986
F-3.3294525146484375
tp3629
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p3630
(F-2.6936647368640436
F-3.3133929325984073
tp3631
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3632
(F-3.287108760036209
F-3.2267186091496396
tp3633
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3634
(F-2.940325603392965
F-3.0698380103478065
tp3635
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()'
p3636
(F-2.110825254206072
F-3.0431990990271935
tp3637
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3638
(F-3.6021107991536456
F-3.1015064532940206
tp3639
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3640
(F-3.9876044442720504
F-3.1754364600548377
tp3641
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list"
p3642
(F-3.6057056245349703
F-3.249165755051833
tp3643
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3644
(F-4.0019969355109275
F-3.1623764038085938
tp3645
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3646
(F-3.7567440469326567
F-3.2482056250939
tp3647
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3648
(F-2.865854562806689
F-3.2484283447265625
tp3649
sS'for counter_type in perf_object_list:\n    pass'
p3650
(F-3.169709373922909
F-3.571126497708834
tp3651
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3652
(F-2.777940368652344
F-3.3123582693246694
tp3653
sS'def winmem():\n    pass'
p3654
(F-1.3882129842584783
F-3.1943849416879506
tp3655
sS'import datetime'
p3656
(F-5.064818382263184
F-3.116693349984976
tp3657
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3658
(F-2.4690722499246385
F-3.0118082486666164
tp3659
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3660
(F-3.0879432415140085
F-3.3542019770695615
tp3661
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3662
(F-3.03922785956429
F-3.0573674715482273
tp3663
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3664
(F-3.4266781481394326
F-3.1215535677396336
tp3665
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3666
(F-2.417999671784458
F-3.020098172701322
tp3667
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3668
(F-3.0610890706380207
F-3.4038414588341346
tp3669
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3670
(F-3.1059608001447256
F-3.070171062762921
tp3671
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3672
(F-4.140914069281684
F-3.596559377817007
tp3673
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p3674
(F-4.209912708827427
F-3.4686009333683896
tp3675
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3676
(F-3.172457608309659
F-3.066609896146334
tp3677
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3678
(F-3.2983784075304334
F-3.161785419170673
tp3679
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3680
(F-2.7029394660767574
F-3.0530935434194713
tp3681
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3682
(F-3.28550041158786
F-3.154250218318059
tp3683
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3684
(F-3.713404581555581
F-3.2468572763296275
tp3685
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3686
(F-3.956378643329327
F-3.580391810490535
tp3687
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3688
(F-3.172842992821275
F-3.1032389127291164
tp3689
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3690
(F-2.3674563055169093
F-3.034703181340144
tp3691
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3692
(F-3.328401207660734
F-3.1903598491962137
tp3693
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3694
(F-3.353715125917043
F-3.159300584059495
tp3695
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3696
(F-3.846306730571546
F-3.0822513286884012
tp3697
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3698
(F-3.7774779579856177
F-3.1010372455303488
tp3699
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3700
(F-3.349401092529297
F-3.0893625112680287
tp3701
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3702
(F-3.002477324057999
F-3.0938421396108775
tp3703
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p3704
(F-3.4068531237150492
F-2.976933405949519
tp3705
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3706
(F-3.9389409604279892
F-3.2803192138671875
tp3707
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3708
(F-2.6607643888075905
F-3.080587240365835
tp3709
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p3710
(F-3.123141484855558
F-3.069195087139423
tp3711
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3712
(F-2.834686917739932
F-3.1401810279259315
tp3713
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3714
(F-4.252107620239258
F-3.3096234248234677
tp3715
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3716
(F-3.090985107421875
F-3.072249485896184
tp3717
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3718
(F-3.801884969075521
F-3.182933807373047
tp3719
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3720
(F-3.833910529996142
F-3.258312518780048
tp3721
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3722
(F-3.364316638764881
F-3.1452005826509914
tp3723
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3724
(F-3.5531732895795036
F-3.234500004695012
tp3725
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3726
(F-3.258824435147372
F-3.163330078125
tp3727
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3728
(F-2.6768563164605035
F-3.066595517672025
tp3729
sS'pid = os.getpid()\npy = psutil.Process(pid)'
p3730
(F-2.7828557756212025
F-2.914551074688251
tp3731
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3732
(F-3.2683974322150737
F-3.1394512469951925
tp3733
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3734
(F-3.3254686438519023
F-3.1876164949857273
tp3735
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3736
(F-2.5430449503331096
F-3.2985073969914365
tp3737
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3738
(F-3.2575113687170556
F-3.2364220252403846
tp3739
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3740
(F-3.6753457099303137
F-3.101544893704928
tp3741
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3742
(F-3.4431482571274485
F-3.179515545184796
tp3743
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3744
(F-2.835911859660388
F-3.217638455904447
tp3745
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3746
(F-2.607636003863087
F-2.9842168367826023
tp3747
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3748
(F-3.187244943996833
F-3.1121292114257812
tp3749
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3750
(F-3.34075927734375
F-3.2125153174767127
tp3751
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3752
(F-3.5165708529874213
F-3.050923567551833
tp3753
sS'import psutil\npid = os.getpid()'
p3754
(F-2.803577423095703
F-2.9028986417330227
tp3755
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3756
(F-3.2849559998244384
F-3.1547376192533054
tp3757
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p3758
(F-3.0780829757940573
F-3.097944112924429
tp3759
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p3760
(F-2.322613620018774
F-3.0350843576284556
tp3761
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3762
(F-3.0977428050822082
F-3.051629579984225
tp3763
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3764
(F-3.28627674113292
F-3.056043184720553
tp3765
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3766
(F-4.004790100870253
F-3.355611360990084
tp3767
sS'print this_proc_results'
p3768
(F-4.745609283447266
F-3.186604719895583
tp3769
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3770
(F-3.2314687528849704
F-3.056802896352915
tp3771
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3772
(F-3.227394615662258
F-3.104429978590745
tp3773
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3774
(F-3.5656266475747698
F-3.2196734501765323
tp3775
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p3776
(F-4.1322796161358175
F-3.4180538470928488
tp3777
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3778
(F-3.3504030632250235
F-3.1891065744253306
tp3779
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3780
(F-3.659040074148578
F-3.231221712552584
tp3781
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3782
(F-3.1744626690147504
F-3.0696287888746996
tp3783
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p3784
(F-3.771388420691857
F-2.967285449688251
tp3785
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3786
(F-2.6716795834628018
F-3.101120875431941
tp3787
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3788
(F-3.783821837542808
F-3.163848876953125
tp3789
sS'import pywintypes'
p3790
(F-5.294427871704102
F-3.0549647991473856
tp3791
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3792
(F-3.131610844759333
F-3.0688450153057394
tp3793
sS'if (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3794
(F-3.3215066415292247
F-3.589030045729417
tp3795
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3796
(F-3.453291740970335
F-3.173508570744441
tp3797
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3798
(F-1.5323747146961302
F-3.0460674579326925
tp3799
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3800
(F-2.404414306640625
F-3.3753656240609975
tp3801
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3802
(F-2.4714608784594567
F-3.02812987107497
tp3803
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3804
(F-2.944323433770074
F-3.1364869337815504
tp3805
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3806
(F-3.456346180936282
F-3.1273912283090444
tp3807
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p3808
(F-3.886413065592448
F-3.341128422663762
tp3809
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3810
(F-3.5358734130859375
F-3.182893312894381
tp3811
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p3812
(F-2.9860174244847792
F-3.093402862548828
tp3813
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p3814
(F-1.9228932189941406
F-3.017717801607572
tp3815
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p3816
(F-4.3328447341918945
F-3.0613168569711537
tp3817
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3818
(F-3.298585891723633
F-3.1707065288837137
tp3819
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3820
(F-3.1298234939575194
F-3.127668234018179
tp3821
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3822
(F-3.147700854934617
F-3.066425616924579
tp3823
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3824
(F-3.2949352264404297
F-3.3433946462777944
tp3825
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3826
(F-2.614296653053977
F-3.032826643723708
tp3827
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3828
(F-3.2510618179563493
F-3.11435053898738
tp3829
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3830
(F-3.3463262339107325
F-3.1774561955378604
tp3831
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3832
(F-3.3008973598480225
F-2.9814183161808896
tp3833
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3834
(F-3.7533153855657004
F-3.3466676565317006
tp3835
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3836
(F-2.2930221557617188
F-3.0126413198617787
tp3837
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3838
(F-2.40377924992488
F-3.009633284348708
tp3839
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3840
(F-3.7618591095927703
F-3.1837806701660156
tp3841
sS'def get_pid_stats(self, pid):\n    pass'
p3842
(F-2.5257426367865667
F-2.9431671729454627
tp3843
sS'import win32com.client'
p3844
(F-3.105545997619629
F-3.0805672865647535
tp3845
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3846
(F-2.7683076542135665
F-3.2044310936561
tp3847
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3848
(F-3.000121447504783
F-3.121922419621394
tp3849
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3850
(F-3.216957737336006
F-3.104746598463792
tp3851
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3852
(F-3.993572235107422
F-3.5570672842172475
tp3853
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3854
(F-4.016349129054857
F-3.3624784029447117
tp3855
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3856
(F-3.8125463025323274
F-3.0955370389498196
tp3857
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p3858
(F-3.336672229927127
F-3.18712410560021
tp3859
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3860
(F-2.8705844116210937
F-3.1536199129544773
tp3861
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3862
(F-3.737058577998992
F-3.24811759361854
tp3863
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3864
(F-3.3919847832351433
F-3.0818590017465444
tp3865
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3866
(F-3.5065872192382814
F-3.4438816950871396
tp3867
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3868
(F-3.4730074768565875
F-3.1230319096491885
tp3869
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3870
(F-2.8503358364105225
F-3.155217097355769
tp3871
sS"pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p3872
(F-3.9437363942464194
F-2.926568544827975
tp3873
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p3874
(F-3.354690890842014
F-3.109266134408804
tp3875
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3876
(F-3.317421291185462
F-3.1623089130108175
tp3877
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3878
(F-3.42564277908429
F-3.183369856614333
tp3879
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3880
(F-3.279384068080357
F-3.0673528817983775
tp3881
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3882
(F-3.8843425403941763
F-3.3183878385103664
tp3883
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p3884
(F-4.0888456617082864
F-3.256055685190054
tp3885
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p3886
(F-1.682338789397595
F-2.9860255901630106
tp3887
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3888
(F-2.653124234981693
F-3.0538564828725963
tp3889
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3890
(F-2.790921481150501
F-3.2791175842285156
tp3891
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3892
(F-3.3708691804305366
F-3.116792238675631
tp3893
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3894
(F-3.3155030287973615
F-3.1040728642390323
tp3895
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3896
(F-3.2584388185654007
F-3.051426814152644
tp3897
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3898
(F-3.4961057622381984
F-3.0457596412071815
tp3899
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3900
(F-4.298556452212126
F-3.5183431185208836
tp3901
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3902
(F-2.5766937077394005
F-3.0213309067946215
tp3903
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3904
(F-3.240564644811008
F-3.1996075556828427
tp3905
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p3906
(F-3.321644079216703
F-3.188443110539363
tp3907
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3908
(F-4.036845379565135
F-3.176009251521184
tp3909
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3910
(F-3.8951899210611978
F-2.960138174203726
tp3911
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3912
(F-3.124262287758327
F-3.0688902047964244
tp3913
sS"import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p3914
(F-3.7725657710322626
F-2.907092754657452
tp3915
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3916
(F-3.4521292617037833
F-3.1559078509990988
tp3917
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3918
(F-2.5979151232489226
F-3.165172576904297
tp3919
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3920
(F-4.100931654881387
F-3.151441133939303
tp3921
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3922
(F-3.7857282922623003
F-3.1889560406024637
tp3923
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3924
(F-3.28789818805197
F-3.1520453232985277
tp3925
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p3926
(F-3.949995342053865
F-3.540925539456881
tp3927
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3928
(F-3.0346929615941542
F-3.416719289926382
tp3929
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3930
(F-3.007368018064784
F-3.1653533348670373
tp3931
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os'
p3932
(F-3.6514949253627234
F-3.2730351961576023
tp3933
sS'import os\nimport psutil'
p3934
(F-3.853802272251674
F-2.958650442270132
tp3935
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3936
(F-3.6210740033318016
F-3.100062443659856
tp3937
sS'return x'
p3938
(F-3.637774705886841
F-3.309480520395132
tp3939
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3940
(F-4.27609193091299
F-3.367127932035006
tp3941
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3942
(F-2.7374402264642983
F-3.309337615966797
tp3943
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3944
(F-3.3077362362701113
F-3.1540621243990383
tp3945
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3946
(F-2.8997489430425243
F-3.049176436204177
tp3947
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3948
(F-2.8295515872645036
F-2.995361621563251
tp3949
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3950
(F-3.126496772826954
F-3.0764837998610277
tp3951
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3952
(F-3.0883106904871322
F-3.0701238192044773
tp3953
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3954
(F-3.9040578510946857
F-3.1224054189828725
tp3955
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3956
(F-3.736789598651961
F-3.15788327730619
tp3957
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3958
(F-4.010359259927348
F-3.1630979684682994
tp3959
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3960
(F-4.163050564852628
F-3.328273186316857
tp3961
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3962
(F-1.7889657020568848
F-2.9850554833045373
tp3963
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3964
(F-3.3056948130367365
F-3.2010715191180887
tp3965
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3966
(F-4.1752117288523705
F-3.2321131779597354
tp3967
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3968
(F-3.359295378006044
F-3.2209848257211537
tp3969
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p3970
(F-3.130304832981057
F-3.406412564791166
tp3971
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p3972
(F-3.6894267689098013
F-3.065923837515024
tp3973
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3974
(F-1.8497989230685763
F-3.487640380859375
tp3975
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p3976
(F-5.090231577555339
F-3.4615948016826925
tp3977
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3978
(F-3.6672682063594744
F-3.324016864483173
tp3979
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3980
(F-3.247389327648074
F-3.0953985360952525
tp3981
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3982
(F-3.70201416015625
F-3.163503206693209
tp3983
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3984
(F-2.7141500651041666
F-3.0379703228290262
tp3985
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p3986
(F-4.021990966796875
F-3.1558368389423075
tp3987
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3988
(F-3.7088849544525146
F-3.3170242309570312
tp3989
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3990
(F-3.2898761167070045
F-3.1851366483248196
tp3991
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3992
(F-3.3164007308635304
F-3.193652813251202
tp3993
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3994
(F-3.7773165138818885
F-3.1121820303109975
tp3995
sS"return sys_dict\nif (__name__ == '__main__'):\n    pass"
p3996
(F-3.2114513397216795
F-3.3279489370492787
tp3997
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3998
(F-3.6966892199569874
F-3.1450013380784254
tp3999
sS'from __future__ import print_function'
p4000
(F-1.4211864471435547
F-3.1493509732759914
tp4001
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4002
(F-2.732330592332688
F-3.24288823054387
tp4003
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4004
(F-3.293387474951806
F-3.1156991811899037
tp4005
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4006
(F-3.3740552497632574
F-3.147774622990535
tp4007
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4008
(F-2.4230965009701797
F-3.2639201237605167
tp4009
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4010
(F-4.100430747335271
F-3.220418196458083
tp4011
sS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4012
(F-3.258212578005907
F-3.4035712022047777
tp4013
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4014
(F-2.8438866097045596
F-3.018873068002554
tp4015
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4016
(F-2.480971299208604
F-3.0049253610464244
tp4017
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4018
(F-3.767386973987926
F-2.9954833984375
tp4019
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4020
(F-3.3765211998908646
F-3.149152609018179
tp4021
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4022
(F-3.033333162006579
F-3.066730499267578
tp4023
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4024
(F-3.2773531641629177
F-3.142588101900541
tp4025
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4026
(F-2.4852412923177085
F-3.0853292025052586
tp4027
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4028
(F-2.758255168955813
F-3.047076885516827
tp4029
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4030
(F-1.940911172818737
F-3.088399446927584
tp4031
sS'if (not self.process_name_list):\n    found_flag = True'
p4032
(F-2.771786082874645
F-3.344085693359375
tp4033
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4034
(F-3.602944766773897
F-3.2234737689678488
tp4035
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p4036
(F-3.073595567183061
F-3.003263620229868
tp4037
sS"memoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p4038
(F-4.648026989352319
F-3.203398191011869
tp4039
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4040
(F-3.2714825500285505
F-3.1867910531850963
tp4041
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p4042
(F-4.497010102143159
F-3.306682293231671
tp4043
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4044
(F-3.7537399818157327
F-3.0572677025428185
tp4045
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4046
(F-4.499477170548349
F-3.388295393723708
tp4047
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4048
(F-2.6708212352934337
F-3.0751093350923977
tp4049
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4050
(F-4.60177001953125
F-3.0402576739971456
tp4051
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4052
(F-4.42516465620561
F-3.414133512056791
tp4053
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4054
(F-2.4892962121016144
F-3.0782497112567606
tp4055
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4056
(F-3.6659413090458624
F-3.0510019155649037
tp4057
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4058
(F-3.4284847861842107
F-3.1496109595665565
tp4059
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4060
(F-3.328418449815271
F-3.196569589468149
tp4061
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4062
(F-3.152818672612028
F-3.2194119966947117
tp4063
sS'if (not self.perf_object_list):\n    pass'
p4064
(F-2.932540045844184
F-3.424714601956881
tp4065
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4066
(F-2.9319711223208933
F-3.09272707425631
tp4067
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4068
(F-3.270599437040441
F-3.1771017221304088
tp4069
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4070
(F-3.480723119980796
F-3.1618719834547777
tp4071
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4072
(F-2.9837691993044135
F-3.1977192805363583
tp4073
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4074
(F-3.014343485290751
F-3.170959179217999
tp4075
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4076
(F-3.234373876653566
F-3.1946405264047475
tp4077
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4078
(F-3.3476531596123418
F-3.145196767953726
tp4079
sS'if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p4080
(F-3.1121600014822826
F-3.5097491924579325
tp4081
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4082
(F-2.1085007231114274
F-2.9630614060621996
tp4083
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4084
(F-3.11705315918815
F-3.117213322566106
tp4085
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4086
(F-2.5024561728200605
F-3.0447425842285156
tp4087
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4088
(F-2.1445777015348453
F-2.977313995361328
tp4089
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4090
(F-2.5088772828551544
F-2.9806879483736477
tp4091
sS'return proc_results_list'
p4092
(F-4.755335807800293
F-3.356981424184946
tp4093
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4094
(F-2.851292902500785
F-3.0268950829139123
tp4095
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4096
(F-2.88676324291764
F-2.983263455904447
tp4097
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4098
(F-3.1493492777437075
F-3.066876924954928
tp4099
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4100
(F-3.1323789938902245
F-3.123875251183143
tp4101
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4102
(F-3.0949133604870998
F-3.0674109825721154
tp4103
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4104
(F-3.1333550635804523
F-3.083251659686749
tp4105
sS'for proc_name in self.process_name_list:\n    pass'
p4106
(F-2.66432711952611
F-3.3900011502779446
tp4107
sS"for counter_type in perf_object_list:\n    strComputer = '.'"
p4108
(F-4.169294357299805
F-3.5005534245417667
tp4109
sS"strComputer = '.'"
p4110
(F-5.457551956176758
F-3.339142139141376
tp4111
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4112
(F-3.6824966872236735
F-3.141561361459585
tp4113
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4114
(F-2.3115318885216345
F-2.959411327655499
tp4115
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4116
(F-3.645456371498746
F-3.0882503802959738
tp4117
sS"print ('memory use:', memoryUse)"
p4118
(F-3.9952303568522134
F-3.0912851186899037
tp4119
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4120
(F-3.341160857371795
F-3.1448643024151144
tp4121
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4122
(F-2.7465218098958335
F-3.1520379873422475
tp4123
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4124
(F-2.5708403410734952
F-3.1937294006347656
tp4125
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        pass"
p4126
(F-4.013637542724609
F-3.226779057429387
tp4127
sS'pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p4128
(F-4.016232299804687
F-2.924259772667518
tp4129
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4130
(F-3.0747880897974307
F-3.1513111407940206
tp4131
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4132
(F-3.9469446389071914
F-3.2233299842247596
tp4133
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4134
(F-3.3091575032933256
F-3.1745135967548075
tp4135
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4136
(F-3.570105465975675
F-3.341308887188251
tp4137
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4138
(F-2.9617882494656547
F-3.1203478299654446
tp4139
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4140
(F-3.3239143533909576
F-3.170159853421725
tp4141
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4142
(F-3.7797129641297045
F-3.3631210327148438
tp4143
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4144
(F-2.9033915201822915
F-3.0434652475210338
tp4145
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4146
(F-3.3244695052724755
F-3.226511735182542
tp4147
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4148
(F-3.1053414952340734
F-3.0999427208533654
tp4149
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4150
(F-3.3046953493105597
F-3.182361309344952
tp4151
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4152
(F-3.1606647503265286
F-3.078250298133263
tp4153
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4154
(F-2.8181564529220777
F-3.081770970271184
tp4155
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p4156
(F-2.5691234447337963
F-3.4514180696927586
tp4157
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4158
(F-3.217201991387975
F-3.202709197998047
tp4159
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4160
(F-3.110368035656358
F-3.176272759070763
tp4161
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4162
(F-3.3674455011983317
F-3.138292752779447
tp4163
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4164
(F-3.749560387305964
F-3.1370330223670373
tp4165
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4166
(F-3.1474530351629046
F-3.101617666391226
tp4167
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p4168
(F-3.593259811401367
F-3.1205869821401744
tp4169
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4170
(F-2.075062545304446
F-3.0644070551945615
tp4171
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4172
(F-3.0610488689943556
F-3.1320665799654446
tp4173
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4174
(F-2.862956362475681
F-3.223083789532001
tp4175
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4176
(F-3.23599787962627
F-3.044658660888672
tp4177
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4178
(F-3.6481596657593327
F-3.0961233285757213
tp4179
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p4180
(F-4.1323752889827805
F-3.398534921499399
tp4181
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4182
(F-3.8816478998974118
F-3.37472416804387
tp4183
sS'import pywintypes\nimport datetime'
p4184
(F-4.554755619594029
F-2.996087881234976
tp4185
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4186
(F-1.5812677950472445
F-3.041810549222506
tp4187
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass'
p4188
(F-3.264850484913793
F-3.2644183819110575
tp4189
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4190
(F-3.769564856401822
F-3.1326968853290262
tp4191
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4192
(F-3.735579017254946
F-3.2258130587064304
tp4193
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4194
(F-3.2503793721571768
F-3.1886009803185096
tp4195
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4196
(F-3.817878748324051
F-3.0925269493689904
tp4197
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4198
(F-3.378863578464674
F-3.1586808424729567
tp4199
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4200
(F-2.4032075670030384
F-3.077025193434495
tp4201
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4202
(F-3.647986888885498
F-3.1547496502216044
tp4203
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4204
(F-3.703412162540294
F-3.2055772634652944
tp4205
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4206
(F-3.689901251541941
F-3.0951793377216044
tp4207
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4208
(F-3.546903284584604
F-3.0784436739408054
tp4209
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4210
(F-4.061011112097538
F-3.040633274958684
tp4211
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4212
(F-3.8242560192547015
F-3.1577371450570912
tp4213
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p4214
(F-1.8834129616066262
F-3.2776448176457333
tp4215
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p4216
(F-3.8018165588378907
F-3.0556270892803488
tp4217
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4218
(F-2.9617958762428978
F-3.0359714214618387
tp4219
sS'this_proc_results = stats_processor.get_pid_stats(this_pid)'
p4220
(F-4.674758564342152
F-3.0499332134540262
tp4221
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4222
(F-3.0903993879045757
F-3.067642798790565
tp4223
sS'obj_name = objItem.Name'
p4224
(F-5.613787841796875
F-3.4834283682016225
tp4225
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4226
(F-3.4927309903231536
F-3.3125070425180287
tp4227
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4228
(F-3.4246430596110833
F-3.0871359018179088
tp4229
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p4230
(F-3.411374733664773
F-3.3822353069598856
tp4231
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4232
(F-3.034436233644563
F-3.0729106022761417
tp4233
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4234
(F-3.9583389914247413
F-3.150396493765024
tp4235
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4236
(F-3.7866016224118098
F-3.0485587486853967
tp4237
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4238
(F-3.8303617037259614
F-3.104641547569862
tp4239
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p4240
(F-2.380228988996899
F-3.03305171086238
tp4241
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4242
(F-3.296279676032789
F-3.1902254544771633
tp4243
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4244
(F-3.1617293584914434
F-3.2089776259202223
tp4245
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            pass"
p4246
(F-3.8227606879340277
F-3.350070366492638
tp4247
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4248
(F-3.3591111868866217
F-3.1759100693922777
tp4249
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4250
(F-3.4856986251531863
F-3.168576167179988
tp4251
sS"if (__name__ == '__main__'):\n    pass"
p4252
(F-1.8626619974772136
F-3.2354451693021336
tp4253
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4254
(F-3.097357412484976
F-3.104015056903546
tp4255
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4256
(F-2.755452145812332
F-3.266749455378606
tp4257
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p4258
(F-2.9963669179604566
F-3.059239020714393
tp4259
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4260
(F-3.1143540810945827
F-3.1148922259990988
tp4261
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p4262
(F-2.977145608402629
F-3.0448068472055287
tp4263
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4264
(F-2.691181426352643
F-3.246611081636869
tp4265
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4266
(F-3.806898362565749
F-3.105865185077374
tp4267
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4268
(F-3.114480398751639
F-3.1008377075195312
tp4269
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4270
(F-3.1972360638132122
F-3.1017784705528846
tp4271
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4272
(F-3.6383774031454057
F-3.09306892981896
tp4273
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4274
(F-2.1463447946016907
F-3.2464045011080227
tp4275
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4276
(F-4.097264029762962
F-3.163157242995042
tp4277
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4278
(F-3.2381158754146298
F-3.1050535348745494
tp4279
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4280
(F-3.7330577464884582
F-3.1913575392503004
tp4281
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4282
(F-3.068971463335239
F-3.1077059232271633
tp4283
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4284
(F-2.753969555058755
F-3.24965579693134
tp4285
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4286
(F-3.7802023691673803
F-3.151395944448618
tp4287
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4288
(F-3.167978813812023
F-3.1201095581054688
tp4289
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4290
(F-3.690953125
F-3.1467044536884012
tp4291
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4292
(F-3.93207298398642
F-3.262912163367638
tp4293
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4294
(F-4.191456864519817
F-3.1416071378267727
tp4295
sS'py = psutil.Process(pid)'
p4296
(F-3.457342529296875
F-2.9543190002441406
tp4297
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4298
(F-3.18523984342008
F-3.095733349139874
tp4299
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4300
(F-3.1426797884213524
F-3.0632365300105167
tp4301
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4302
(F-3.7163872718811035
F-3.1489539513221154
tp4303
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4304
(F-2.7141017440922006
F-3.0615093524639425
tp4305
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4306
(F-2.567518036941002
F-2.9810101435734677
tp4307
sS'import os\nthis_pid = os.getpid()'
p4308
(F-2.5019634791782925
F-2.921497051532452
tp4309
sS'for proc_name in self.process_name_list:\n    obj_name = objItem.Name'
p4310
(F-3.4809197645920973
F-3.424730447622446
tp4311
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4312
(F-3.45085
F-3.1341893122746396
tp4313
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4314
(F-3.2728115587349396
F-3.142669384296124
tp4315
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4316
(F-3.6614478217230904
F-3.224212939922626
tp4317
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4318
(F-3.952651652883976
F-3.0860355083759012
tp4319
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4320
(F-3.709167019826061
F-3.1697152944711537
tp4321
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p4322
(F-4.851908220563616
F-3.45703858595628
tp4323
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4324
(F-3.409744079736211
F-3.2035440298227162
tp4325
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4326
(F-2.618393299191497
F-3.0240616431603065
tp4327
sS'pythoncom.CoInitialize()\nproc_results_list = []'
p4328
(F-4.199346205767463
F-3.246983454777644
tp4329
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4330
(F-2.6599954517964783
F-3.3172261164738583
tp4331
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4332
(F-3.013117542005565
F-3.019955561711238
tp4333
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4334
(F-3.76505011020426
F-3.3766919649564304
tp4335
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4336
(F-3.0853631769569176
F-3.0544859079214244
tp4337
sS'return this_proc_dict\n\ndef get_stats(self):\n    pass'
p4338
(F-2.910715623335405
F-3.3013980572040262
tp4339
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4340
(F-2.381272997174944
F-3.3666857205904446
tp4341
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p4342
(F-3.082359858921596
F-3.01101567195012
tp4343
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4344
(F-3.248109512511187
F-3.1062046931340146
tp4345
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4346
(F-2.137207173855505
F-3.0248565673828125
tp4347
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4348
(F-3.2777295411380014
F-3.1777772169846754
tp4349
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4350
(F-2.2238599830698744
F-3.0273622366098256
tp4351
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4352
(F-1.736077252556296
F-3.08662355863131
tp4353
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4354
(F-2.46845978381587
F-3.2469153771033654
tp4355
sS'this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4356
(F-3.9257700443267822
F-2.9752960205078125
tp4357
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4358
(F-2.681679947369573
F-3.1112835223858175
tp4359
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4360
(F-4.005012326124238
F-3.1327056884765625
tp4361
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4362
(F-3.6759754693330224
F-3.0701346764197717
tp4363
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4364
(F-2.8213585162984915
F-3.1623282799353967
tp4365
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4366
(F-3.256280915257613
F-3.064897977388822
tp4367
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4368
(F-3.677281429893092
F-2.958087921142578
tp4369
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4370
(F-3.8172450474330355
F-3.14174564068134
tp4371
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p4372
(F-1.6354774475097655
F-3.335836263803335
tp4373
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4374
(F-3.3173828125
F-3.2439947861891527
tp4375
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4376
(F-3.3927291067023027
F-3.3847128061147838
tp4377
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4378
(F-4.135538320072362
F-3.382498814509465
tp4379
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4380
(F-2.540225237784301
F-2.960084181565505
tp4381
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4382
(F-3.0828011302741425
F-3.113893068753756
tp4383
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4384
(F-2.811563393504349
F-3.0426160372220554
tp4385
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4386
(F-1.9774801013539138
F-3.0024640009953427
tp4387
sS"' Returns a dictionary of the system stats'"
p4388
(F-4.705976486206055
F-3.3954752408541164
tp4389
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p4390
(F-2.85034205995757
F-3.3357168344350963
tp4391
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4392
(F-2.74607986369461
F-3.0202803978553185
tp4393
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4394
(F-2.976350588219188
F-3.1515857989971456
tp4395
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4396
(F-2.5036584680730645
F-3.3488294161283054
tp4397
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p4398
(F-3.932725989300272
F-3.2155142564039965
tp4399
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4400
(F-3.407747605267693
F-3.263448568490835
tp4401
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4402
(F-2.747289272701794
F-3.217789283165565
tp4403
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4404
(F-2.6927614316835506
F-3.0932047917292667
tp4405
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4406
(F-3.6734127717859604
F-3.1566649216871996
tp4407
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p4408
(F-2.7246283254315777
F-3.3358318622295675
tp4409
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4410
(F-3.093837071131993
F-3.100811004638672
tp4411
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4412
(F-3.9851116982235273
F-3.1128372779259315
tp4413
sS'from __future__ import print_function\nimport psutil'
p4414
(F-2.303305845994216
F-3.0269737243652344
tp4415
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4416
(F-3.0360904343784116
F-3.0223667438213644
tp4417
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4418
(F-3.2935376677749675
F-3.195055154653696
tp4419
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4420
(F-3.307742208962912
F-3.185666010929988
tp4421
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4422
(F-3.4409493885869566
F-3.152283008282001
tp4423
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4424
(F-4.3194122314453125
F-3.25530037513146
tp4425
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4426
(F-3.7778260202118843
F-3.158346029428335
tp4427
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4428
(F-3.3089955265360667
F-3.418017167311448
tp4429
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4430
(F-3.3022036780737003
F-3.071470700777494
tp4431
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p4432
(F-3.135184566990859
F-3.0987164424015927
tp4433
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4434
(F-3.714419869815602
F-3.1748082087590146
tp4435
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4436
(F-3.59322998046875
F-3.321122096135066
tp4437
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4438
(F-3.2467672870088076
F-3.1893072861891527
tp4439
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4440
(F-3.200247498014761
F-3.1043580862192006
tp4441
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4442
(F-2.6500613742404515
F-3.061668689434345
tp4443
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p4444
(F-4.680963134765625
F-3.4440782987154446
tp4445
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4446
(F-3.2711991964921654
F-3.090879880464994
tp4447
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4448
(F-3.795008595784505
F-3.1578345665564904
tp4449
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p4450
(F-2.5534017069356425
F-3.0303192138671875
tp4451
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4452
(F-3.238463421257175
F-3.021711202768179
tp4453
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4454
(F-3.0399659827120287
F-3.0867112966684194
tp4455
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4456
(F-3.994911844416182
F-3.136188213641827
tp4457
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4458
(F-3.0422168567868098
F-3.117024641770583
tp4459
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p4460
(F-1.6155443512991574
F-3.0250610938439
tp4461
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4462
(F-3.2044835389760147
F-3.1034795320951023
tp4463
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4464
(F-2.7184916375910193
F-3.202427790715144
tp4465
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4466
(F-3.1076898089909957
F-3.069958026592548
tp4467
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4468
(F-3.0826136702198093
F-3.1905364990234375
tp4469
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4470
(F-3.4979309404968584
F-3.2019574091984677
tp4471
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4472
(F-3.91428005105198
F-3.17100583589994
tp4473
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4474
(F-3.3274024281790346
F-3.1934256920447717
tp4475
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4476
(F-3.0187998670212766
F-3.1585282545823317
tp4477
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4478
(F-3.5764854832699426
F-3.0841316810021033
tp4479
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4480
(F-3.4003832184866574
F-3.1647244966947117
tp4481
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3'
p4482
(F-5.684823354085286
F-3.5021092341496396
tp4483
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4484
(F-3.570851961771647
F-3.297528780423678
tp4485
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4486
(F-3.3286668297654627
F-3.188534369835487
tp4487
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4488
(F-3.3589031885540677
F-3.066531254695012
tp4489
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4490
(F-3.404518890380859
F-3.18525637113131
tp4491
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4492
(F-2.5916777862899605
F-3.219043731689453
tp4493
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4494
(F-2.7702534993489585
F-3.228585169865535
tp4495
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4496
(F-3.284907939271157
F-3.1787484975961537
tp4497
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4498
(F-2.481287990859633
F-3.0532716604379506
tp4499
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4500
(F-3.855805541113984
F-3.161993173452524
tp4501
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4502
(F-1.5022572236902574
F-3.0218429565429688
tp4503
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4504
(F-2.8762186854338845
F-3.14779545710637
tp4505
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4506
(F-3.256022270152111
F-3.160180898813101
tp4507
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4508
(F-2.8240713801408677
F-3.0947027940016527
tp4509
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4510
(F-1.9606995814054915
F-3.0158932025615988
tp4511
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p4512
(F-2.954684398213371
F-3.4401324345515323
tp4513
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4514
(F-3.115937533443921
F-3.1133372967059794
tp4515
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4516
(F-3.807443986859238
F-3.1757451570951023
tp4517
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4518
(F-3.74611870147897
F-3.065739264855018
tp4519
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4520
(F-3.244720809761135
F-3.0654420119065504
tp4521
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p4522
(F-2.0962123704993205
F-3.298990689791166
tp4523
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4524
(F-3.221083462768917
F-3.1115587674654446
tp4525
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4526
(F-3.7300272842461917
F-3.070862109844501
tp4527
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4528
(F-2.2485501078151215
F-3.1306727482722354
tp4529
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4530
(F-4.330446148862933
F-3.29733892587515
tp4531
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4532
(F-3.428246726452465
F-3.161446497990535
tp4533
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4534
(F-3.1839218651688337
F-3.19760748056265
tp4535
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4536
(F-2.572176305259146
F-2.997518099271334
tp4537
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4538
(F-3.614598306377282
F-3.26216066800631
tp4539
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p4540
(F-2.7834305536179316
F-2.9003976675180287
tp4541
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4542
(F-3.120721197747565
F-3.196679922250601
tp4543
sS"print 'this proc results:'"
p4544
(F-3.2726995944976807
F-3.2953036381648135
tp4545
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4546
(F-3.159148746066623
F-3.189771505502554
tp4547
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4548
(F-2.906888386849581
F-2.9986900916466346
tp4549
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4550
(F-3.636986926593612
F-3.2963027954101562
tp4551
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4552
(F-3.1785112268784466
F-3.178529299222506
tp4553
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4554
(F-4.143341500418527
F-3.063449272742638
tp4555
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4556
(F-3.250779724121094
F-3.270131331223708
tp4557
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4558
(F-4.157977470984826
F-3.146600576547476
tp4559
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4560
(F-3.097192721309034
F-3.1170266958383412
tp4561
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4562
(F-3.306088772506925
F-3.0902962317833533
tp4563
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4564
(F-3.2782800418814433
F-3.1983416630671573
tp4565
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4566
(F-3.350341796875
F-3.1470386798565206
tp4567
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4568
(F-3.674103515625
F-3.1358698331392727
tp4569
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4570
(F-3.1125040353822313
F-3.1025722210223856
tp4571
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4572
(F-2.6575259872482904
F-3.079973954420823
tp4573
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4574
(F-3.8499915951588113
F-3.08681634756235
tp4575
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4576
(F-2.735076744518979
F-3.047628255990835
tp4577
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p4578
(F-2.586770509418688
F-3.430789067195012
tp4579
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4580
(F-3.447649040478188
F-3.161134279691256
tp4581
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4582
(F-3.759025736058012
F-3.3140264657827525
tp4583
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4584
(F-3.6235490629944622
F-3.257581270658053
tp4585
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4586
(F-2.989617988500702
F-3.0504238422100363
tp4587
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p4588
(F-2.9679361979166665
F-3.0204591017503004
tp4589
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4590
(F-2.7139350043402777
F-3.030779618483323
tp4591
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4592
(F-3.339296354280485
F-3.1598314138559194
tp4593
sS'x = winmem()'
p4594
(F-2.7193080357142856
F-3.2398417546198917
tp4595
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4596
(F-3.7873777984290995
F-3.1912190363957333
tp4597
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4598
(F-3.462252690241887
F-3.106129866379958
tp4599
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4600
(F-2.6366322166041325
F-3.089506296011118
tp4601
sS'break\nreturn this_proc_dict'
p4602
(F-5.638101959228516
F-3.3689830486591044
tp4603
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4604
(F-2.9607667086417213
F-3.0420467670147238
tp4605
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4606
(F-2.741527180095295
F-3.0268431443434496
tp4607
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4608
(F-2.9096738462094907
F-3.172710125262921
tp4609
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4610
(F-3.6590476036071777
F-3.169433300311749
tp4611
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4612
(F-3.926468666153725
F-3.173583984375
tp4613
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4614
(F-3.9991791823814653
F-3.204936981201172
tp4615
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4616
(F-3.6230778731699065
F-3.082542712871845
tp4617
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4618
(F-2.6686469528275696
F-3.209058028001052
tp4619
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4620
(F-2.5193132411933945
F-3.2942818861741285
tp4621
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4622
(F-3.7594253593205575
F-3.2240550701434794
tp4623
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4624
(F-2.638506721047794
F-3.091938312237079
tp4625
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4626
(F-3.7125169542100696
F-2.953813699575571
tp4627
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4628
(F-2.74432373046875
F-3.0551608158991885
tp4629
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4630
(F-4.33299320302111
F-3.4082201444185696
tp4631
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4632
(F-3.6584364947150734
F-3.2517934945913463
tp4633
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4634
(F-2.43482507776331
F-3.0920210618239183
tp4635
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4636
(F-3.2965910313493114
F-3.172572209284856
tp4637
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4638
(F-3.863124302455357
F-3.3265416071965146
tp4639
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4640
(F-2.608559767405192
F-3.2078561049241285
tp4641
sS'print psutil.cpu_percent()'
p4642
(F-3.4859771728515625
F-2.9146837087777944
tp4643
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4644
(F-2.5020314750941934
F-3.0310211181640625
tp4645
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4646
(F-3.0994086536934704
F-3.301362844613882
tp4647
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4648
(F-3.2641544931942654
F-3.095916454608624
tp4649
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4650
(F-2.5126139322916665
F-3.0399263822115383
tp4651
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p4652
(F-3.5706717751242896
F-3.051942385160006
tp4653
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4654
(F-3.145265760530537
F-3.1017869802621694
tp4655
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4656
(F-3.139504226983762
F-3.1886455829326925
tp4657
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4658
(F-3.041420888092558
F-3.110250326303335
tp4659
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4660
(F-3.6348947378305287
F-3.299809382512019
tp4661
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4662
(F-3.9868917754202178
F-3.2916397681603065
tp4663
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4664
(F-3.732442292454404
F-3.0696581326998196
tp4665
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4666
(F-3.1653228304279386
F-3.0706575833834133
tp4667
sS'found_flag = True'
p4668
(F-3.2121034349714006
F-3.3647149892953725
tp4669
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4670
(F-3.0710703125
F-3.213713132418119
tp4671
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4672
(F-3.139296642841737
F-3.2031643207256613
tp4673
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4674
(F-3.1204774952099523
F-3.0653709998497596
tp4675
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4676
(F-3.371500860784472
F-3.1536404536320615
tp4677
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4678
(F-3.6591804034549122
F-3.160950880784255
tp4679
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4680
(F-2.927556355794271
F-3.3561471792367787
tp4681
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4682
(F-2.369278971354167
F-2.984571310190054
tp4683
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4684
(F-3.855373328840229
F-3.2604305560772238
tp4685
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4686
(F-3.129956764627928
F-3.108793698824369
tp4687
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4688
(F-4.353724592823093
F-3.3909964928260217
tp4689
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4690
(F-2.594090444599083
F-3.033946697528546
tp4691
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4692
(F-3.8064713911576704
F-3.022104703463041
tp4693
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4694
(F-3.2883171833736795
F-3.4570770263671875
tp4695
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4696
(F-4.013284355931028
F-3.170315375694862
tp4697
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4698
(F-2.254637637380826
F-2.9928219134990988
tp4699
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4700
(F-2.964155425295305
F-3.0461202768179088
tp4701
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p4702
(F-3.194267077323718
F-3.100193610558143
tp4703
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p4704
(F-3.2121826171875
F-3.0879540076622596
tp4705
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p4706
(F-2.919471060875619
F-3.4094971876878004
tp4707
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4708
(F-3.233010791596912
F-3.1038507314828725
tp4709
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4710
(F-3.6986058285361842
F-3.074677980863131
tp4711
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4712
(F-2.5490125450721153
F-3.0135110708383412
tp4713
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4714
(F-3.916776985957705
F-2.97465573824369
tp4715
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4716
(F-2.615675586765095
F-3.1121644240159254
tp4717
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4718
(F-2.841422859055307
F-3.0404193584735575
tp4719
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4720
(F-2.487942165798611
F-3.0292684114896336
tp4721
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4722
(F-2.9960204655736375
F-3.1762416546161356
tp4723
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4724
(F-3.167154343608189
F-3.0969214806189904
tp4725
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4726
(F-3.348653350396179
F-3.1800064673790565
tp4727
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4728
(F-3.384327063399754
F-3.242044595571665
tp4729
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4730
(F-3.7356428235306023
F-3.366549858680138
tp4731
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p4732
(F-2.9071690486027646
F-3.4065325810359073
tp4733
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4734
(F-2.9827117223173514
F-3.0831407400277944
tp4735
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4736
(F-3.0266175747934434
F-3.097243382380559
tp4737
sS'import win32com.client\nfrom ctypes import *'
p4738
(F-3.028961875221946
F-3.0551690321702223
tp4739
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4740
(F-3.779910113360431
F-3.3341798048753004
tp4741
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4742
(F-3.3700360107421874
F-3.5107862032376804
tp4743
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p4744
(F-2.356602907180786
F-3.0345191955566406
tp4745
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4746
(F-3.3029135731408665
F-3.186264918400691
tp4747
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4748
(F-3.292822432844606
F-3.1088338998647838
tp4749
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4750
(F-5.498676973230698
F-3.0161649263822117
tp4751
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4752
(F-4.073080825805664
F-3.0923423767089844
tp4753
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4754
(F-3.2639693734031052
F-3.200072948749249
tp4755
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4756
(F-3.642638089364035
F-3.310383136455829
tp4757
sS'class process_stats:\n    pass'
p4758
(F-3.313321893865412
F-3.3248766385591946
tp4759
sS'return x\n\n\nclass process_stats:\n    pass'
p4760
(F-3.716780185699463
F-3.3034312908466044
tp4761
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4762
(F-1.7762064379315043
F-2.971385955810547
tp4763
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4764
(F-2.607026541573661
F-3.0104710505558896
tp4765
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4766
(F-3.0293130376197737
F-3.1565108666053185
tp4767
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p4768
(F-2.7172051145319354
F-3.3733350313626804
tp4769
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4770
(F-3.846669158524259
F-3.1168353740985575
tp4771
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4772
(F-3.0449216238265175
F-3.1451955942007213
tp4773
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4774
(F-3.8547786365855825
F-3.2437832172100363
tp4775
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4776
(F-3.575542784573739
F-3.1013529850886417
tp4777
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4778
(F-3.2863807508680556
F-3.0963680560772238
tp4779
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4780
(F-2.6566390991210938
F-3.0300827026367188
tp4781
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4782
(F-3.1680555138221154
F-3.1044012216421275
tp4783
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4784
(F-3.4595098703151175
F-3.1648028447077823
tp4785
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4786
(F-2.7494217373814362
F-3.095154982346755
tp4787
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4788
(F-3.7953268007938914
F-3.2459129920372596
tp4789
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4790
(F-3.3524220678761694
F-3.1889114379882812
tp4791
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4792
(F-3.0604622889046715
F-3.0594814007098856
tp4793
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        pass"
p4794
(F-4.11407841862859
F-3.194888481727013
tp4795
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4796
(F-3.891169956752232
F-3.3920200054462137
tp4797
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4798
(F-2.570634876598011
F-3.045749077430138
tp4799
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p4800
(F-2.9417890223061165
F-3.3890938392052283
tp4801
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4802
(F-3.8146860223067436
F-3.146558028001052
tp4803
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4804
(F-2.6497653025501178
F-3.211976858285757
tp4805
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4806
(F-2.939800888744753
F-3.224817129281851
tp4807
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p4808
(F-3.964321560329861
F-3.103187267596905
tp4809
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p4810
(F-3.2231253599509215
F-3.5502530611478367
tp4811
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4812
(F-3.666793052596275
F-3.092620556171124
tp4813
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4814
(F-3.2968214158887985
F-3.193285428560697
tp4815
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4816
(F-2.2712325500927384
F-3.2357617891751804
tp4817
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4818
(F-2.6540304204469085
F-3.038004655104417
tp4819
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4820
(F-3.4978514844998
F-3.1273477994478664
tp4821
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4822
(F-3.4554401909353776
F-3.1157904404860277
tp4823
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4824
(F-3.434188108934494
F-3.1260701693021336
tp4825
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4826
(F-3.3954767595257676
F-3.2053739107572117
tp4827
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4828
(F-3.116541921356578
F-3.1314174945537863
tp4829
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p4830
(F-3.9796050315679508
F-2.9082662142240086
tp4831
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p4832
(F-2.852166828356291
F-3.3954623295710635
tp4833
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4834
(F-4.03656547760295
F-3.4073172349196215
tp4835
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4836
(F-3.320189838547972
F-3.1811367915226865
tp4837
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4838
(F-3.2843217329545453
F-3.4991287818321815
tp4839
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4840
(F-1.413698615097418
F-3.041391812838041
tp4841
sS'if found_flag:\n    pass'
p4842
(F-2.7530283494429155
F-3.3221746591421275
tp4843
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4844
(F-3.4732615739549013
F-3.165392655592698
tp4845
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4846
(F-2.527556413374607
F-3.018071101262019
tp4847
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4848
(F-3.230915482251814
F-3.0962442251352162
tp4849
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p4850
(F-1.7120862688337053
F-3.1524244455190806
tp4851
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4852
(F-3.7707731827445654
F-3.202586834247296
tp4853
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4854
(F-3.626386122270064
F-3.0862784752478967
tp4855
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4856
(F-3.294370339133523
F-3.1103650606595554
tp4857
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4858
(F-3.1696744202488687
F-3.077574509840745
tp4859
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4860
(F-3.795888112003642
F-3.085771707388071
tp4861
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4862
(F-3.8773783764808005
F-3.1061260516826925
tp4863
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4864
(F-3.2920130945700965
F-3.0986275306114783
tp4865
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4866
(F-2.672779873278014
F-3.075062091533954
tp4867
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p4868
(F-2.6686068216959637
F-2.947344266451322
tp4869
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4870
(F-3.137781922246369
F-3.1054942791278544
tp4871
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4872
(F-3.680551258250825
F-3.138177431546725
tp4873
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4874
(F-2.8218780388811973
F-3.2429583622859073
tp4875
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4876
(F-3.1079696527048317
F-3.054902883676382
tp4877
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4878
(F-2.946950351490694
F-3.171502920297476
tp4879
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4880
(F-3.31272998754529
F-3.2233992356520433
tp4881
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4882
(F-3.1247418307112995
F-3.070843036358173
tp4883
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4884
(F-3.928412235144413
F-3.0779888446514425
tp4885
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p4886
(F-2.3490806402162066
F-3.2825370201697717
tp4887
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4888
(F-2.8378693953804346
F-3.2505466754619894
tp4889
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4890
(F-3.7255887372778096
F-3.2757908747746396
tp4891
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4892
(F-3.9797822097252156
F-3.228639162503756
tp4893
sS"for attribute in self.supported_types[counter_type]:\n    eval_str = ('objItem.%s' % attribute)"
p4894
(F-4.040051596505301
F-3.5021705627441406
tp4895
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4896
(F-2.82984813745471
F-3.25004636324369
tp4897
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p4898
(F-2.490024967088225
F-3.196726285494291
tp4899
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4900
(F-2.5269451259826283
F-3.0058135986328125
tp4901
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4902
(F-3.098347481189587
F-3.0668170635516825
tp4903
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4904
(F-3.1236750615107547
F-3.0695169889009914
tp4905
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4906
(F-2.5978523570404954
F-3.107606741098257
tp4907
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4908
(F-2.842089717252267
F-3.2072169964130106
tp4909
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p4910
(F-4.033002068014706
F-2.993101853590745
tp4911
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4912
(F-3.7351552135539503
F-3.121893075796274
tp4913
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4914
(F-2.766048262075718
F-3.0952168978177586
tp4915
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4916
(F-4.0229848225911455
F-3.2939494206355167
tp4917
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4918
(F-2.4802473621255547
F-3.268283257117638
tp4919
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4920
(F-3.809444577258949
F-3.0682772122896633
tp4921
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4922
(F-2.6044068432127507
F-3.101729466364934
tp4923
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4924
(F-3.6913885967548077
F-3.152934734637921
tp4925
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4926
(F-3.2445044557364207
F-3.1501400287334738
tp4927
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4928
(F-3.345015703621557
F-3.1464063204251804
tp4929
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4930
(F-3.253855605664342
F-3.0629671536959133
tp4931
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4932
(F-3.193739227032593
F-3.1020672137920675
tp4933
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4934
(F-1.86512306614926
F-3.025111565223107
tp4935
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4936
(F-2.84872090757774
F-3.033480717585637
tp4937
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4938
(F-3.401662462747883
F-3.1518214299128604
tp4939
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4940
(F-3.5886019193209133
F-3.2899211003230167
tp4941
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4942
(F-2.489180428641183
F-3.174515357384315
tp4943
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4944
(F-3.7775817027289746
F-3.152038867657001
tp4945
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4946
(F-2.880654224892506
F-3.0939756540151744
tp4947
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4948
(F-3.078763075277839
F-3.1702364408052883
tp4949
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4950
(F-2.9436840597353027
F-3.10914553128756
tp4951
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4952
(F-2.5956764914772728
F-3.0295096177321215
tp4953
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4954
(F-3.3358980487046255
F-3.175760709322416
tp4955
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4956
(F-3.2483523789272515
F-3.399926992563101
tp4957
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4958
(F-3.860942258673199
F-3.047120314378005
tp4959
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4960
(F-3.740182373046875
F-3.245592557466947
tp4961
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4962
(F-3.2572638227053337
F-3.1533646216759315
tp4963
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4964
(F-2.895344649211015
F-3.0192762521597056
tp4965
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4966
(F-2.6106182391826924
F-3.1894892179048977
tp4967
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4968
(F-3.3787897629450363
F-3.146715897780198
tp4969
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4970
(F-3.367638763537906
F-3.1764373779296875
tp4971
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4972
(F-2.6360423913162747
F-3.033815237192007
tp4973
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4974
(F-4.042799147884403
F-3.4248137840857873
tp4975
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4976
(F-3.692936135074807
F-3.31069095318134
tp4977
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4978
(F-2.6936228762390795
F-3.0585159888634315
tp4979
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4980
(F-2.992424283708845
F-3.002735431377704
tp4981
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4982
(F-3.147707630926212
F-3.0735819889948917
tp4983
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4984
(F-3.5361171624599357
F-3.263528970571665
tp4985
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4986
(F-2.793038619192023
F-3.2220224233774037
tp4987
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p4988
(F-2.9277049877025463
F-2.9977138225848856
tp4989
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4990
(F-4.841007051013765
F-3.765320997971755
tp4991
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4992
(F-4.439929008483887
F-3.0340279799241285
tp4993
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4994
(F-3.3661517360179722
F-3.073607224684495
tp4995
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p4996
(F-3.1661007404327393
F-2.9938841599684496
tp4997
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4998
(F-2.580129796808416
F-2.9618914677546573
tp4999
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5000
(F-1.5083753287074078
F-3.0059180626502404
tp5001
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5002
(F-3.103832303560697
F-3.067875495323768
tp5003
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p5004
(F-3.740439675071023
F-3.312940157376803
tp5005
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5006
(F-2.0827728271484376
F-2.963423802302434
tp5007
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5008
(F-3.8420904250372026
F-3.320377936730018
tp5009
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5010
(F-3.3290547338025323
F-3.0905579787034254
tp5011
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5012
(F-3.292753917631847
F-3.1511441744290867
tp5013
sS'if (proc_name.lower() in obj_name.lower()):\n    pass'
p5014
(F-2.4628146362304686
F-3.329699296217698
tp5015
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5016
(F-2.8401134550883507
F-3.061826852651743
tp5017
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5018
(F-3.655278454088185
F-3.0891776451697717
tp5019
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5020
(F-3.746196746826172
F-3.154785449688251
tp5021
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5022
(F-3.087047110358588
F-3.1135955223670373
tp5023
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5024
(F-3.0261201249792222
F-3.1032926119290867
tp5025
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5026
(F-2.6114854144782913
F-3.0669546860914965
tp5027
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5028
(F-3.3434275545815164
F-3.14618888268104
tp5029
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5030
(F-2.5773362519125556
F-3.037051567664513
tp5031
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5032
(F-3.1950125142830568
F-3.1557711087740383
tp5033
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5034
(F-3.8317222595214844
F-3.1732013408954325
tp5035
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5036
(F-3.796510558197464
F-3.0894170907827525
tp5037
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5038
(F-3.1619476040083585
F-3.071148212139423
tp5039
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p5040
(F-2.6068593660990396
F-2.897062741793119
tp5041
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5042
(F-3.2934044946598102
F-3.080287053034856
tp5043
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5044
(F-3.2641295417906746
F-3.223675067608173
tp5045
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5046
(F-3.2948134649367558
F-3.2260501568134012
tp5047
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5048
(F-3.783841913396662
F-3.0821495056152344
tp5049
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5050
(F-3.0631203651428223
F-3.065840794489934
tp5051
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5052
(F-3.3474329506478657
F-3.2052706204927883
tp5053
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5054
(F-3.247785441080729
F-3.1912527817946215
tp5055
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5056
(F-3.725925661482901
F-3.1248509333683896
tp5057
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5058
(F-3.876056162516276
F-3.3597371028019833
tp5059
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'"
p5060
(F-5.733022169633345
F-3.4918262775127706
tp5061
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5062
(F-3.403120794216124
F-3.1119519747220554
tp5063
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p5064
(F-2.871195602416992
F-3.3926051213191104
tp5065
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p5066
(F-2.176505628482316
F-3.160257779634916
tp5067
sS'if (len(colItems) > 0):\n    pass'
p5068
(F-3.0366511625402115
F-3.488139812762921
tp5069
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5070
(F-3.280582203584559
F-3.193013704740084
tp5071
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5072
(F-3.714309360670007
F-3.088069035456731
tp5073
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5074
(F-3.662604331970215
F-3.1314541743351865
tp5075
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5076
(F-3.4311319514936196
F-3.1597067025991588
tp5077
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5078
(F-3.592949532173775
F-3.32557120689979
tp5079
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5080
(F-3.3360957642725597
F-3.1739859947791467
tp5081
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5082
(F-3.0090622811947227
F-3.0373452993539662
tp5083
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5084
(F-3.3110312633470955
F-3.1806851900540867
tp5085
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5086
(F-3.3013774702701664
F-3.195740039532001
tp5087
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5088
(F-2.52830476214172
F-2.9972528310922475
tp5089
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5090
(F-3.327601560249856
F-3.16107177734375
tp5091
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5092
(F-2.4227701822916665
F-3.1973827068622294
tp5093
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5094
(F-2.9636644635881697
F-3.1123971205491285
tp5095
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5096
(F-3.3957361883726005
F-3.1407538193922777
tp5097
sS'memoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5098
(F-4.9219522890837295
F-3.212189014141376
tp5099
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5100
(F-3.06110005133708
F-3.188586014967698
tp5101
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5102
(F-2.5893861486556684
F-3.21014404296875
tp5103
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5104
(F-3.1482524965476677
F-3.0517933185283956
tp5105
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5106
(F-3.725384067177387
F-3.0662210904634914
tp5107
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5108
(F-3.5657184307391825
F-3.1961505596454325
tp5109
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5110
(F-3.028362658090203
F-3.099084707406851
tp5111
sS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5112
(F-3.098339683131168
F-3.464182633620042
tp5113
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5114
(F-2.1762165007044056
F-3.259456047644982
tp5115
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p5116
(F-2.2126809528895786
F-3.0110555795522838
tp5117
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5118
(F-3.706254691131844
F-3.1393905052771935
tp5119
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5120
(F-3.2254129129129128
F-3.0895250760591946
tp5121
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5122
(F-2.851243605307483
F-3.1595303462101865
tp5123
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5124
(F-2.755035400390625
F-3.2233285170335035
tp5125
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5126
(F-3.1952353084788605
F-3.1078235919658956
tp5127
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5128
(F-2.4199224935995565
F-3.046363537128155
tp5129
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5130
(F-3.670942607678865
F-3.082519237811749
tp5131
sS'pythoncom.CoInitialize()\nx = winmem()'
p5132
(F-3.2733350481305803
F-3.2122879028320312
tp5133
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5134
(F-3.3390552355520247
F-3.1884642380934496
tp5135
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5136
(F-2.6354163188879984
F-3.0495725778432994
tp5137
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5138
(F-3.422428591242096
F-3.169923048753005
tp5139
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5140
(F-3.682404176553546
F-3.0831841688889723
tp5141
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5142
(F-2.8462963008401383
F-3.033778557410607
tp5143
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5144
(F-3.1186066977998133
F-3.3962070758526144
tp5145
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5146
(F-3.286023175274884
F-3.3939619797926683
tp5147
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5148
(F-2.6865676467483106
F-2.9808405362642727
tp5149
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5150
(F-3.30436767578125
F-3.015994145320012
tp5151
sS'import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p5152
(F-3.6885716029575892
F-2.96308341393104
tp5153
sS'perf_object_list = self.supported_types.keys()'
p5154
(F-3.5401840209960938
F-3.4834544842059794
tp5155
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5156
(F-2.350231464092548
F-3.191986083984375
tp5157
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5158
(F-3.1306713015534156
F-3.0784483689528246
tp5159
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5160
(F-3.7748081636744617
F-3.2014835064227762
tp5161
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5162
(F-3.9008129031159156
F-3.0819452725923977
tp5163
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5164
(F-3.5281473795572915
F-3.2979974013108473
tp5165
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5166
(F-3.157345711471688
F-3.0947796748234677
tp5167
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5168
(F-3.41128227927468
F-3.3007968022273135
tp5169
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5170
(F-3.458888356278582
F-3.4147538405198317
tp5171
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5172
(F-3.273080045160865
F-3.0701428926908054
tp5173
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5174
(F-3.743528656612169
F-3.0751463083120494
tp5175
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5176
(F-3.73496516483767
F-3.1555853623610277
tp5177
sS'print result_dict'
p5178
(F-4.9768327077229815
F-3.508329538198618
tp5179
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5180
(F-2.5524433315200294
F-3.040212191068209
tp5181
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5182
(F-3.286771107868976
F-3.17558347261869
tp5183
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5184
(F-3.487176207102597
F-3.2205208998460035
tp5185
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5186
(F-2.761824758429276
F-3.0530771108774037
tp5187
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5188
(F-3.1891955659589692
F-3.1091458247258115
tp5189
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5190
(F-2.6299007327057593
F-3.058026533860427
tp5191
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5192
(F-2.4632758851263934
F-2.997078822209285
tp5193
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5194
(F-2.490248320118481
F-3.02021730863131
tp5195
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5196
(F-3.706344424977022
F-3.38310300386869
tp5197
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5198
(F-3.325083554610756
F-3.1537701533390927
tp5199
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5200
(F-3.124163922774106
F-3.0786056518554688
tp5201
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5202
(F-3.341836368336397
F-3.1932464012732873
tp5203
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5204
(F-3.156026405863243
F-3.120266547569862
tp5205
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p5206
(F-1.1305533272879464
F-3.3812825129582333
tp5207
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5208
(F-2.62846816432932
F-3.2730636596679688
tp5209
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5210
(F-3.6052751138176715
F-3.1582981989933896
tp5211
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5212
(F-1.959130568731399
F-3.1857132544884315
tp5213
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5214
(F-3.665049904271176
F-3.0550528306227465
tp5215
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5216
(F-2.956602292640187
F-3.0569522564227762
tp5217
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p5218
(F-4.292661090229833
F-3.39516595693735
tp5219
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5220
(F-2.9855363891336766
F-3.0562092707707333
tp5221
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5222
(F-2.2987515888516863
F-3.0368672884427586
tp5223
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p5224
(F-2.905033754498771
F-3.423111548790565
tp5225
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5226
(F-3.78129636324369
F-3.101382622352013
tp5227
sS"'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5228
(F-4.705976486206055
F-3.3954752408541164
tp5229
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5230
(F-3.138648101006554
F-3.091866419865535
tp5231
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5232
(F-3.1429038545005343
F-3.1021749056302586
tp5233
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5234
(F-3.751187703255831
F-3.1897251422588644
tp5235
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5236
(F-3.2025798992351726
F-3.077308361346905
tp5237
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5238
(F-3.033449879550321
F-3.0923435504619894
tp5239
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5240
(F-3.4524275887308797
F-3.154361137977013
tp5241
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5242
(F-2.9774107701570083
F-3.0833804790790262
tp5243
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5244
(F-2.825890080845771
F-3.0366090627817006
tp5245
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5246
(F-2.699021254128557
F-3.102056650015024
tp5247
sS'from ctypes import *\nfrom ctypes.wintypes import *'
p5248
(F-2.9113443814791164
F-3.0158524146446815
tp5249
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5250
(F-3.5226729068850062
F-3.2100137563852162
tp5251
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5252
(F-3.3397775423728815
F-3.1752821115347056
tp5253
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p5254
(F-4.040031881893382
F-3.1729645362267127
tp5255
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5256
(F-3.5893203735351564
F-3.1982644888070912
tp5257
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]'
p5258
(F-2.1733282840613164
F-3.0530630258413463
tp5259
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5260
(F-3.3994928950273926
F-3.145643087533804
tp5261
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5262
(F-3.1119988952020203
F-3.371471405029297
tp5263
sS'print psutil.virtual_memory()'
p5264
(F-3.637440490722656
F-2.9741891714242787
tp5265
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5266
(F-4.235865372877854
F-3.290599529559796
tp5267
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5268
(F-3.7365031088552167
F-2.968011709359976
tp5269
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5270
(F-2.96521860540169
F-3.0894302955040565
tp5271
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5272
(F-3.3183294853555814
F-3.1525083688589244
tp5273
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5274
(F-3.0477427345290926
F-3.0521800701434794
tp5275
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5276
(F-3.051065270169323
F-3.067698258620042
tp5277
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5278
(F-2.5364240481529707
F-3.0949378380408654
tp5279
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())\nprint(psutil.virtual_memory())'
p5280
(F-2.349995422363281
F-2.9318662790151744
tp5281
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5282
(F-3.451964994820442
F-3.141673748309796
tp5283
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5284
(F-3.234515630710892
F-3.0580379779522238
tp5285
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5286
(F-3.6462395709493887
F-3.0605398324819713
tp5287
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5288
(F-3.9185488300938762
F-3.2092214731069713
tp5289
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p5290
(F-5.282530159785829
F-3.4714378943810096
tp5291
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p5292
(F-2.329022637728987
F-3.3510674696702223
tp5293
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5294
(F-3.116002550571382
F-3.0656747084397535
tp5295
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5296
(F-3.4095401340060763
F-3.0939149122971754
tp5297
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5298
(F-3.7823725796202154
F-3.062488555908203
tp5299
sS'from ctypes.wintypes import *\nimport pythoncom'
p5300
(F-4.302467346191406
F-3.0046759385329027
tp5301
sS'break\nif found_flag:\n    pass'
p5302
(F-3.759630643404447
F-3.28537104679988
tp5303
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5304
(F-3.2056907582505842
F-3.1896966787484975
tp5305
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5306
(F-3.32878288776289
F-3.094991243802584
tp5307
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5308
(F-3.151611328125
F-3.069595923790565
tp5309
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5310
(F-3.787272341965419
F-3.126086895282452
tp5311
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5312
(F-3.150281778971354
F-3.0693881695087137
tp5313
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5314
(F-3.705971651299055
F-3.37681638277494
tp5315
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5316
(F-3.356752710117773
F-3.18843019925631
tp5317
sS'pid = os.getpid()'
p5318
(F-2.5702116224500866
F-2.9383612412672777
tp5319
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5320
(F-3.6628626655129826
F-3.2770957946777344
tp5321
sS'continue'
p5322
(F-8.009137471516928
F-3.439759474534255
tp5323
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5324
(F-3.0297183202317925
F-3.106060321514423
tp5325
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5326
(F-3.8382130158253207
F-3.1928429236778846
tp5327
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5328
(F-3.9467499831627153
F-3.4522972106933594
tp5329
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p5330
(F-2.4193895128038196
F-3.4056305518517127
tp5331
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5332
(F-3.312188156512605
F-3.186755840594952
tp5333
sS'import pythoncom'
p5334
(F-5.280918598175049
F-2.997679490309495
tp5335
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5336
(F-3.7042130319695725
F-3.260204021747296
tp5337
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5338
(F-2.6890206808572286
F-3.026028559758113
tp5339
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5340
(F-3.330912360978439
F-3.186510819655198
tp5341
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5342
(F-3.102574484688895
F-3.150602487417368
tp5343
sS'self.filter_list = filter_list'
p5344
(F-4.004157673228871
F-3.854670891394982
tp5345
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5346
(F-3.688391343602594
F-3.2300696739783654
tp5347
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5348
(F-3.399134004067001
F-3.1405475323016825
tp5349
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5350
(F-3.4062828487820096
F-3.2892849261944113
tp5351
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5352
(F-2.3884624774639422
F-2.9606895446777344
tp5353
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5354
(F-3.371044039439006
F-3.1577315697303185
tp5355
sS'pythoncom.CoInitialize()'
p5356
(F-2.994626522064209
F-3.2494310232309194
tp5357
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p5358
(F-4.667588370186942
F-3.2858816293569713
tp5359
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5360
(F-3.1347184910893016
F-3.230743114764874
tp5361
sS'import pythoncom\nimport pywintypes\nimport datetime'
p5362
(F-4.092776107788086
F-2.960634084848257
tp5363
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5364
(F-3.348642858186565
F-3.2022449786846456
tp5365
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5366
(F-3.4220665158249264
F-3.14958249605619
tp5367
sS'x = MEMORYSTATUS()'
p5368
(F-2.7193080357142856
F-3.2398417546198917
tp5369
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5370
(F-3.069703958802304
F-3.170958298903245
tp5371
sS"'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p5372
(F-4.705976486206055
F-3.3954752408541164
tp5373
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5374
(F-3.8803853902730854
F-3.0753326416015625
tp5375
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5376
(F-3.1529963969366426
F-3.0953313387357273
tp5377
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5378
(F-3.408805031446541
F-3.1337911165677586
tp5379
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5380
(F-2.1136720137162643
F-2.9777952340932994
tp5381
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5382
(F-3.1419713117074277
F-3.308110163762019
tp5383
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5384
(F-3.0769856770833335
F-3.1776260962853065
tp5385
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5386
(F-3.1660959847668497
F-3.111220433161809
tp5387
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5388
(F-3.6761971112977654
F-3.3655008169320912
tp5389
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5390
(F-2.6017341142819252
F-3.0731292137732873
tp5391
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5392
(F-3.8059782913427034
F-3.1925984896146336
tp5393
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5394
(F-2.3707456788816654
F-3.220316373384916
tp5395
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5396
(F-3.2636046939425998
F-3.189853081336388
tp5397
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5398
(F-2.944529456549911
F-3.1016258826622596
tp5399
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5400
(F-3.585912068684896
F-3.08681400005634
tp5401
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5402
(F-3.2764485677083335
F-3.189512692964994
tp5403
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5404
(F-3.146217705390772
F-3.0577222383939304
tp5405
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5406
(F-3.934919906536322
F-3.0824942955603967
tp5407
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5408
(F-3.104363294894586
F-3.0940883343036356
tp5409
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5410
(F-4.081527577275815
F-3.120419135460487
tp5411
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5412
(F-3.34584012477518
F-3.1560756976787863
tp5413
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5414
(F-3.2007609859542496
F-3.101773188664363
tp5415
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5416
(F-3.984565357170483
F-3.1141492403470554
tp5417
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5418
(F-2.9789030195058297
F-3.060290996844952
tp5419
sS'windll.kernel32.GlobalMemoryStatus(byref(x))'
p5420
(F-3.7661364237467447
F-3.1024395869328427
tp5421
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5422
(F-1.2372576739336993
F-3.0287405160757213
tp5423
sS'if (not self.process_name_list):\n    pass'
p5424
(F-2.591323640611437
F-3.39593505859375
tp5425
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5426
(F-2.427821533203125
F-2.975966526911809
tp5427
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5428
(F-3.8302483809621712
F-3.32101557804988
tp5429
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5430
(F-3.9006966727120536
F-2.9679732689490685
tp5431
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5432
(F-2.8227491870368877
F-3.098535391000601
tp5433
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5434
(F-3.1876506862017804
F-3.1985224210298977
tp5435
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p5436
(F-4.000557693780637
F-3.044133112980769
tp5437
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5438
(F-2.86976221188977
F-3.085566887488732
tp5439
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list"
p5440
(F-3.506839236697635
F-3.2154755225548377
tp5441
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5442
(F-3.108390671199531
F-3.0714874267578125
tp5443
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5444
(F-3.731819661458333
F-3.1418867844801683
tp5445
sS'from ctypes import *'
p5446
(F-2.9887873331705728
F-3.048815507155198
tp5447
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5448
(F-3.1556802574856824
F-3.1776897723858175
tp5449
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5450
(F-3.1122849987399195
F-3.099257542536809
tp5451
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5452
(F-1.9719193070023149
F-3.048331334040715
tp5453
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5454
(F-3.279355336384601
F-3.1520987290602465
tp5455
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5456
(F-2.566883492977061
F-3.0337659395658054
tp5457
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5458
(F-3.8050575657894736
F-3.094861837533804
tp5459
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5460
(F-3.1820829058549145
F-3.093963916485126
tp5461
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5462
(F-3.1223237635725636
F-3.0671107952411356
tp5463
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5464
(F-2.696692410321303
F-3.0836768517127404
tp5465
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5466
(F-3.322060633187342
F-3.19948489849384
tp5467
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5468
(F-3.606929170912591
F-3.175338158240685
tp5469
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5470
(F-4.335532052176339
F-2.984564267672025
tp5471
sS'print psutil.cpu_percent()\nprint psutil.virtual_memory()'
p5472
(F-3.5764963250411186
F-2.9126545832707333
tp5473
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"'
p5474
(F-4.705976486206055
F-3.3954752408541164
tp5475
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p5476
(F-3.6785878499348956
F-3.033586648794321
tp5477
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5478
(F-3.1223667689732144
F-3.4295965341421275
tp5479
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5480
(F-3.0415429789650887
F-3.064848386324369
tp5481
sS'__revision__ = 3\nimport win32com.client'
p5482
(F-4.995206197102864
F-3.3190521827110877
tp5483
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5484
(F-3.3705989373126153
F-3.1489583528958836
tp5485
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5486
(F-3.18481707179507
F-3.097615462083083
tp5487
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5488
(F-3.32094232468378
F-3.2267767099233775
tp5489
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5490
(F-2.98067467491906
F-3.1699110177847056
tp5491
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5492
(F-2.5194068618967562
F-3.0282199566180887
tp5493
sS'if (len(colItems) > 0):\n    for objItem in colItems:\n        found_flag = False'
p5494
(F-3.3620854039346018
F-3.623885228083684
tp5495
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client'
p5496
(F-5.17724118913923
F-3.35646966787485
tp5497
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5498
(F-4.113935470581055
F-3.217208275428185
tp5499
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5500
(F-3.285996791294643
F-3.200072068434495
tp5501
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5502
(F-3.176779604174546
F-3.0629395705003004
tp5503
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5504
(F-3.708156935024611
F-3.1251499469463644
tp5505
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p5506
(F-3.9927008213141026
F-3.06416262113131
tp5507
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5508
(F-3.80779797097911
F-2.9058107229379506
tp5509
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5510
(F-3.2813591925652474
F-3.1883762066180887
tp5511
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5512
(F-3.15637889661287
F-3.1042791513296275
tp5513
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5514
(F-3.7668308681911893
F-3.07239737877479
tp5515
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5516
(F-3.279728259070445
F-3.1200364919809194
tp5517
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5518
(F-2.733840981811208
F-3.031934004563552
tp5519
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5520
(F-1.7929238029148267
F-3.026213132418119
tp5521
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p5522
(F-2.881854248046875
F-3.4318114060621996
tp5523
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p5524
(F-3.9530789204780628
F-3.1599517235389123
tp5525
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p5526
(F-3.6986275530876
F-3.3516305776742787
tp5527
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p5528
(F-3.3575941516507055
F-3.0572386521559496
tp5529
sS"print 'this proc results:'\nprint this_proc_results"
p5530
(F-4.088646628639915
F-3.1998807466947117
tp5531
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5532
(F-3.0804832062695664
F-3.069445389967698
tp5533
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5534
(F-2.9319251427283652
F-3.3211115323580227
tp5535
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5536
(F-2.154329687132871
F-3.1235738900991588
tp5537
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5538
(F-3.813344642993582
F-3.133541694054237
tp5539
sS'this_proc_dict[attribute] = eval(eval_str)'
p5540
(F-4.6386566162109375
F-3.5398483276367188
tp5541
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5542
(F-3.4830996704101564
F-3.1167229872483473
tp5543
sS'proc_results_list = []'
p5544
(F-3.960772705078125
F-3.4437470069298377
tp5545
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5546
(F-3.1440433490313473
F-3.0605013920710635
tp5547
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True'
p5548
(F-2.9941979685137348
F-3.423002389761118
tp5549
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5550
(F-2.883045570523131
F-3.033540578988882
tp5551
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5552
(F-3.49051024421813
F-3.298657637376052
tp5553
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5554
(F-4.235237545437283
F-3.3176046518179088
tp5555
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5556
(F-3.713235319947167
F-3.155462411733774
tp5557
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5558
(F-3.107843944967425
F-3.071095980130709
tp5559
sS'proc_results = stats_processor.get_stats()'
p5560
(F-3.820545705159505
F-3.242706592266376
tp5561
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5562
(F-3.3893965934086774
F-3.2010621290940504
tp5563
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5564
(F-3.175760036561547
F-3.0773280217097354
tp5565
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5566
(F-3.8214494185014205
F-3.1713022085336537
tp5567
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5568
(F-3.1552295315650203
F-3.1938435481144833
tp5569
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5570
(F-3.7228293942414687
F-3.227534660926232
tp5571
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5572
(F-2.9535439980996623
F-3.062100337101863
tp5573
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5574
(F-3.578153325707873
F-3.087463085467999
tp5575
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5576
(F-2.0209222521100725
F-3.1450846745417667
tp5577
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5578
(F-3.2008701200682155
F-3.0709903423602762
tp5579
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5580
(F-2.8739001762576217
F-3.0515723595252404
tp5581
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5582
(F-3.665837476701301
F-3.1071900587815504
tp5583
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5584
(F-3.1427013713270715
F-3.0767252995417667
tp5585
sS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5586
(F-3.3035500049591064
F-3.4426175631009617
tp5587
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5588
(F-3.1305851973886565
F-3.1091666588416467
tp5589
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5590
(F-3.287835338128307
F-3.1902459951547475
tp5591
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5592
(F-2.2640702620796533
F-2.966260469876803
tp5593
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5594
(F-2.040168081011091
F-3.0548306978665867
tp5595
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p5596
(F-3.977183532714844
F-3.0581609285794773
tp5597
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5598
(F-3.383493817484575
F-3.1919326782226562
tp5599
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5600
(F-2.2862185270889945
F-3.007806631234976
tp5601
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5602
(F-3.9634832566784275
F-3.092122591458834
tp5603
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5604
(F-3.087066411972046
F-3.1703356229341946
tp5605
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5606
(F-2.918589772044362
F-3.1776956411508412
tp5607
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5608
(F-3.2749235280716573
F-3.0997290978064904
tp5609
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5610
(F-3.04330629872576
F-3.0951083256648135
tp5611
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5612
(F-3.938569810655382
F-3.1173280569223256
tp5613
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5614
(F-3.2854829126474807
F-3.1915655869704027
tp5615
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5616
(F-3.3853622657665308
F-3.1778382521409254
tp5617
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5618
(F-3.8816922944167565
F-3.0480948228102465
tp5619
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p5620
(F-4.142599972811612
F-3.0758297259990988
tp5621
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5622
(F-2.5069444886247965
F-3.0834746727576623
tp5623
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    pass'
p5624
(F-2.0486407193270595
F-3.0363211998572717
tp5625
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5626
(F-3.1596319580078127
F-3.5174889197716346
tp5627
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5628
(F-3.519389446516682
F-3.300663581261268
tp5629
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5630
(F-4.011729705028045
F-3.1686985309307394
tp5631
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5632
(F-2.589899485696576
F-3.269060868483323
tp5633
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5634
(F-2.7161357157939188
F-3.0538406372070312
tp5635
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5636
(F-2.797651871390965
F-3.0179801354041467
tp5637
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5638
(F-3.1249895035081607
F-3.054803701547476
tp5639
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5640
(F-3.2082575817273056
F-3.2054883516751804
tp5641
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5642
(F-3.04716722138074
F-3.045703887939453
tp5643
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5644
(F-3.126728653511732
F-3.0516366225022535
tp5645
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5646
(F-4.010013233531605
F-3.163053659292368
tp5647
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5648
(F-3.1094775224260007
F-3.0688435481144833
tp5649
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5650
(F-3.1277401194852943
F-3.055311056283804
tp5651
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5652
(F-3.0278573330965908
F-3.1700515747070312
tp5653
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5654
(F-2.65621811084533
F-3.0033660301795373
tp5655
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5656
(F-3.1275460970603812
F-3.0702623220590444
tp5657
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5658
(F-2.5932760378482405
F-3.063563420222356
tp5659
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5660
(F-1.44583376716165
F-3.008483593280499
tp5661
sS'proc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5662
(F-3.115554527000145
F-3.4640570420485277
tp5663
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5664
(F-3.3557131218187735
F-3.1410868718073917
tp5665
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5666
(F-2.5298199501766523
F-3.199910970834585
tp5667
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p5668
(F-2.3110568806276484
F-3.4757080078125
tp5669
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5670
(F-3.3897936796722115
F-3.1377029418945312
tp5671
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5672
(F-3.7575668334960937
F-3.256548074575571
tp5673
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5674
(F-3.093512748704806
F-3.0671169574444113
tp5675
sS"_fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5676
(F-1.5766372680664062
F-3.2620010375976562
tp5677
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5678
(F-2.8336166305158605
F-3.086055168738732
tp5679
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5680
(F-3.1383523030123053
F-3.1206019474909854
tp5681
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5682
(F-3.6745262145996094
F-3.0490458561823917
tp5683
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5684
(F-2.9419777393341064
F-3.1652579674353967
tp5685
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5686
(F-2.748055190416383
F-3.092190375694862
tp5687
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5688
(F-3.129330324187992
F-3.1115986750676083
tp5689
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5690
(F-3.1378760506692664
F-3.113054422231821
tp5691
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5692
(F-1.6963882446289062
F-2.980284470778245
tp5693
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p5694
(F-3.834318425105168
F-3.1504889268141527
tp5695
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5696
(F-1.3573835324018428
F-3.0368191645695615
tp5697
sS'def get_sys_stats():\n    pass'
p5698
(F-2.403374989827474
F-3.065930880033053
tp5699
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5700
(F-2.846967922911352
F-3.245775369497446
tp5701
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5702
(F-3.863515696806066
F-3.1134314903846154
tp5703
sS'import psutil\nprint psutil.cpu_percent()\nprint psutil.virtual_memory()'
p5704
(F-3.0006159002130683
F-2.8846080486591044
tp5705
sS'this_proc_dict = {}'
p5706
(F-4.376910781860351
F-3.5007664607121396
tp5707
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5708
(F-3.3322000308912627
F-3.19483390221229
tp5709
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5710
(F-4.2145479090073525
F-3.0852989783653846
tp5711
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5712
(F-1.6432454962479441
F-3.1542220482459435
tp5713
sS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5714
(F-3.2368265787760415
F-3.411937420184796
tp5715
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5716
(F-2.4235256572632253
F-3.0786983783428488
tp5717
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5718
(F-1.7707491025819884
F-2.9968329209547777
tp5719
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5720
(F-3.1256260342068143
F-3.068314185509315
tp5721
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5722
(F-2.7905955595128678
F-2.9769163865309496
tp5723
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5724
(F-2.772434779575893
F-3.046959216778095
tp5725
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5726
(F-3.901358864524148
F-3.2548531752366285
tp5727
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5728
(F-3.704728890728477
F-3.073595193716196
tp5729
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5730
(F-2.575263418802401
F-2.9750735943134012
tp5731
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5732
(F-3.302271295362903
F-3.1832140409029446
tp5733
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5734
(F-3.547276423527644
F-3.253284454345703
tp5735
sS'return this_proc_dict'
p5736
(F-4.543137550354004
F-3.416136521559495
tp5737
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5738
(F-3.231044836211623
F-3.0970978370079627
tp5739
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p5740
(F-4.223550290477519
F-3.5918731689453125
tp5741
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5742
(F-2.9390331904093423
F-2.989819746751052
tp5743
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5744
(F-3.2837245904126213
F-3.0694629962627706
tp5745
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5746
(F-3.6693299916397604
F-3.2752447861891527
tp5747
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5748
(F-3.649774678548177
F-3.312470949613131
tp5749
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5750
(F-4.562522888183594
F-3.44853767981896
tp5751
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5752
(F-3.340198599414908
F-3.1865985576923075
tp5753
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5754
(F-3.935202537933526
F-3.134338085467999
tp5755
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5756
(F-3.37055366769488
F-3.189488044151893
tp5757
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5758
(F-2.61906220192133
F-3.263042156512921
tp5759
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5760
(F-3.5845067479588963
F-3.217210916372446
tp5761
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5762
(F-3.7141053734756095
F-3.1329410259540262
tp5763
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5764
(F-3.096080499425323
F-3.097330240102915
tp5765
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p5766
(F-3.647943284776476
F-3.0330162048339844
tp5767
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5768
(F-2.5099260245573807
F-3.0221372751089244
tp5769
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p5770
(F-3.8062847222222222
F-3.145173879770132
tp5771
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5772
(F-2.381784102495979
F-3.247577373798077
tp5773
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5774
(F-2.4463875325520834
F-3.3058430598332333
tp5775
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5776
(F-3.26898193359375
F-3.182965498704177
tp5777
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5778
(F-2.6162350303248356
F-2.9759401174692006
tp5779
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5780
(F-2.8273492431640626
F-3.0894191448505106
tp5781
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5782
(F-4.051377133969908
F-3.08718021099384
tp5783
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5784
(F-3.468494415283203
F-3.332082014817458
tp5785
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5786
(F-1.3859955027133604
F-2.9961075415978065
tp5787
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5788
(F-4.1501953125
F-3.078004103440505
tp5789
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5790
(F-4.002908494737413
F-3.3585709791917067
tp5791
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5792
(F-3.843457605084802
F-3.127118624173678
tp5793
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5794
(F-3.4796004756804435
F-3.146759033203125
tp5795
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5796
(F-3.0311881510416665
F-3.060148385854868
tp5797
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5798
(F-2.7641683999594155
F-3.0990577110877404
tp5799
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5800
(F-3.672126374421296
F-3.125333932729868
tp5801
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5802
(F-3.278926231341655
F-3.066355485182542
tp5803
sS'sys_dict = get_sys_stats()'
p5804
(F-4.20188727745643
F-3.2523243243877706
tp5805
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p5806
(F-3.053776264190674
F-3.0914779076209435
tp5807
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5808
(F-3.3205048386849216
F-3.1769321148212137
tp5809
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5810
(F-3.162818660804941
F-3.1965047396146336
tp5811
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p5812
(F-4.199583830656828
F-3.3578948974609375
tp5813
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5814
(F-3.352685546875
F-3.153065901536208
tp5815
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5816
(F-2.5814210817262575
F-3.0983795752892127
tp5817
sS'found_flag = False'
p5818
(F-3.3999151502336775
F-3.3552445631760817
tp5819
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()"
p5820
(F-3.208353788956352
F-3.1358026357797475
tp5821
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5822
(F-3.627119700113932
F-3.5616243802584133
tp5823
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5824
(F-2.5304869630466253
F-3.0346031188964844
tp5825
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5826
(F-2.8098697060032896
F-3.0762320298414965
tp5827
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5828
(F-3.186335829437756
F-3.1734950725848856
tp5829
sS'self.perf_object_list = perf_object_list'
p5830
(F-4.590986124674479
F-3.5134623600886417
tp5831
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5832
(F-2.932130080003005
F-3.0723246060884914
tp5833
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5834
(F-1.7868075900607638
F-2.9913641122671275
tp5835
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5836
(F-3.7904386849238954
F-3.090849362886869
tp5837
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5838
(F-3.1782610316476423
F-3.0707162710336537
tp5839
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5840
(F-2.4617313652931645
F-3.039652310884916
tp5841
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5842
(F-3.471284897487523
F-3.1844875629131613
tp5843
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5844
(F-1.333652843128551
F-3.113481961763822
tp5845
sS'return sys_dict'
p5846
(F-5.801507314046224
F-3.4416254483736477
tp5847
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5848
(F-2.5195524879383817
F-3.086468036358173
tp5849
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5850
(F-2.0910656936769563
F-2.98654292179988
tp5851
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5852
(F-2.5099190266927085
F-3.241863250732422
tp5853
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5854
(F-3.7835369575314406
F-3.063104482797476
tp5855
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p5856
(F-2.902355028235394
F-3.375507648174579
tp5857
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5858
(F-3.081337183551059
F-3.367030217097356
tp5859
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5860
(F-3.682260613692434
F-3.2216823284442606
tp5861
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5862
(F-3.172642557244552
F-3.1045558636005106
tp5863
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5864
(F-3.2384161180065525
F-3.10716306246244
tp5865
sS'py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5866
(F-4.691280364990234
F-2.9325121366060696
tp5867
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5868
(F-2.4972097593694396
F-3.052301260141226
tp5869
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p5870
(F-3.919027238884228
F-3.1471531207744894
tp5871
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5872
(F-3.3270534349524454
F-3.1388485248272238
tp5873
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5874
(F-3.1696384907505797
F-3.0748282212477465
tp5875
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5876
(F-3.208666729670699
F-3.1061281057504506
tp5877
sS'"process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5878
(F-4.705976486206055
F-3.3954752408541164
tp5879
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5880
(F-3.2783576117621527
F-3.354588435246394
tp5881
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p5882
(F-4.034898681640625
F-3.308940594012921
tp5883
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5884
(F-3.240771484375
F-3.1096696120042067
tp5885
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5886
(F-2.7005124499450375
F-3.2233026944673977
tp5887
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5888
(F-3.8259280195860104
F-3.069935138408954
tp5889
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5890
(F-1.9169943897994524
F-3.0148450411283054
tp5891
sS'for attribute in self.supported_types[counter_type]:\n    pass'
p5892
(F-3.4382553100585938
F-3.453735645000751
tp5893
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5894
(F-2.459258700284091
F-3.09290519127479
tp5895
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5896
(F-3.1599922311265036
F-3.236278533935547
tp5897
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5898
(F-3.8865821475074407
F-3.0353240966796875
tp5899
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5900
(F-4.021124721558626
F-3.1983695397010217
tp5901
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5902
(F-3.272730371973536
F-3.181928194486178
tp5903
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5904
(F-2.5367431640625
F-3.0194520216721754
tp5905
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5906
(F-2.936941348805147
F-3.058978740985577
tp5907
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5908
(F-3.8532612435769713
F-3.176404806283804
tp5909
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5910
(F-3.7210782679115852
F-3.131368196927584
tp5911
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5912
(F-3.3355173727294454
F-3.1867684584397535
tp5913
sS'for objItem in colItems:\n    pass'
p5914
(F-3.7004051208496094
F-3.549334012545072
tp5915
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5916
(F-3.173255791969171
F-3.1025962829589844
tp5917
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5918
(F-3.256870764476765
F-3.0595503586989183
tp5919
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5920
(F-3.1130786427973876
F-3.0989643977238583
tp5921
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5922
(F-3.9205474853515625
F-3.139864994929387
tp5923
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5924
(F-3.914871337890625
F-3.195069826566256
tp5925
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5926
(F-3.354329178972942
F-3.172485058124249
tp5927
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5928
(F-2.455463656418615
F-3.0591351435734677
tp5929
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5930
(F-2.451107490353468
F-3.1003221365121694
tp5931
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5932
(F-3.888005682762633
F-3.1032752990722656
tp5933
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p5934
(F-4.31296097604852
F-3.2334148700420675
tp5935
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5936
(F-3.3189187121035446
F-3.1949996948242188
tp5937
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5938
(F-3.755039132756295
F-3.1584669259878306
tp5939
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5940
(F-3.266475823407616
F-3.1543816786545973
tp5941
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5942
(F-3.9560918898809523
F-3.4059677124023438
tp5943
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5944
(F-3.8103925596992925
F-3.112116887019231
tp5945
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5946
(F-2.6425063091775645
F-3.22903325007512
tp5947
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5948
(F-2.016685053987323
F-3.0010845477764425
tp5949
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5950
(F-3.7214926786200944
F-3.1594317509577823
tp5951
sS'break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p5952
(F-3.534398651123047
F-3.485063993013822
tp5953
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5954
(F-3.141074722532242
F-3.0743191058819113
tp5955
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5956
(F-3.139776554639125
F-3.0765644953801083
tp5957
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5958
(F-3.7920253073522288
F-3.1799078721266527
tp5959
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5960
(F-3.219455368454392
F-3.1615797189565806
tp5961
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5962
(F-3.2732320305045324
F-3.163136995755709
tp5963
sS'from ctypes.wintypes import *'
p5964
(F-4.0003228187561035
F-3.0323445246769833
tp5965
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5966
(F-3.3352886749148833
F-3.1786854083721456
tp5967
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5968
(F-2.524342056972529
F-3.047024653508113
tp5969
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5970
(F-3.577101401232798
F-3.2525179936335635
tp5971
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5972
(F-3.317644177770322
F-3.2029336782602162
tp5973
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5974
(F-2.72658984375
F-3.0546866196852465
tp5975
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5976
(F-2.7646615164620534
F-3.0169748159555287
tp5977
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p5978
(F-4.056151028337149
F-3.37239749615009
tp5979
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5980
(F-3.476298141479492
F-3.138775165264423
tp5981
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5982
(F-3.1477360992935233
F-3.0659831120417667
tp5983
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5984
(F-1.4816765583736795
F-3.0646884624774637
tp5985
sS'class MEMORYSTATUS(Structure):\n    pass'
p5986
(F-1.7256209055582683
F-3.0563991253192606
tp5987
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5988
(F-2.9378883539244187
F-3.0428425715519833
tp5989
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5990
(F-2.971233884930174
F-3.2305914071890025
tp5991
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5992
(F-3.955599744780725
F-3.0823417076697717
tp5993
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5994
(F-3.136497697580173
F-3.1906685462364783
tp5995
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5996
(F-1.957701416015625
F-3.014418675349309
tp5997
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5998
(F-2.9363014411493764
F-3.0642195481520433
tp5999
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p6000
(F-3.309262623506434
F-3.2400823739858775
tp6001
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6002
(F-3.3708832839439653
F-3.175602839543269
tp6003
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p6004
(F-4.217546811311141
F-3.2860967195951023
tp6005
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6006
(F-2.863925855986926
F-3.05608397263747
tp6007
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p6008
(F-3.2262378833912035
F-3.097691169151893
tp6009
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p6010
(F-3.2015892969418878
F-3.1106094947228065
tp6011
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p6012
(F-3.287854300033693
F-3.1902606670673075
tp6013
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p6014
(F-2.469481387380826
F-3.0847523029033956
tp6015
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p6016
(F-3.708939049314346
F-3.083692110501803
tp6017
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p6018
(F-2.060070292154948
F-2.986970461331881
tp6019
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6020
(F-3.1797894368731425
F-3.056447542630709
tp6021
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p6022
(F-3.305459309094058
F-3.174243927001953
tp6023
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p6024
(F-3.0362046785294887
F-3.100123772254357
tp6025
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6026
(F-3.4320255799394195
F-3.132589193490835
tp6027
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p6028
(F-3.369538274569291
F-3.1739543034480167
tp6029
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p6030
(F-2.678320172189296
F-3.3078636756310096
tp6031
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6032
(F-4.011339258264612
F-3.491208003117488
tp6033
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6034
(F-3.28568115234375
F-3.083600264329177
tp6035
sS'def get_stats(self):\n    pass'
p6036
(F-1.6734602791922433
F-3.15072749211238
tp6037
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6038
(F-3.352038525194528
F-3.203424307016226
tp6039
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6040
(F-3.0329619485547736
F-3.090464078463041
tp6041
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6042
(F-4.381869506835938
F-3.6526454045222354
tp6043
sS'this_pid = os.getpid()'
p6044
(F-3.021917863325639
F-2.9322292621319113
tp6045
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p6046
(F-4.030559214510659
F-3.288713895357572
tp6047
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6048
(F-4.18041451772054
F-3.036075005164513
tp6049
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p6050
(F-3.1362956653941763
F-3.105518341064453
tp6051
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6052
(F-3.4526440850619613
F-3.1725557767427883
tp6053
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p6054
(F-3.076195982243043
F-3.069684835580679
tp6055
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6056
(F-3.659600705516582
F-3.107654864971454
tp6057
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p6058
(F-4.145348140171596
F-3.0440855759840746
tp6059
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6060
(F-4.1799700055803575
F-3.185869950514573
tp6061
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6062
(F-3.238559873764124
F-3.152305896465595
tp6063
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6064
(F-2.842910927220395
F-3.102130596454327
tp6065
sS'for objItem in colItems:\n    found_flag = False'
p6066
(F-3.831005769617417
F-3.5776132436899037
tp6067
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p6068
(F-3.6597591400146485
F-3.201719430776743
tp6069
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6070
(F-3.7800488621515678
F-3.2181898263784556
tp6071
sS'for result_dict in proc_results:\n    pass'
p6072
(F-3.068067932128906
F-3.4957560025728664
tp6073
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p6074
(F-3.1684121796579072
F-3.3783334585336537
tp6075
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6076
(F-2.8760084995003634
F-3.255673041710487
tp6077
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p6078
(F-3.9674445258246527
F-3.155657548170823
tp6079
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6080
(F-3.2773904779905916
F-3.182912092942458
tp6081
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6082
(F-2.3983104160853794
F-2.944684542142428
tp6083
sS'for result_dict in proc_results:\n    print result_dict\nimport os'
p6084
(F-3.8617161342075894
F-3.472271259014423
tp6085
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p6086
(F-3.7838805602477477
F-3.0973566495455227
tp6087
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6088
(F-3.3611671146953404
F-3.152923290546124
tp6089
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p6090
(F-2.6989461263020833
F-2.9885201087364783
tp6091
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p6092
(F-3.7074526832217263
F-3.4894497211162863
tp6093
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6094
(F-3.6293838273233443
F-3.321907923771785
tp6095
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6096
(F-2.963007363505747
F-3.0510201087364783
tp6097
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6098
(F-3.3247802734375
F-3.177183297964243
tp6099
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p6100
(F-3.1412876674107144
F-3.0746612548828125
tp6101
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p6102
(F-3.2103067324967336
F-3.184429168701172
tp6103
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p6104
(F-3.3046096229132176
F-3.2129434438852162
tp6105
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p6106
(F-3.3023734092712402
F-3.1858253479003906
tp6107
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6108
(F-3.1007989668196743
F-3.174137995793269
tp6109
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p6110
(F-3.307943905101103
F-3.1763895474947414
tp6111
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p6112
(F-3.8458425998687744
F-3.055858612060547
tp6113
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6114
(F-3.135313434365355
F-3.3530631432166467
tp6115
sS'self.process_name_list = process_name_list'
p6116
(F-3.6688466389973957
F-3.4489986713115988
tp6117
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6118
(F-2.716170666264553
F-3.2552730853740988
tp6119
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p6120
(F-3.806935530442458
F-3.1307607797475963
tp6121
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p6122
(F-3.0931048626666304
F-3.051912161020132
tp6123
sS"import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p6124
(F-3.919448254155178
F-2.9094502375676083
tp6125
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6126
(F-3.1291172737578865
F-3.1332726111778846
tp6127
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6128
(F-3.7538682162231085
F-3.0749822763296275
tp6129
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6130
(F-3.4942769883554194
F-3.212713388296274
tp6131
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    pass"
p6132
(F-4.549009252477576
F-3.112268301156851
tp6133
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p6134
(F-3.1217018410011574
F-3.3591604966383715
tp6135
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6136
(F-3.4193636291819063
F-3.1567356403057394
tp6137
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    pass'
p6138
(F-2.929017526132089
F-3.4485684908353367
tp6139
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6140
(F-3.175463001974191
F-3.0762918912447414
tp6141
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p6142
(F-3.3381315772213154
F-3.4008043729341946
tp6143
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p6144
(F-2.771549285404266
F-3.030506427471454
tp6145
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p6146
(F-3.6672540283203126
F-3.0924072265625
tp6147
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6148
(F-3.7748576462870895
F-3.0512944735013523
tp6149
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p6150
(F-3.1106771534886852
F-3.0729185251089244
tp6151
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p6152
(F-3.3131237878732436
F-3.2142730126014123
tp6153
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6154
(F-2.0388246424057903
F-2.922779376690204
tp6155
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p6156
(F-2.3289875095173462
F-2.9949428851787863
tp6157
sS'proc_results_list.append(this_proc_dict)'
p6158
(F-3.625781536102295
F-3.44422355064979
tp6159
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p6160
(F-4.125121124031008
F-3.4306006798377404
tp6161
sS"py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p6162
(F-4.485785293579101
F-2.9302341754619894
tp6163
ssI5137497
(dp6164
S"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6165
(F-1.7705458068847657
F-3.131074905395508
tp6166
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6167
(F-2.7046766094132964
F-3.133075141906738
tp6168
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')"
p6169
(F-1.7854385375976562
F-3.321394348144531
tp6170
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6171
(F-3.170807202657064
F-3.147903823852539
tp6172
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6173
(F-2.2486382026176948
F-3.121717834472656
tp6174
sS"print 'This file directory and name'"
p6175
(F-3.0588722229003906
F-3.752945327758789
tp6176
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6177
(F-2.482798963490099
F-3.1355899810791015
tp6178
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6179
(F-2.2143633442540325
F-3.147504997253418
tp6180
sS"print 'This file path, relative to os.getcwd()'"
p6181
(F-3.0588722229003906
F-3.752945327758789
tp6182
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6183
(F-2.8503489176432293
F-3.1364131927490235
tp6184
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p6185
(F-2.054781959170387
F-3.3491657257080076
tp6186
sS'import os'
p6187
(F-3.3479347229003906
F-3.32983283996582
tp6188
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6189
(F-2.574071078830295
F-3.1223722457885743
tp6190
sS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6191
(F-3.023357969341856
F-3.0620796203613283
tp6192
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6193
(F-2.2765291448225056
F-3.2381935119628906
tp6194
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6195
(F-2.691769554501488
F-3.0633350372314454
tp6196
sS'dir_path = os.path.dirname(os.path.realpath(__file__))'
p6197
(F-1.1624496294104534
F-3.0541355133056642
tp6198
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6199
(F-2.3122373510290077
F-3.475450897216797
tp6200
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6201
(F-2.9772379557291666
F-3.1341789245605467
tp6202
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6203
(F-2.6807168813852162
F-3.5250301361083984
tp6204
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6205
(F-1.89440235338713
F-3.115946388244629
tp6206
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6207
(F-2.4745749141393083
F-3.1250869750976564
tp6208
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')"
p6209
(F-1.8944302876790364
F-3.470908355712891
tp6210
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6211
(F-2.594286883318866
F-3.4290092468261717
tp6212
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6213
(F-2.3383322702327245
F-3.105364990234375
tp6214
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6215
(F-1.8735554558890206
F-3.1318004608154295
tp6216
sS"import os\nprint 'Path at terminal when executing this file'"
p6217
(F-2.2642970766339983
F-3.362441635131836
tp6218
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6219
(F-2.323813698508523
F-3.3580116271972655
tp6220
sS"print (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6221
(F-2.981597900390625
F-3.235422134399414
tp6222
sS"print (((path + ' --> ') + filename) + '\\n')"
p6223
(F-3.525972843170166
F-3.2965744018554686
tp6224
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6225
(F-2.0327449597810445
F-3.205147933959961
tp6226
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6227
(F-2.1679702758789063
F-3.336725616455078
tp6228
sS"print 'This file full path (following symlinks)'"
p6229
(F-3.0588722229003906
F-3.752945327758789
tp6230
sS"print (os.getcwd() + '\\n')"
p6231
(F-1.6845900217692058
F-3.373299407958984
tp6232
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6233
(F-2.280222256978353
F-3.058909606933594
tp6234
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6235
(F-2.4669857025146484
F-3.1299909591674804
tp6236
sS'import os\ncwd = os.getcwd()'
p6237
(F-2.014776865641276
F-3.150729751586914
tp6238
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6239
(F-2.2600500924246654
F-3.1949560165405275
tp6240
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6241
(F-2.2291370391845704
F-3.144814300537109
tp6242
sS'import os\ndir_path = os.path.dirname(os.path.realpath(__file__))'
p6243
(F-1.1081496018629808
F-3.075425148010254
tp6244
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6245
(F-2.1125211362485534
F-3.2234237670898436
tp6246
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6247
(F-2.3812139601934526
F-3.071226119995117
tp6248
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6249
(F-2.5161061604817707
F-3.0528900146484377
tp6250
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6251
(F-2.8221266004774304
F-3.0933021545410155
tp6252
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6253
(F-2.83028081258138
F-3.167497444152832
tp6254
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6255
(F-2.1729685919625417
F-3.1416299819946287
tp6256
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6257
(F-2.104551315307617
F-3.206049346923828
tp6258
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6259
(F-2.317197645032728
F-3.1320629119873047
tp6260
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6261
(F-2.5863608875493895
F-3.1162452697753906
tp6262
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6263
(F-2.4856046549479167
F-3.138566017150879
tp6264
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6265
(F-2.685202858664773
F-3.0672420501708983
tp6266
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6267
(F-2.519047328404018
F-3.056967544555664
tp6268
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6269
(F-2.462136677333287
F-3.1120330810546877
tp6270
sS'print os.path.dirname(full_path)'
p6271
(F-1.551871813260592
F-3.195257568359375
tp6272
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6273
(F-2.4466532389322917
F-3.0769458770751954
tp6274
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6275
(F-2.771021321614583
F-3.0657655715942385
tp6276
sS"print 'Path at terminal when executing this file'"
p6277
(F-3.0588722229003906
F-3.752945327758789
tp6278
sS"print (__file__ + '\\n')"
p6279
(F-2.6975549697875976
F-3.396379089355469
tp6280
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6281
(F-2.4238689101745035
F-3.136570167541504
tp6282
sS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6283
(F-2.8454338709513345
F-3.1982868194580076
tp6284
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6285
(F-2.308293660481771
F-3.204820251464844
tp6286
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6287
(F-3.044743776321411
F-3.5529251098632812
tp6288
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6289
(F-2.441991406817769
F-3.162972259521484
tp6290
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6291
(F-2.6290950775146484
F-3.0562501907348634
tp6292
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6293
(F-3.0770357572115383
F-3.1115478515625
tp6294
sS'(path, filename) = os.path.split(full_path)'
p6295
(F-2.4938903384738498
F-3.0548965454101564
tp6296
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6297
(F-3.3309449415940504
F-3.4475482940673827
tp6298
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6299
(F-2.389766534169515
F-3.400114822387695
tp6300
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6301
(F-2.4184779505575857
F-3.1513572692871095
tp6302
sS"print 'This file directory only'\nprint os.path.dirname(full_path)"
p6303
(F-1.7475779056549072
F-3.219878387451172
tp6304
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6305
(F-2.2458751781566724
F-3.112984275817871
tp6306
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6307
(F-2.1868464152018228
F-3.2156471252441405
tp6308
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6309
(F-2.221136305067274
F-3.2357025146484375
tp6310
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p6311
(F-2.399896240234375
F-3.423044204711914
tp6312
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p6313
(F-2.280718061659071
F-3.504323959350586
tp6314
sS'cwd = os.getcwd()'
p6315
(F-2.2969307369656033
F-3.1453399658203125
tp6316
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6317
(F-2.552688759251645
F-3.118611717224121
tp6318
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6319
(F-2.1352171056410847
F-3.1899213790893555
tp6320
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6321
(F-2.4938448392427883
F-3.1290136337280274
tp6322
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6323
(F-2.5006736755371093
F-3.4948429107666015
tp6324
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6325
(F-2.5000353081281794
F-3.102672004699707
tp6326
sS"print (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6327
(F-3.9917245162160775
F-3.3248992919921876
tp6328
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6329
(F-2.4345359802246094
F-3.111408233642578
tp6330
sS"print (full_path + '\\n')\nprint 'This file directory and name'"
p6331
(F-3.3770517202524037
F-3.540283966064453
tp6332
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6333
(F-2.596993653670601
F-3.133062171936035
tp6334
sS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6335
(F-3.3062799241807728
F-3.0789072036743166
tp6336
sS'full_path = os.path.realpath(__file__)'
p6337
(F-1.6594184637069702
F-3.115884780883789
tp6338
sS"print (full_path + '\\n')"
p6339
(F-2.663868713378906
F-3.4991661071777345
tp6340
sS"print 'This file directory only'"
p6341
(F-3.0588722229003906
F-3.752945327758789
tp6342
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6343
(F-2.4545269347073737
F-3.0519975662231444
tp6344
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6345
(F-2.247013176812066
F-3.0525444030761717
tp6346
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6347
(F-2.6055147298177084
F-3.080447959899902
tp6348
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6349
(F-2.4632128201998196
F-3.144901466369629
tp6350
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6351
(F-2.7457040640024037
F-3.0901012420654297
tp6352
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6353
(F-2.6247406005859375
F-3.11124267578125
tp6354
ssI930397
(dp6355
S"alist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6356
(F-4.5839848672190024
F-1.6290199973366477
tp6357
sS"alist[(-1):]\nastr = ''"
p6358
(F-5.258863176618304
F-1.598607149991122
tp6359
sS'some_list[(-2)] = 3'
p6360
(F-3.1864574138934794
F-1.5446713187477805
tp6361
sS'alist[(-1)]\nalist[(-1):]'
p6362
(F-4.27587890625
F-1.573756131258878
tp6363
sS'alist[(-1):]'
p6364
(F-4.146351623535156
F-1.5870366529984907
tp6365
sS'astr[(-1)]\nastr[(-1):]'
p6366
(F-4.480943891737196
F-1.5887419960715554
tp6367
sS'some_list = [1, 2, 3]'
p6368
(F-2.3527396275446963
F-1.534088134765625
tp6369
sS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p6370
(F-4.440093485514323
F-1.5719580216841265
tp6371
sS'alist.pop()'
p6372
(F-3.1871100834437778
F-1.6792592135342685
tp6373
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p6374
(F-4.055931309291295
F-1.4996282404119319
tp6375
sS'alist = []\nalist[(-1)]\nalist[(-1):]'
p6376
(F-3.7976316369098164
F-1.5001642053777522
tp6377
sS'alist = []\nalist[(-1)]'
p6378
(F-3.4788191659109935
F-1.5004256855357776
tp6379
sS'some_list[(-2)] = 3\nsome_list'
p6380
(F-4.2020093132467835
F-1.5490625554865056
tp6381
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''"
p6382
(F-4.332642449273004
F-1.5018424987792969
tp6383
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p6384
(F-3.0453855933212655
F-1.5279130068692295
tp6385
sS"astr = ''\nastr[(-1)]\nastr[(-1):]"
p6386
(F-4.210395812988281
F-1.732573769309304
tp6387
sS"astr = ''"
p6388
(F-3.6416759490966797
F-1.7748125249689275
tp6389
sS'some_list'
p6390
(F-5.577473831176758
F-1.7023686495694248
tp6391
sS"alist[(-1)]\nalist[(-1):]\nastr = ''"
p6392
(F-4.923684206875888
F-1.5808590975674717
tp6393
sS'alist = []'
p6394
(F-3.587862014770508
F-1.5288346030495383
tp6395
sS'astr[(-1)]'
p6396
(F-3.7019861009385853
F-1.5328960418701172
tp6397
sS"alist[(-1):]\nastr = ''\nastr[(-1)]"
p6398
(F-4.497215617786754
F-1.6055408824573865
tp6399
sS'alist[(-1)]'
p6400
(F-3.658492194281684
F-1.580784884366122
tp6401
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5'
p6402
(F-2.5393942260742186
F-1.5310396714644
tp6403
sS'some_list[(-1)] = 5'
p6404
(F-3.1491617056039662
F-1.5741058696400037
tp6405
sS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6406
(F-4.5105031331380205
F-1.5820811878551135
tp6407
sS'some_list[(-1)] = 5\nsome_list[(-2)] = 3'
p6408
(F-3.2410702514648437
F-1.5389700802889736
tp6409
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6410
(F-4.183049635453657
F-1.506539604880593
tp6411
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3'
p6412
(F-2.662517650707348
F-1.5288918235085227
tp6413
sS"astr = ''\nastr[(-1)]"
p6414
(F-3.655721517709585
F-1.727246717973189
tp6415
sS'astr[(-1):]'
p6416
(F-4.153402709960938
F-1.537282250144265
tp6417
sS'some_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p6418
(F-3.7137414340315194
F-1.5381180156360974
tp6419
ssI961632
(dp6420
S"str(10)\nint('10')"
p6421
(F-3.5086295387961646
F-1.914999008178711
tp6422
sS'str(a)'
p6423
(F-2.2013985315958657
F-2.0376309288872614
tp6424
sS'str(10)'
p6425
(F-3.232097625732422
F-2.004759046766493
tp6426
sS'str(i)'
p6427
(F-2.0059827168782554
F-2.069018257988824
tp6428
sS"int('10')"
p6429
(F-2.028977711995443
F-1.9405345916748047
tp6430
sS'a.__str__()'
p6431
(F-3.4136344061957464
F-2.2387383778889975
tp6432
ssI1712227
(dp6433
S"items.append('apple')\nitems.append('orange')"
p6434
(F-2.361109415690104
F-1.656221580505371
tp6435
sS"items = []\nitems.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6436
(F-2.0828025252730757
F-1.5776650428771972
tp6437
sS"items.append('apple')"
p6438
(F-2.2745614051818848
F-1.665481948852539
tp6439
sS'l.length'
p6440
(F-5.210651016235351
F-1.542087459564209
tp6441
sS"items.append('banana')"
p6442
(F-2.2745614051818848
F-1.665481948852539
tp6443
sS'len(items)'
p6444
(F-2.407924016316732
F-1.6525203704833984
tp6445
sS'print l'
p6446
(F-4.657293319702148
F-1.5876370429992677
tp6447
sS'l = slist(range(10))\nl.length\nprint l'
p6448
(F-4.149765862358941
F-1.5172853469848633
tp6449
sS"items = []\nitems.append('apple')\nitems.append('orange')"
p6450
(F-2.19565486907959
F-1.5755648612976074
tp6451
sS'items.__len__()'
p6452
(F-5.248222351074219
F-1.7698421478271484
tp6453
sS"items.append('orange')\nitems.append('banana')"
p6454
(F-2.361109415690104
F-1.656221580505371
tp6455
sS'True'
p6456
(F-6.515811920166016
F-2.0171875
tp6457
sS'len([1, 2, 3])'
p6458
(F-2.007513999938965
F-1.522204875946045
tp6459
sS'def length(self):\n    pass'
p6460
(F-2.1293312708536782
F-1.8530670166015626
tp6461
sS'def length(self):\n    return len(self)'
p6462
(F-2.496459722518921
F-1.8007274627685548
tp6463
sS"items.append('orange')"
p6464
(F-2.2745614051818848
F-1.665481948852539
tp6465
sS'l.length\nprint l'
p6466
(F-4.751618385314941
F-1.5041007041931151
tp6467
sS'l = slist(range(10))\nl.length'
p6468
(F-4.449163818359375
F-1.525253963470459
tp6469
sS'items = []'
p6470
(F-3.212775548299154
F-1.544090461730957
tp6471
sS'return len(self)'
p6472
(F-4.551237923758371
F-1.8173185348510743
tp6473
sS'class slist(list):\n    pass'
p6474
(F-2.7414398193359375
F-1.5493361473083496
tp6475
sS'l = slist(range(10))'
p6476
(F-3.300373077392578
F-1.5193154335021972
tp6477
sS"items = []\nitems.append('apple')"
p6478
(F-2.40578372661884
F-1.5785515785217286
tp6479
sS"items.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6480
(F-2.2548033974387427
F-1.6466178894042969
tp6481
ssI1720421
(dp6482
S'for item in itertools.chain(listone, listtwo):\n    pass'
p6483
(F-1.530544810824924
F-2.889532235952524
tp6484
sS'mergedlist = list(set((listone + listtwo)))'
p6485
(F-2.282538350423177
F-2.904247577373798
tp6486
sS'pass'
p6487
(F-2.97981866200765
F-3.8428594149076023
tp6488
sS'import itertools\nfor item in itertools.chain(listone, listtwo):\n    pass'
p6489
(F-1.5907147725423176
F-2.8959514911358175
tp6490
sS'mergedlist = (listone + listtwo)'
p6491
(F-2.8801456027560763
F-3.1898087721604567
tp6492
sS'import itertools'
p6493
(F-4.755110263824463
F-3.0095320481520433
tp6494
ssI209513
(dp6495
S"x = int('deadbeef', 16)"
p6496
(F-3.374903106689453
F-1.68561585744222
tp6497
sS'int(s, 16)'
p6498
(F-3.007220506668091
F-1.643975469801161
tp6499
sS"int('a', 16)\nint('0xa', 16)"
p6500
(F-3.3886845906575522
F-1.6203745736016169
tp6501
sS"int('0xa', 16)"
p6502
(F-2.677377700805664
F-1.7022645738389757
tp6503
sS"print int('10', 0)"
p6504
(F-2.8552012973361545
F-1.7231708102756076
tp6505
sS"print int('0xdeadbeef', 0)"
p6506
(F-2.8552012973361545
F-1.7231708102756076
tp6507
sS"print int('0xdeadbeef', 0)\nprint int('10', 0)"
p6508
(F-2.899312412037569
F-1.7136238945855036
tp6509
sS"int('a', 16)"
p6510
(F-2.677377700805664
F-1.7022645738389757
tp6511
ssI642154
(dp6512
S'T2 = [[int(column) for column in row] for row in T1]'
p6513
(F-3.000447654724121
F-1.8642359646883877
tp6514
sS'[[int(y) for y in x] for x in T1]'
p6515
(F-2.720930735270182
F-1.7662259882146663
tp6516
sS'T2 = [parse_a_row_of_T1(row) for row in T1]'
p6517
(F-3.848931746049361
F-1.6861600008877842
tp6518
sS"print (int('1') + 1)"
p6519
(F-2.4015749151056465
F-1.5355247150767932
tp6520
sS'T2 = [map(int, x) for x in T1]'
p6521
(F-2.175856113433838
F-1.7216547185724431
tp6522
ssI2269827
(dp6523
S"(chr(101) == 'e')\nhex(65)"
p6524
(F-4.199517059326172
F-1.6215575536092122
tp6525
sS"hex(65)\n(chr(65) == 'A')"
p6526
(F-3.7983469645182293
F-1.6086807250976562
tp6527
sS"('0x%x' % 255)"
p6528
(F-4.271505083356585
F-1.7050188382466633
tp6529
sS"(chr(101) == 'e')\nhex(65)\n(chr(65) == 'A')"
p6530
(F-4.020042737325032
F-1.6064743995666504
tp6531
sS"(chr(101) == 'e')"
p6532
(F-3.5079673767089843
F-1.6864975293477376
tp6533
sS"strHex = ('0x%0.2X' % 255)"
p6534
(F-3.873767852783203
F-1.7322635650634766
tp6535
sS"('0x%X' % 255)"
p6536
(F-4.271505083356585
F-1.7050188382466633
tp6537
sS'hex(65)'
p6538
(F-3.591347058614095
F-1.7050406138102214
tp6539
sS"(chr(65) == 'A')"
p6540
(F-3.461187744140625
F-1.6579952239990234
tp6541
ssI6996603
(dp6542
S'shutil.rmtree(path, ignore_errors=False, onerror=None)'
p6543
(F-2.444779713948568
F-2.249225828382704
tp6544
sS'os.removedirs(name)'
p6545
(F-2.183741331100464
F-2.5697419908311634
tp6546
sS'os.rmdir'
p6547
(F-2.9525989532470702
F-2.569118923611111
tp6548
sS'os.remove'
p6549
(F-4.132257080078125
F-2.4584708743625217
tp6550
ssI227459
(dp6551
S'chr(97)'
p6552
(F-3.382887522379557
F-2.818251927693685
tp6553
sS'ord()'
p6554
(F-3.369729232788086
F-2.8247388203938804
tp6555
sS"ord('a')\nchr(97)"
p6556
(F-3.095722198486328
F-2.8382511138916016
tp6557
sS'unichr(1234)'
p6558
(F-3.7498954137166343
F-2.8180147806803384
tp6559
sS"ord('a')\nchr(97)\nchr((ord('a') + 3))"
p6560
(F-2.945858499278193
F-2.833699756198459
tp6561
sS'unichr(97)'
p6562
(F-3.7892786661783853
F-2.805730183919271
tp6563
sS"chr((ord('a') + 3))"
p6564
(F-2.298917476947491
F-2.7947180006239147
tp6565
sS"ord('a')"
p6566
(F-1.9419364929199219
F-2.838660558064779
tp6567
sS'unichr(97)\nunichr(1234)'
p6568
(F-4.420503442937678
F-2.8254087236192493
tp6569
sS"ord(u'\\u3042')"
p6570
(F-1.9419364929199219
F-2.838660558064779
tp6571
sS"chr(97)\nchr((ord('a') + 3))"
p6572
(F-3.0561510721842446
F-2.8068434397379556
tp6573
ssI9257094
(dp6574
S"lower = raw_input('type in the same thing caps lock.')"
p6575
(F-2.268836784362793
F-3.0207748413085938
tp6576
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p6577
(F-2.101990479689378
F-2.942869398328993
tp6578
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p6579
(F-2.422825981588925
F-2.94466315375434
tp6580
sS'print upper.upper()\nprint lower.lower()'
p6581
(F-3.7025100708007814
F-2.9184661441379123
tp6582
sS'print s.upper()'
p6583
(F-2.4624083042144775
F-2.898315853542752
tp6584
sS'string.ascii_uppercase'
p6585
(F-2.8414306640625
F-3.1350955963134766
tp6586
sS"upper = raw_input('type in something lowercase.')"
p6587
(F-2.305975914001465
F-2.9943389892578125
tp6588
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')"
p6589
(F-2.0840954027677836
F-2.9591066572401257
tp6590
sS's.upper()'
p6591
(F-2.070614678519113
F-2.901856952243381
tp6592
sS"s = 'sdsd'\ns.upper()"
p6593
(F-1.9012378345836292
F-2.9060755835639105
tp6594
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p6595
(F-2.240455165053859
F-2.931703143649631
tp6596
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p6597
(F-2.5575919151306152
F-2.929287168714735
tp6598
sS"s = 'sdsd'\nprint s.upper()"
p6599
(F-1.6263292630513508
F-2.9107403225368924
tp6600
sS"s = 'sdsd'"
p6601
(F-2.2565208435058595
F-3.0233383178710938
tp6602
sS'print lower.lower()'
p6603
(F-3.693037509918213
F-2.974021487765842
tp6604
sS'import string'
p6605
(F-4.820491790771484
F-3.2427226172553167
tp6606
sS'import string\nstring.ascii_uppercase'
p6607
(F-3.6226970672607424
F-3.1418219672309027
tp6608
sS'print upper.upper()'
p6609
(F-3.885322093963623
F-2.933809280395508
tp6610
ssI730764
(dp6611
S'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    raise'
p6612
(F-1.9557598025299783
F-3.7310943603515625
tp6613
sS'try:\n    doSomething()\nexcept Exception:\n    pass'
p6614
(F-1.396454459742496
F-3.63134765625
tp6615
sS'try:\n    sys.exit(1)\nexcept Exception:\n    pass'
p6616
(F-0.9901674361456008
F-3.5842386881510415
tp6617
sS'try:\n    doSomething()\nexcept:\n    pass'
p6618
(F-1.479035907321506
F-3.622320556640625
tp6619
sS'pass'
p6620
(F-2.7382005055745444
F-3.654072570800781
tp6621
sS"shutil.rmtree('/fake/dir')"
p6622
(F-2.0867433547973633
F-3.816517384847005
tp6623
sS'try:\n    do_something()\nexcept:\n    pass'
p6624
(F-1.1448789897717928
F-3.60587158203125
tp6625
sS'raise'
p6626
(F-7.706766128540039
F-3.650501251220703
tp6627
sS'shutil.rmtree(2)'
p6628
(F-2.7101128101348877
F-3.82639643351237
tp6629
sS'shutil.rmtree(path)'
p6630
(F-2.344165086746216
F-3.8546244303385415
tp6631
sS'if (e.errno == 2):\n    pass'
p6632
(F-2.4306325276692706
F-3.5938425699869794
tp6633
sS'handle_exception()'
p6634
(F-3.5444444928850447
F-3.8109898885091145
tp6635
sS'try:\n    do_something()\nexcept:\n    handle_exception()'
p6636
(F-1.8829906297766643
F-3.6092872619628906
tp6637
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    pass'
p6638
(F-1.68744765880496
F-3.7323277791341147
tp6639
sS'sys.exit(1)'
p6640
(F-1.78574538230896
F-3.6227795918782553
tp6641
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    pass'
p6642
(F-1.3935743967692058
F-3.8133227030436196
tp6643
sS'try:\n    shutil.rmtree(path)\nexcept OSError:\n    pass'
p6644
(F-1.2471249320290305
F-3.820046234130859
tp6645
sS'try:\n    sys.exit(1)\nexcept:\n    pass'
p6646
(F-1.057365608215332
F-3.582697550455729
tp6647
sS'do_something()'
p6648
(F-1.642397744315011
F-3.610584513346354
tp6649
sS'doSomething()'
p6650
(F-2.849339167277018
F-3.69296875
tp6651
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass'
p6652
(F-1.8061692979600694
F-3.7510147094726562
tp6653
sS'try:\n    do_something()\nexcept:\n    handle_exception()\nraise'
p6654
(F-2.7343194580078123
F-3.6120389302571616
tp6655
ssI70797
(dp6656
S"var = raw_input('Please enter something: ')"
p6657
(F-1.8819829940795898
F-3.8405723571777344
tp6658
sS'import sys'
p6659
(F-4.574221611022949
F-4.422186957465278
tp6660
sS"print ('you entered ' + input_var)"
p6661
(F-2.1855937957763674
F-3.936982896592882
tp6662
sS'import sys\nprint sys.argv'
p6663
(F-2.412574132283529
F-4.370670318603516
tp6664
sS"print 'you entered', var"
p6665
(F-2.9763876597086587
F-4.006999121771918
tp6666
sS"input_var = input('Enter something: ')"
p6667
(F-2.4477798461914064
F-3.8446066114637585
tp6668
sS"input_var = input('Enter something: ')\nprint ('you entered ' + input_var)"
p6669
(F-2.0214859811883223
F-3.809334225124783
tp6670
sS'print sys.argv'
p6671
(F-3.7964080174764
F-4.245496537950304
tp6672
sS"var = raw_input('Please enter something: ')\nprint 'you entered', var"
p6673
(F-1.9430606842041016
F-3.81101565890842
tp6674
ssI4706499
(dp6675
S"f.write('hi')"
p6676
(F-1.2601652145385742
F-1.3119858105977376
tp6677
sS'f.seek(0)'
p6678
(F-1.5205163955688477
F-1.294796625773112
tp6679
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6680
(F-1.3951952253069198
F-1.296322186787923
tp6681
sS'f.seek(0)\nf.read()'
p6682
(F-1.6198248182024275
F-1.2945492267608643
tp6683
sS"f.write('hi')\nf.seek(0)"
p6684
(F-1.5928943634033204
F-1.3060418764750164
tp6685
sS"open('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p6686
(F-1.1913574536641438
F-1.2364695866902669
tp6687
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6688
(F-1.3658694675990513
F-1.299714724222819
tp6689
sS"open('test', 'rb').read()"
p6690
(F-1.0304359594980876
F-1.2563401063283284
tp6691
sS"f.seek(0)\nf.write('bye')"
p6692
(F-1.3953435262044271
F-1.2786938349405925
tp6693
sS"with open('foo', 'a') as f:\n    pass"
p6694
(F-1.0334527492523193
F-1.2816646893819172
tp6695
sS"f.write('bye')\nf.seek(0)\nf.read()"
p6696
(F-1.429402850923084
F-1.3086591561635335
tp6697
sS"myfile.write('appended text')"
p6698
(F-1.6873118877410889
F-1.264520804087321
tp6699
sS"f = open('test', 'a+')"
p6700
(F-1.28002986907959
F-1.2722307840983074
tp6701
sS"with open('test.txt', 'a') as myfile:\n    myfile.write('appended text')"
p6702
(F-0.9861643654959542
F-1.2411028544108074
tp6703
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6704
(F-1.075667294588956
F-1.2713150183359783
tp6705
sS"f.read()\nf.seek(0)\nf.write('bye')"
p6706
(F-1.612712678455171
F-1.293428659439087
tp6707
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6708
(F-1.3239798196932164
F-1.296553373336792
tp6709
sS"f.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6710
(F-1.274041039603097
F-1.291317621866862
tp6711
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6712
(F-1.0391132287811815
F-1.2762245337168376
tp6713
sS"f.seek(0)\nf.write('bye')\nf.seek(0)"
p6714
(F-1.3542630455710671
F-1.2899893124898274
tp6715
sS'f.seek(0)\nf.read()\nf.seek(0)'
p6716
(F-1.7298907325381325
F-1.2992730935414631
tp6717
sS"f.write('hi')\nf.seek(0)\nf.read()"
p6718
(F-1.429402850923084
F-1.3086591561635335
tp6719
sS"open('test', 'a+b').write('koko')"
p6720
(F-0.8996385427621695
F-1.247968355814616
tp6721
sS"f.write('cool beans...')"
p6722
(F-1.2601652145385742
F-1.3119858105977376
tp6723
sS"with open('foo', 'a') as f:\n    f.write('cool beans...')"
p6724
(F-0.6173566182454427
F-1.2707308928171794
tp6725
sS'f.read()\nf.seek(0)'
p6726
(F-2.0613132204328264
F-1.3065043290456135
tp6727
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6728
(F-1.4718622480119978
F-1.2982198397318523
tp6729
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6730
(F-1.3098546890985399
F-1.303134282430013
tp6731
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p6732
(F-1.5421291078839983
F-1.3073134422302246
tp6733
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()"
p6734
(F-0.9897837320963542
F-1.2654056549072266
tp6735
sS"f.write('bye')"
p6736
(F-1.2601652145385742
F-1.3119858105977376
tp6737
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p6738
(F-1.150143199496799
F-1.2330727577209473
tp6739
sS"'testkoko'"
p6740
(F-4.511280695597331
F-1.712022304534912
tp6741
sS"f = open('test', 'a+')\nf.write('hi')"
p6742
(F-1.059873019947725
F-1.2584277788798015
tp6743
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6744
(F-1.253139813741048
F-1.302984396616618
tp6745
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6746
(F-1.3740797603831572
F-1.2984641393025715
tp6747
sS"f.write('koko')"
p6748
(F-1.2601652145385742
F-1.3119858105977376
tp6749
sS"with open('test.txt', 'a') as myfile:\n    pass"
p6750
(F-1.3127415180206299
F-1.2436580657958984
tp6751
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6752
(F-1.0708452112534468
F-1.2752952575683594
tp6753
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)"
p6754
(F-1.02977720896403
F-1.2600189844767253
tp6755
sS'f.read()'
p6756
(F-1.76669066292899
F-1.3300525347391765
tp6757
sS"open('test', 'wb').write('test')"
p6758
(F-0.8996384694026067
F-1.247968355814616
tp6759
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p6760
(F-1.1606818534232475
F-1.2708574930826824
tp6761
sS"f.write('test')"
p6762
(F-1.2601652145385742
F-1.3119856516520183
tp6763
sS'fseek(stream, 0, SEEK_END)'
p6764
(F-4.294582366943359
F-1.8508955637613933
tp6765
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')"
p6766
(F-1.075693130493164
F-1.2336161931355794
tp6767
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6768
(F-1.4821181978498186
F-1.2900096575419109
tp6769
sS"f.write('bye')\nf.seek(0)"
p6770
(F-1.5928943634033204
F-1.3060418764750164
tp6771
ssI22676
(dp6772
S"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6773
(F-2.82997563680013
F-1.7925806779127855
tp6774
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6775
(F-2.8657947484997734
F-1.7253878666804388
tp6776
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p6777
(F-1.1446880158923922
F-1.6967830657958984
tp6778
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p6779
(F-2.253931884765625
F-1.7819406069242036
tp6780
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6781
(F-3.0958158531967475
F-2.24881465618427
tp6782
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p6783
(F-1.5692180417618662
F-1.7098897787240834
tp6784
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6785
(F-3.4865473305306782
F-2.060281753540039
tp6786
sS"file_name = url.split('/')[(-1)]"
p6787
(F-2.6923359764946833
F-1.9818873772254357
tp6788
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')"
p6789
(F-1.5097226362961988
F-1.6958977625920222
tp6790
sS'f.close()'
p6791
(F-1.2900782993861608
F-2.1807531210092397
tp6792
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6793
(F-2.7310084025065104
F-2.13057620708759
tp6794
sS"urllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p6795
(F-1.47196626663208
F-1.651555868295523
tp6796
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6797
(F-3.2962090174357095
F-2.023719494159405
tp6798
sS'import urllib'
p6799
(F-4.291531562805176
F-1.8284222529484675
tp6800
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6801
(F-2.587726508246528
F-1.8339977264404297
tp6802
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p6803
(F-1.3897670877390895
F-1.6918962918795073
tp6804
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p6805
(F-2.370802459716797
F-1.7834186553955078
tp6806
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6807
(F-3.363625114732753
F-1.9085088876577525
tp6808
sS"url = 'http://download.thinkbroadband.com/10MB.zip'"
p6809
(F-2.1839780807495117
F-1.8842798379751353
tp6810
sS'if (not buffer):\n    break\nfile_size_dl += len(buffer)'
p6811
(F-3.8009159253991167
F-2.036980702326848
tp6812
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6813
(F-2.8061067155263957
F-1.8074246920072115
tp6814
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6815
(F-3.7480198956918027
F-2.0557440244234524
tp6816
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p6817
(F-2.2649640535053455
F-1.7549709906944861
tp6818
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6819
(F-4.232900479944741
F-2.2174534430870643
tp6820
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6821
(F-3.004705156598772
F-1.9729834336500902
tp6822
sS"f = open(file_name, 'wb')"
p6823
(F-1.868692398071289
F-2.13786741403433
tp6824
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p6825
(F-3.9808201789855957
F-1.9120628650371845
tp6826
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6827
(F-4.139199266155947
F-2.1639958895169773
tp6828
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6829
(F-4.129606410435268
F-2.2701961810772238
tp6830
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6831
(F-3.056115286690848
F-2.06557376568134
tp6832
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6833
(F-2.9086875221946022
F-2.000394527728741
tp6834
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6835
(F-3.051446242559524
F-1.9626209552471454
tp6836
sS'print status,\nf.close()'
p6837
(F-3.470743352716619
F-2.1921304556039662
tp6838
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p6839
(F-4.741111509261593
F-2.0903851435734677
tp6840
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p6841
(F-3.610716772861168
F-1.9563559018648589
tp6842
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6843
(F-2.597667943651431
F-1.7268797067495494
tp6844
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6845
(F-4.064201586174242
F-2.163523453932542
tp6846
sS'break'
p6847
(F-3.441464106241862
F-2.045224116398738
tp6848
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6849
(F-4.147014092961583
F-2.104949657733624
tp6850
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p6851
(F-4.024903615315755
F-1.954057400043194
tp6852
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6853
(F-2.8576264717209505
F-1.7666039100060096
tp6854
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p6855
(F-1.595191123268821
F-1.7464427947998047
tp6856
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p6857
(F-1.8608677305024246
F-1.7411221724290113
tp6858
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6859
(F-2.830552936422414
F-1.7327536069429839
tp6860
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6861
(F-4.074092320033482
F-2.10523194533128
tp6862
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p6863
(F-1.255173471238878
F-1.667649929340069
tp6864
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6865
(F-2.2685879927415113
F-2.2591366401085486
tp6866
sS'import requests'
p6867
(F-3.9103498458862305
F-1.7091701214130108
tp6868
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6869
(F-2.546616420950941
F-1.7823280921349158
tp6870
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p6871
(F-1.8193952387029475
F-2.058054703932542
tp6872
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6873
(F-3.3031587895658827
F-1.8264075059157152
tp6874
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p6875
(F-1.813099089122954
F-1.7121756627009466
tp6876
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6877
(F-1.9627773761749268
F-2.2507137885460486
tp6878
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p6879
(F-3.28065197673065
F-1.8364389859713042
tp6880
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6881
(F-2.696969299316406
F-1.790298315194937
tp6882
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p6883
(F-1.3102117265973772
F-1.730118678166316
tp6884
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p6885
(F-1.7477296528063322
F-2.0654205909142127
tp6886
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p6887
(F-2.2017432158848025
F-1.7306863344632661
tp6888
sS'handle.write(data)'
p6889
(F-2.168863534927368
F-2.114339094895583
tp6890
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p6891
(F-3.339502212849069
F-1.9297241797814002
tp6892
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6893
(F-2.7656004622175887
F-1.9630027184119592
tp6894
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6895
(F-2.599458834020103
F-2.5182530329777646
tp6896
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6897
(F-3.4522021063442887
F-2.066436767578125
tp6898
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6899
(F-2.959486995834902
F-1.959387705876277
tp6900
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6901
(F-3.4140995106798537
F-1.8700797741229718
tp6902
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6903
(F-2.9193193151595747
F-1.9785040341890776
tp6904
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6905
(F-3.14719820022583
F-1.960823499239408
tp6906
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6907
(F-3.1702630835843375
F-2.0286702376145582
tp6908
sS'file_size_dl = 0\nblock_sz = 8192'
p6909
(F-5.456316630045573
F-1.7645378112792969
tp6910
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p6911
(F-3.7662665325662363
F-1.9596387423001802
tp6912
sS"f = open(file_name, 'wb')\nmeta = u.info()"
p6913
(F-2.4011203765869142
F-2.1455741295447717
tp6914
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6915
(F-3.6265554603623467
F-2.034800015963041
tp6916
sS'print status,'
p6917
(F-6.338193893432617
F-2.2537369361290565
tp6918
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6919
(F-3.0721148681640624
F-1.9998700068547175
tp6920
sS'status = (status + (chr(8) * (len(status) + 1)))'
p6921
(F-3.8675202079441235
F-2.776732224684495
tp6922
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6923
(F-3.2761450443171003
F-1.7880703852726862
tp6924
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6925
(F-2.267690485174006
F-2.3547666989839993
tp6926
sS'u = urllib2.urlopen(url)'
p6927
(F-1.978174591064453
F-1.7689247131347656
tp6928
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p6929
(F-2.253432273864746
F-1.695825723501352
tp6930
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p6931
(F-1.700046074099657
F-1.7157588371863732
tp6932
sS'for data in tqdm(response.iter_content()):\n    handle.write(data)'
p6933
(F-2.1822654724121096
F-1.98527952340933
tp6934
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6935
(F-3.122720015676398
F-1.8810279552753155
tp6936
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6937
(F-3.1474921113701275
F-1.9507415478046124
tp6938
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6939
(F-2.2181409050436582
F-1.81816893357497
tp6940
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p6941
(F-2.8973681640625
F-1.7830477494459887
tp6942
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6943
(F-2.943110148111979
F-1.7981116955096905
tp6944
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6945
(F-2.849869194380734
F-1.7863854628342848
tp6946
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p6947
(F-2.383289849580224
F-1.8704961630014272
tp6948
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6949
(F-4.316445993822675
F-2.216047873863807
tp6950
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6951
(F-3.4087015787760415
F-1.9124318636380708
tp6952
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6953
(F-2.9042426495512657
F-1.8118362426757812
tp6954
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6955
(F-3.8782258467240767
F-2.0522716228778544
tp6956
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p6957
(F-2.3657007632048233
F-1.9408179063063402
tp6958
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6959
(F-3.978070599099864
F-2.106054452749399
tp6960
sS'if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p6961
(F-3.518651580810547
F-2.0386216090275693
tp6962
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p6963
(F-1.2232430401970358
F-1.697839883657602
tp6964
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6965
(F-2.7390391432394194
F-1.7330725743220403
tp6966
sS'response = requests.get(url, stream=True)'
p6967
(F-1.3401442936488561
F-1.7421669593224158
tp6968
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6969
(F-2.317883613782051
F-1.9001168471116285
tp6970
sS'if (not buffer):\n    break'
p6971
(F-3.1286748250325522
F-2.3904090294471154
tp6972
sS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()'
p6973
(F-3.689550457578717
F-2.541600153996394
tp6974
sS"import urllib\nurllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p6975
(F-1.058265392596905
F-1.6180940774770884
tp6976
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6977
(F-4.32194349500868
F-2.2588436420147238
tp6978
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6979
(F-2.9005233020317265
F-2.1268127147967997
tp6980
sS'meta = u.info()'
p6981
(F-3.779783460828993
F-2.7982377272385817
tp6982
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p6983
(F-2.7690326321509575
F-1.7730756906362681
tp6984
sS'from tqdm import tqdm'
p6985
(F-5.212052663167317
F-2.802753155048077
tp6986
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p6987
(F-3.653885242550872
F-1.9829287895789514
tp6988
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p6989
(F-2.823309580485026
F-1.782380617581881
tp6990
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6991
(F-2.642406785344503
F-1.7878834651066706
tp6992
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6993
(F-3.707927115011535
F-2.0353968693659854
tp6994
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6995
(F-2.8949616608796296
F-1.7607950063852162
tp6996
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6997
(F-3.286507139814661
F-1.964655802800105
tp6998
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p6999
(F-3.167294789509601
F-2.037779147808368
tp7000
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7001
(F-1.706170123556386
F-1.7478199005126953
tp7002
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7003
(F-4.114271636702057
F-2.084815685565655
tp7004
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p7005
(F-2.615242336107337
F-1.8731431227463942
tp7006
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7007
(F-4.015697772686298
F-2.0091090569129357
tp7008
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7009
(F-3.1383226834810696
F-2.720484806941106
tp7010
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7011
(F-3.3264706739738807
F-1.7905550736647387
tp7012
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7013
(F-2.7392441156342273
F-1.7359385857215295
tp7014
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7015
(F-4.4223584626850325
F-2.1584931887113132
tp7016
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7017
(F-4.011748871245942
F-2.0974370516263523
tp7018
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7019
(F-3.209803026775981
F-1.9520765451284556
tp7020
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7021
(F-3.878624979654948
F-1.7934766916128306
tp7022
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7023
(F-2.3747223563816235
F-1.7940763326791616
tp7024
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7025
(F-3.5985965851814514
F-2.0370637453519382
tp7026
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7027
(F-1.245719728015718
F-1.691531254695012
tp7028
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p7029
(F-2.2513500306664445
F-1.8701642843393178
tp7030
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7031
(F-3.76614182083695
F-1.952600625845102
tp7032
sS"with open('10MB', 'wb') as handle:\n    pass"
p7033
(F-1.3183345794677734
F-2.1985564598670373
tp7034
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7035
(F-2.782511753318584
F-1.7659979600172777
tp7036
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p7037
(F-3.5918382917131697
F-2.043651874248798
tp7038
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7039
(F-2.3316121255197833
F-1.7897465045635517
tp7040
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7041
(F-3.5442748296828497
F-2.061205350435697
tp7042
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7043
(F-2.769202447706653
F-1.7698480165921724
tp7044
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7045
(F-3.34719966008113
F-2.0202200962946963
tp7046
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7047
(F-3.260144726983432
F-1.9233392568734975
tp7048
sS'r = requests.get(url)\nprint len(r.content)'
p7049
(F-1.5244549645317926
F-1.7755000774676983
tp7050
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7051
(F-3.3142882899234167
F-1.923300523024339
tp7052
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7053
(F-3.643617406384698
F-2.0340827061579776
tp7054
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7055
(F-3.3936573535720735
F-1.9002921764667218
tp7056
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7057
(F-2.6299256544846754
F-1.7755869351900542
tp7058
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7059
(F-2.2362085230210247
F-1.7415034954364483
tp7060
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7061
(F-4.53511594376474
F-2.2758797865647535
tp7062
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7063
(F-3.247039794921875
F-2.016508542574369
tp7064
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7065
(F-2.781222565005524
F-1.7297008220966046
tp7066
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7067
(F-3.957693952855056
F-2.086043431208684
tp7068
sS'import urllib2'
p7069
(F-4.43674373626709
F-1.717523721548227
tp7070
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7071
(F-2.830272420247396
F-1.7969314868633564
tp7072
sS'while True:\n    buffer = u.read(block_sz)'
p7073
(F-3.4894900851779513
F-2.1782897068903995
tp7074
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7075
(F-4.236515553792318
F-2.0930938720703125
tp7076
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7077
(F-2.143483116513207
F-1.7498541611891527
tp7078
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7079
(F-2.098469034830729
F-1.7093190413254957
tp7080
sS"response = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p7081
(F-1.3006972206963434
F-1.7345804067758412
tp7082
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7083
(F-3.403443012040915
F-1.8661541571983924
tp7084
sS'f.write(buffer)'
p7085
(F-2.201873302459717
F-2.1910398923433743
tp7086
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7087
(F-3.0694508870442707
F-2.006242898794321
tp7088
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7089
(F-4.044505971722899
F-2.083711183988131
tp7090
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7091
(F-3.2796903124042585
F-1.8332297985370343
tp7092
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7093
(F-3.1913838940997454
F-1.7813461010272686
tp7094
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7095
(F-4.298870849609375
F-2.2873524885911207
tp7096
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7097
(F-3.244288126627604
F-1.8096785912146935
tp7098
sS"file_size = int(meta.getheaders('Content-Length')[0])"
p7099
(F-2.621781667073568
F-2.479969024658203
tp7100
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p7101
(F-2.463483983820135
F-1.9224711198073168
tp7102
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p7103
(F-2.66254513762718
F-1.8541429959810698
tp7104
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7105
(F-1.4252268184315076
F-1.7623616732083833
tp7106
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7107
(F-4.420346260070801
F-2.2812767028808594
tp7108
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7109
(F-4.04857957219503
F-2.0221003018892727
tp7110
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7111
(F-4.425322265625
F-2.2419938307542067
tp7112
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7113
(F-2.8265171880307407
F-1.7901888627272387
tp7114
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7115
(F-3.7415722541089327
F-1.9770443256084735
tp7116
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7117
(F-2.541989300702069
F-2.29237908583421
tp7118
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7119
(F-3.5874771981869102
F-1.9627813192514272
tp7120
sS'for data in tqdm(response.iter_content()):\n    pass'
p7121
(F-2.330577087402344
F-2.104476341834435
tp7122
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7123
(F-4.177117241753472
F-2.233554106492263
tp7124
sS'buffer = u.read(block_sz)'
p7125
(F-4.32437006632487
F-2.094243416419396
tp7126
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7127
(F-3.7310425582205413
F-2.032995810875526
tp7128
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7129
(F-3.5816158294677733
F-2.110685495229868
tp7130
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7131
(F-2.8043295851031553
F-1.8132705688476562
tp7132
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7133
(F-3.264202512543777
F-1.9186897277832031
tp7134
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7135
(F-2.3356026785714286
F-1.812524942251352
tp7136
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7137
(F-3.67147847094567
F-2.032251211313101
tp7138
sS'print len(r.content)'
p7139
(F-2.5144322713216147
F-1.9979148277869592
tp7140
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass'
p7141
(F-3.7576907614003057
F-1.9630037454458384
tp7142
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7143
(F-1.8008929055834573
F-1.72614992581881
tp7144
sS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,'
p7145
(F-4.265828450520833
F-2.708369328425481
tp7146
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7147
(F-2.913162452587183
F-1.7914617978609526
tp7148
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7149
(F-1.2968617545233831
F-1.7469880030705378
tp7150
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7151
(F-1.3369430541992187
F-1.7198069645808294
tp7152
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7153
(F-2.257625102996826
F-1.7016435769888072
tp7154
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7155
(F-3.457265125621449
F-2.0585707150972805
tp7156
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7157
(F-3.326297607421875
F-1.8712670252873347
tp7158
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7159
(F-1.3229372429125237
F-1.7120744265042818
tp7160
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7161
(F-3.9624961363066227
F-2.1639413100022535
tp7162
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7163
(F-3.2498884529903016
F-2.2163980924166164
tp7164
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7165
(F-4.309650689783231
F-2.2434822962834287
tp7166
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7167
(F-3.6599855644758357
F-1.9764964763934796
tp7168
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7169
(F-2.5286585489908853
F-1.7948675889235277
tp7170
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7171
(F-1.6586052389705883
F-1.7439152644230769
tp7172
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7173
(F-3.384216093681228
F-1.9998664855957031
tp7174
sS'from tqdm import tqdm\nimport requests'
p7175
(F-4.242962307400173
F-2.4271783095139723
tp7176
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7177
(F-3.8109331130981445
F-2.0505203833946815
tp7178
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7179
(F-3.6029102870396206
F-2.0297056344839244
tp7180
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7181
(F-3.2232348753674196
F-1.9587481572077825
tp7182
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7183
(F-1.6380384826660157
F-1.7522540459266076
tp7184
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7185
(F-4.096466064453125
F-2.2086209517258863
tp7186
sS'file_size_dl += len(buffer)'
p7187
(F-4.283130009969075
F-1.952551768376277
tp7188
sS'if (not buffer):\n    pass'
p7189
(F-3.0326735178629556
F-2.4661639286921573
tp7190
sS"response = urllib2.urlopen('http://www.example.com/')"
p7191
(F-1.7134286880493164
F-1.7563323974609375
tp7192
sS'file_size_dl = 0'
p7193
(F-4.7737375895182295
F-1.9312258500319262
tp7194
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7195
(F-2.903946254564368
F-1.7975299541766827
tp7196
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7197
(F-3.3522409539473683
F-1.864041255070613
tp7198
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7199
(F-3.58941650390625
F-1.9563912611741285
tp7200
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p7201
(F-2.1706618011974896
F-1.9501225398137019
tp7202
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7203
(F-3.5556866405456047
F-1.9649012638972356
tp7204
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7205
(F-3.163165806361607
F-1.7465874598576472
tp7206
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7207
(F-2.1002733954067887
F-1.7800140380859375
tp7208
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7209
(F-2.4725521027095736
F-1.897619100717398
tp7210
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7211
(F-1.9743197514460638
F-1.7917010967548077
tp7212
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7213
(F-3.06351933334813
F-1.9527457310603216
tp7214
sS'file_size_dl += len(buffer)\nf.write(buffer)'
p7215
(F-3.7912681981136926
F-2.013606144831731
tp7216
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7217
(F-3.424261214885306
F-2.1018822009746847
tp7218
sS'block_sz = 8192'
p7219
(F-6.170188903808594
F-1.749842276939979
tp7220
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7221
(F-3.2540047318463166
F-1.7957053551307092
tp7222
sS'html = response.read()'
p7223
(F-1.6699587504069011
F-1.8342600602370043
tp7224
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7225
(F-4.656385455215187
F-2.277753389798678
tp7226
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7227
(F-3.353913586549085
F-1.8288123791034405
tp7228
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7229
(F-2.954255315183683
F-1.7831811171311598
tp7230
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7231
(F-3.4480983928098516
F-1.9024399977463942
tp7232
sS'while True:\n    pass'
p7233
(F-1.7917569478352864
F-2.6189205463115988
tp7234
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7235
(F-2.9176801316281584
F-1.9846982222336988
tp7236
sS'block_sz = 8192\nwhile True:\n    pass'
p7237
(F-3.5470703125
F-2.0869005643404446
tp7238
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7239
(F-2.7491157794820853
F-1.7247161865234375
tp7240
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7241
(F-4.3883766641422195
F-2.119640056903546
tp7242
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p7243
(F-3.227008161873653
F-2.2291746873121996
tp7244
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7245
(F-1.5426893563106143
F-1.7085990905761719
tp7246
sS'r = requests.get(url)'
p7247
(F-1.345461654663086
F-1.7470932006835938
tp7248
ssI739993
(dp7249
S'import pip\ninstalled_packages = pip.get_installed_distributions()'
p7250
(F-3.5698971218532987
F-2.8252759660993303
tp7251
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p7252
(F-3.05447040904652
F-2.857853208269392
tp7253
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p7254
(F-3.1806165422712054
F-2.893010820661272
tp7255
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p7256
(F-3.5607914171720805
F-2.875736509050642
tp7257
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7258
(F-3.646375894546509
F-3.0495082310267856
tp7259
sS'(iterpipes == 0.4)'
p7260
(F-6.186827523367746
F-3.2358300345284596
tp7261
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7262
(F-3.5880257742745534
F-2.8272999354771207
tp7263
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p7264
(F-2.9692196729706555
F-3.0134476252964566
tp7265
sS'(cd / tmp)'
p7266
(F-6.635918753487723
F-3.142359597342355
tp7267
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p7268
(F-3.9976133688902245
F-3.0287508283342635
tp7269
sS"['behave==1.2.4', 'enum34==1.0', 'flask==0.10.1', 'itsdangerous==0.24', 'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3', 'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2', 'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1', 'vioozer-users-server==0.1', 'werkzeug==0.9.4']"
p7270
(F-0.7427655901227679
F-3.0179410661969865
tp7271
sS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7272
(F-3.6366258704144023
F-2.969371795654297
tp7273
sS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p7274
(F-3.8041908696012676
F-2.9580296107700894
tp7275
sS'import os'
p7276
(F-3.555577278137207
F-2.799729483468192
tp7277
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p7278
(F-3.7249671391078403
F-2.826718194144113
tp7279
sS'os.getcwd()'
p7280
(F-1.2392872401646204
F-2.8441273825509206
tp7281
sS'(docutils == 0.7)'
p7282
(F-6.0366091047014505
F-3.1323885236467635
tp7283
sS"help('modules')"
p7284
(F-2.0683048566182456
F-2.9605276925223216
tp7285
sS'print installed_packages_list'
p7286
(F-5.058919429779053
F-2.942774091448103
tp7287
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p7288
(F-3.049419641494751
F-3.0607471466064453
tp7289
sS'import pip'
p7290
(F-5.207508087158203
F-2.7847884041922435
tp7291
sS'import os\nos.getcwd()'
p7292
(F-1.0419711112976073
F-2.8277070181710378
tp7293
sS'installed_packages = pip.get_installed_distributions()'
p7294
(F-3.463958231608073
F-2.927258082798549
tp7295
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p7296
(F-3.4831045968191963
F-3.052789960588728
tp7297
ssI6797984
(dp7298
S"raw_input('Type Something').lower()"
p7299
(F-1.6753592491149902
F-1.7227292494340376
tp7300
sS"s = 'Kilometer'"
p7301
(F-2.2848739624023438
F-1.6422481536865234
tp7302
sS"print s.lower()\nprint s.decode('utf-8').lower()"
p7303
(F-1.938916015625
F-1.5210474187677556
tp7304
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'"
p7305
(F-2.2848739624023438
F-1.6422483270818538
tp7306
sS"s = 'Kilometer'\nprint s.lower()"
p7307
(F-1.5158491134643555
F-1.6092397516424006
tp7308
sS"print s.decode('utf-8').lower()"
p7309
(F-1.668931667621319
F-1.4982833862304688
tp7310
sS'print s.lower()'
p7311
(F-2.278003454208374
F-1.579405351118608
tp7312
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()\nprint s.decode('utf-8').lower()"
p7313
(F-1.52193021774292
F-1.535205147483132
tp7314
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()"
p7315
(F-1.5158491134643555
F-1.6092397516424006
tp7316
ssI1207457
(dp7317
S'import codecs'
p7318
(F-5.569892883300781
F-2.3458199501037598
tp7319
sS"type(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7320
(F-2.4869910875956216
F-2.211024761199951
tp7321
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')"
p7322
(F-2.3467680278577303
F-2.1921756267547607
tp7323
sS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7324
(F-2.3322990417480467
F-2.2567672729492188
tp7325
sS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7326
(F-2.4861554597553455
F-2.2341392040252686
tp7327
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata"
p7328
(F-4.091032981872559
F-2.4855551719665527
tp7329
sS'f.write(my_unicode_string)'
p7330
(F-2.816330909729004
F-2.347344398498535
tp7331
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)"
p7332
(F-2.260866165161133
F-2.2675869464874268
tp7333
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7334
(F-2.2906976427350725
F-2.201406478881836
tp7335
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7336
(F-2.1142782592773437
F-2.2912909984588623
tp7337
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7338
(F-2.3303402264912925
F-2.237058162689209
tp7339
sS"s = u'\\xa310'"
p7340
(F-2.2508317947387697
F-2.2450852394104004
tp7341
sS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7342
(F-2.5873936739834873
F-2.2593131065368652
tp7343
sS"s.encode('utf16')"
p7344
(F-1.398164987564087
F-2.205842971801758
tp7345
sS"a.encode('ascii', 'ignore')"
p7346
(F-1.9989044189453125
F-2.221430778503418
tp7347
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'"
p7348
(F-2.9087650299072267
F-2.411219596862793
tp7349
sS"s.encode('utf8')"
p7350
(F-1.398164987564087
F-2.2058427333831787
tp7351
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'"
p7352
(F-2.8526302337646485
F-2.3156723976135254
tp7353
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7354
(F-1.7042329451617073
F-2.274963617324829
tp7355
sS'type(a)'
p7356
(F-2.6215248107910156
F-2.4311232566833496
tp7357
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7358
(F-2.1575727462768555
F-2.3228440284729004
tp7359
sS"s = u'\\xa310'\ns.encode('utf8')\ns.encode('utf16')"
p7360
(F-1.4167809737356085
F-2.1939902305603027
tp7361
sS"a.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7362
(F-2.1916772942794
F-2.224738359451294
tp7363
sS"s.encode('utf8')\ns.encode('utf16')"
p7364
(F-1.6619261423746745
F-2.2072691917419434
tp7365
sS'import unicodedata'
p7366
(F-5.833782196044922
F-2.673377752304077
tp7367
sS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7368
(F-2.1510501188390396
F-2.230316162109375
tp7369
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7370
(F-1.4567034585135323
F-2.240220308303833
tp7371
sS"a.encode('ascii', 'replace')"
p7372
(F-1.9989044189453125
F-2.221430778503418
tp7373
sS"type(a)\na.encode('ascii', 'ignore')"
p7374
(F-2.633794403076172
F-2.2070136070251465
tp7375
sS"s = u'\\xa310'\ns.encode('utf8')"
p7376
(F-1.3045854568481445
F-2.184941053390503
tp7377
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7378
(F-2.4634103041428785
F-2.239156484603882
tp7379
sS"'Kluft skrams infor pa federal electoral groe'"
p7380
(F-3.8035589853922525
F-2.313278913497925
tp7381
ssI3294889
(dp7382
S'for (key, value) in d.iteritems():\n    pass'
p7383
(F-1.7825457924290706
F-2.1775150299072266
tp7384
sS'd.keys()'
p7385
(F-2.152782712663923
F-2.331419563293457
tp7386
sS'for key in d:\n    pass'
p7387
(F-1.5525106950239702
F-2.2104726791381837
tp7388
sS"print k, 'corresponds to', v"
p7389
(F-3.867128849029541
F-2.5521278381347656
tp7390
sS'for (key, value) in d.items():\n    pass'
p7391
(F-1.7867977744654606
F-2.21341552734375
tp7392
sS'd.items()'
p7393
(F-2.163620812552316
F-2.344659614562988
tp7394
sS"print letter, 'corresponds to', number"
p7395
(F-4.805974960327148
F-2.6797435760498045
tp7396
sS'list(d)'
p7397
(F-1.8374993006388347
F-2.3417732238769533
tp7398
sS'for (letter, number) in d.items():\n    pass'
p7399
(F-2.3538332487407483
F-2.421820640563965
tp7400
sS'for (k, v) in d.items():\n    pass'
p7401
(F-1.728400983308491
F-2.189967727661133
tp7402
sS"d = {'x': 1, 'y': 2, 'z': 3, }"
p7403
(F-2.2383590274386935
F-2.4237783432006834
tp7404
sS"print '{0} corresponds to {1}'.format(letter, number)"
p7405
(F-2.6404429349032315
F-2.759695816040039
tp7406
sS'pass'
p7407
(F-2.896704355875651
F-3.0448917388916015
tp7408
sS"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)"
p7409
(F-2.191252666970958
F-2.332820701599121
tp7410
sS'list(d)\nd.keys()'
p7411
(F-2.288571834564209
F-2.2159801483154298
tp7412
sS"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)\nd.keys()"
p7413
(F-2.2532359156115302
F-2.275234413146973
tp7414
ssI7571635
(dp7415
S"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7416
(F-2.0916397362424615
F-1.7570331280048077
tp7417
sS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7418
(F-2.3298308703364157
F-1.7633709540733924
tp7419
sS"print 'Not found'"
p7420
(F-4.4984354972839355
F-2.131749079777644
tp7421
sS"print 'found'"
p7422
(F-4.4984354972839355
F-2.131749079777644
tp7423
sS'(7 in a)'
p7424
(F-5.505568368094308
F-1.7255587944617639
tp7425
sS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7426
(F-2.1566237040928433
F-1.7552968538724458
tp7427
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7428
(F-2.105951162484976
F-1.7505895174466646
tp7429
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7430
(F-1.6394187211990356
F-1.7460960975060096
tp7431
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']"
p7432
(F-2.5492658113178455
F-1.769156969510592
tp7433
sS'index = dict(((y, x) for (x, y) in enumerate(a)))'
p7434
(F-2.176599426269531
F-1.7801918616661658
tp7435
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7436
(F-1.9019375610351563
F-1.746611815232497
tp7437
sS'a_index = index[7]'
p7438
(F-3.8389541625976564
F-1.7475081223707933
tp7439
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7440
(F-2.089381456375122
F-1.750908924983098
tp7441
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))'
p7442
(F-1.9564140133741426
F-1.7521890493539662
tp7443
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7444
(F-1.5524830673680161
F-1.752221474280724
tp7445
sS'a = [4, 2, 3, 1, 5, 6]'
p7446
(F-2.143256019143497
F-1.732110830453726
tp7447
sS'try:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7448
(F-1.918036937713623
F-1.7366632314828725
tp7449
sS"return ('a' in a)"
p7450
(F-3.536412477493286
F-1.8590149512657752
tp7451
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7452
(F-1.9960833655463324
F-1.74598635160006
tp7453
sS'index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7454
(F-2.332700252532959
F-1.7617965111365685
tp7455
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7456
(F-1.9481213713345462
F-1.7461380591759315
tp7457
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']\nreturn ('a' in a)"
p7458
(F-2.5544979388897238
F-1.718816903921274
tp7459
ssI1093322
(dp7460
S"import sys\nsys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7461
(F-4.093999862670898
F-2.6908192952473957
tp7462
sS"import sys\nsys.hexversion\n('%x' % sys.hexversion)"
p7463
(F-3.857008457183838
F-2.4986478169759114
tp7464
sS'import sys'
p7465
(F-4.060952186584473
F-2.266613260904948
tp7466
sS"('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7467
(F-4.288867726045496
F-2.8421394348144533
tp7468
sS'sys.hexversion'
p7469
(F-2.8334396362304686
F-2.491962687174479
tp7470
sS'sys.version_info'
p7471
(F-3.219700404575893
F-2.2851740519205728
tp7472
sS'print sys.version'
p7473
(F-3.051985422770182
F-2.275468444824219
tp7474
sS"('%x' % sys.hexversion)"
p7475
(F-3.9036322699652777
F-2.636174519856771
tp7476
sS'sys.version_info\nsys.hexversion'
p7477
(F-4.087160977450284
F-2.2926116943359376
tp7478
sS'import sys\nsys.hexversion'
p7479
(F-2.940765142440796
F-2.327063496907552
tp7480
sS'(python - V)'
p7481
(F-6.295175279889788
F-2.421734619140625
tp7482
sS"sys.hexversion\n('%x' % sys.hexversion)"
p7483
(F-4.266421391413762
F-2.681837209065755
tp7484
sS"sys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7485
(F-4.433302743094308
F-2.8259005228678387
tp7486
sS'(sys.hexversion < 33947648)'
p7487
(F-4.5276976691351996
F-2.6738436381022135
tp7488
sS'assert (sys.version_info >= (2, 5))'
p7489
(F-3.6473798751831055
F-2.4349706013997396
tp7490
ssI5618878
(dp7491
S"list1 = ['1', '2', '3']"
p7492
(F-2.0665997591885654
F-1.9367694854736328
tp7493
sS"list1 = ['1', '2', '3']\nstr1 = ''.join(list1)"
p7494
(F-1.6438106536865233
F-1.8825390338897705
tp7495
sS"L = ['L', 'O', 'L']\nmakeitastring = ''.join(map(str, L))"
p7496
(F-1.5512933349609375
F-1.8784120082855225
tp7497
sS"makeitastring = ''.join(map(str, L))"
p7498
(F-1.8561663309733072
F-1.8571562767028809
tp7499
sS"L = [1, 2, 3]\n' '.join((str(x) for x in L))\n'1 2 3'"
p7500
(F-2.21447806522764
F-1.9325391054153442
tp7501
sS'L = [1, 2, 3]'
p7502
(F-2.4192993857643823
F-2.011942148208618
tp7503
sS"str1 = ''.join(list1)"
p7504
(F-2.4371059417724608
F-1.8514561653137207
tp7505
sS"' '.join((str(x) for x in L))"
p7506
(F-1.5913851120892692
F-1.8226301670074463
tp7507
sS"str1 = ''.join((str(e) for e in list1))"
p7508
(F-2.0950494063527962
F-1.8427391052246094
tp7509
sS"list1 = [1, 2, 3]\nstr1 = ''.join((str(e) for e in list1))"
p7510
(F-1.963122663826778
F-1.9025671482086182
tp7511
sS'list1 = [1, 2, 3]'
p7512
(F-2.371278242631392
F-1.984413504600525
tp7513
sS"L = ['L', 'O', 'L']"
p7514
(F-2.11056848005815
F-1.9632248878479004
tp7515
sS"L = [1, 2, 3]\n' '.join((str(x) for x in L))"
p7516
(F-1.9400920161494501
F-1.9481213092803955
tp7517
sS"' '.join((str(x) for x in L))\n'1 2 3'"
p7518
(F-2.041177850020559
F-1.8270080089569092
tp7519
sS"'1 2 3'"
p7520
(F-5.396134694417317
F-2.193692922592163
tp7521
ssI3277503
(dp7522
S'array.append(line)'
p7523
(F-2.1033196449279785
F-2.461186981201172
tp7524
sS"with open('filename') as f:\n    lines = f.readlines()"
p7525
(F-0.8751612663269043
F-2.076597213745117
tp7526
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    pass"
p7527
(F-1.9219106476882408
F-2.1571367899576823
tp7528
sS'with open(fname) as f:\n    pass'
p7529
(F-1.717552730015346
F-2.2743804931640623
tp7530
sS"with open('file.txt', 'r') as ins:\n    pass"
p7531
(F-1.5764458179473877
F-2.234747568766276
tp7532
sS"with open('file.txt', 'r') as ins:\n    array = []"
p7533
(F-1.947288713957134
F-2.3022638956705728
tp7534
sS'for line in ins:\n    array.append(line)'
p7535
(F-1.7744536399841309
F-2.2370262145996094
tp7536
sS'array = []'
p7537
(F-3.4391148885091147
F-2.8307266235351562
tp7538
sS'content = f.readlines()'
p7539
(F-1.8906964196099176
F-2.3177940368652346
tp7540
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    array.append(line)"
p7541
(F-1.7945111218620748
F-2.1840052286783855
tp7542
sS'lines = f.readlines()'
p7543
(F-1.8653971354166667
F-2.1310614267985026
tp7544
sS'with open(fname) as f:\n    content = f.readlines()'
p7545
(F-1.4882539749145507
F-2.084402592976888
tp7546
sS"lines = [line.rstrip('\\n') for line in open('filename')]"
p7547
(F-1.2816748368112665
F-2.0665613810221353
tp7548
sS'for line in ins:\n    pass'
p7549
(F-1.9985599517822266
F-2.229567464192708
tp7550
sS"with open('filename') as f:\n    pass"
p7551
(F-1.154341152736119
F-2.261077117919922
tp7552
ssI5844672
(dp7553
S'def removekey(d, key):\n    r = dict(d)\ndel r[key]\nreturn r'
p7554
(F-2.6128297533307756
F-1.947875738143921
tp7555
sS'a'
p7556
(F-8.898893356323242
F-2.2785820960998535
tp7557
sS'del d[key]'
p7558
(F-2.8454456329345703
F-1.9248266220092773
tp7559
sS'del r[key]\nreturn r'
p7560
(F-4.051354598999024
F-1.908544659614563
tp7561
sS'{i: a[i] for i in a if (i != 0)}'
p7562
(F-2.814982223510742
F-1.9904413223266602
tp7563
sS'def removekey(d, key):\n    pass'
p7564
(F-1.6147684369768416
F-2.113001585006714
tp7565
sS'return r'
p7566
(F-5.328802108764648
F-2.400777816772461
tp7567
sS'a\n{i: a[i] for i in a if (i != 0)}'
p7568
(F-3.67404521595348
F-2.0289058685302734
tp7569
sS'def removekey(d, key):\n    r = dict(d)'
p7570
(F-2.013330158434416
F-1.967052698135376
tp7571
sS'{}'
p7572
(F-7.224952697753906
F-2.1227569580078125
tp7573
sS'def removekey(d, key):\n    r = dict(d)\ndel r[key]'
p7574
(F-2.4976901245117187
F-1.9499229192733765
tp7575
sS'del r[key]'
p7576
(F-3.5367973872593472
F-1.91213059425354
tp7577
sS'r = dict(d)'
p7578
(F-2.47072434425354
F-1.9273154735565186
tp7579
sS"'gdbye'"
p7580
(F-6.282381693522136
F-2.5617408752441406
tp7581
ssI16296643
(dp7582
S'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)\na[x][y] = 1'
p7583
(F-2.944050153096517
F-4.094926357269287
tp7584
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl\ntuple(l)"
p7585
(F-2.238293907859109
F-3.3997244834899902
tp7586
sS"t = ('my', 'name', 'is', 'mr', 'tuple')"
p7587
(F-1.5830902099609374
F-3.8182730674743652
tp7588
sS'y = ((mousex + cameraX) // 60)\na[x][y] = 1'
p7589
(F-2.811429231063179
F-3.756168842315674
tp7590
sS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)'
p7591
(F-3.118697718570107
F-4.183230400085449
tp7592
sS'tuple((tuple(i) for i in edited))'
p7593
(F-3.1932299296061197
F-3.4409592151641846
tp7594
sS'if (clicked[0] == 1):\n    pass'
p7595
(F-2.4025542736053467
F-4.398892402648926
tp7596
sS'tuple(itertools.imap(tuple, edited))'
p7597
(F-3.816835256723257
F-3.7337899208068848
tp7598
sS'map(list, level)'
p7599
(F-2.5340566635131836
F-3.4505434036254883
tp7600
sS'l\ntuple(l)'
p7601
(F-4.892608165740967
F-3.4354467391967773
tp7602
sS"l = ['my', 'name', 'is', 'mr', 'list']"
p7603
(F-1.6201685587565104
F-3.5152151584625244
tp7604
sS'a[x][y] = 1'
p7605
(F-2.328357869928533
F-3.48868727684021
tp7606
sS'level1 = [list(row) for row in level1]'
p7607
(F-3.348970685686384
F-3.727057933807373
tp7608
sS'a = numpy.array(level1)'
p7609
(F-3.8807441711425783
F-3.9842963218688965
tp7610
sS'list(t)'
p7611
(F-2.2011098861694336
F-3.53289532661438
tp7612
sS'level1 = map(list, level1)'
p7613
(F-4.485669708251953
F-4.26324987411499
tp7614
sS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt"
p7615
(F-2.6330945632036995
F-3.7939321994781494
tp7616
sS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)'
p7617
(F-2.972814706655649
F-4.179842472076416
tp7618
sS't\nlist(t)'
p7619
(F-5.482807636260986
F-3.5820446014404297
tp7620
sS'tuple(l)'
p7621
(F-2.3762477238972983
F-3.4367177486419678
tp7622
sS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt\nlist(t)"
p7623
(F-2.5756745771928267
F-3.6534292697906494
tp7624
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl"
p7625
(F-2.3774382647346046
F-3.457965135574341
tp7626
sS'a'
p7627
(F-9.008086522420248
F-3.737950325012207
tp7628
sS'a = numpy.array(level1)\na'
p7629
(F-4.92065970102946
F-3.9499073028564453
tp7630
sS'[list(i) for i in level]'
p7631
(F-2.2944463094075522
F-3.4818217754364014
tp7632
sS'x = ((mousey + cameraY) // 60)'
p7633
(F-3.0807723999023438
F-3.7842328548431396
tp7634
sS'l'
p7635
(F-9.488253911336264
F-3.561474323272705
tp7636
sS'y = ((mousex + cameraX) // 60)'
p7637
(F-3.1749431903545675
F-3.883540630340576
tp7638
sS't'
p7639
(F-10.000993092854818
F-3.899484634399414
tp7640
ssI4004550
(dp7641
S'floats = map(float, s.split())'
p7642
(F-2.33736446925572
F-2.426787185668945
tp7643
sS"s = '5.2 5.6 5.3'"
p7644
(F-3.206751251220703
F-2.7645843505859373
tp7645
sS'floats = [float(x) for x in s.split()]'
p7646
(F-1.7892184787326388
F-2.41005802154541
tp7647
sS"s = '5.2 5.6 5.3'\nfloats = [float(x) for x in s.split()]"
p7648
(F-1.8605403900146484
F-2.423563766479492
tp7649
ssI10543303
(dp7650
S'j = [4, 5, 6, 7, 1, 3, 7, 5]'
p7651
(F-2.2818094889322915
F-2.326045109675481
tp7652
sS'j = np.array(j)'
p7653
(F-2.9287269592285154
F-2.827616178072416
tp7654
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nsum(((i > 5) for i in j))'
p7655
(F-2.2181809743245444
F-2.2362566727858324
tp7656
sS'sum((j > i))'
p7657
(F-3.305462646484375
F-2.3480619283822866
tp7658
sS'len([1 for i in j if (i > 5)])'
p7659
(F-3.273463355170356
F-2.2757923419658956
tp7660
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nlen([1 for i in j if (i > 5)])'
p7661
(F-2.68532321327611
F-2.252691855797401
tp7662
sS'import numpy as np\nj = np.array(j)'
p7663
(F-2.30482915242513
F-2.8836840116060696
tp7664
sS'sum(((i > 5) for i in j))'
p7665
(F-2.4060487747192383
F-2.2543100210336537
tp7666
sS'import numpy as np'
p7667
(F-3.5564196904500327
F-2.9757038996769833
tp7668
sS'issubclass(bool, int)'
p7669
(F-3.2872979640960693
F-2.6340516897348256
tp7670
sS'import numpy as np\nj = np.array(j)\nsum((j > i))'
p7671
(F-2.7142814000447593
F-2.751858344444862
tp7672
sS'j = np.array(j)\nsum((j > i))'
p7673
(F-3.1121850264699837
F-2.7685711200420675
tp7674
ssI432842
(dp7675
S'return (bool(str1) ^ bool(str2))'
p7676
(F-3.5750816890171597
F-2.345453389485677
tp7677
sS'from operator import xor\nxor(bool(a), bool(b))'
p7678
(F-2.5167360807719983
F-2.3184918721516925
tp7679
sS'(bool(a) ^ bool(b))'
p7680
(F-3.3714546790489783
F-2.310474904378255
tp7681
sS'xor(bool(a), bool(b))'
p7682
(F-2.4740001133510043
F-2.3059102376302083
tp7683
sS'(bool(a) != bool(b))'
p7684
(F-3.2915191650390625
F-2.313171132405599
tp7685
sS'((a and (not b)) or ((not a) and b))'
p7686
(F-4.570903233119419
F-2.362322235107422
tp7687
sS'def logical_xor(str1, str2):\n    pass'
p7688
(F-2.5496277809143066
F-2.401301066080729
tp7689
sS'def logical_xor(str1, str2):\n    return (bool(str1) ^ bool(str2))'
p7690
(F-2.943759211787471
F-2.4062950134277346
tp7691
sS'from operator import xor'
p7692
(F-3.074747085571289
F-2.4648457845052083
tp7693
ssI1303243
(dp7694
S'(type(o) is str)'
p7695
(F-3.94542236328125
F-2.048027583530971
tp7696
sS'isinstance(o, str)'
p7697
(F-2.6256213188171387
F-1.9554337092808314
tp7698
sS'isinstance(o, basestring)'
p7699
(F-3.1589255332946777
F-1.9874341147286552
tp7700
sS'isinstance(obj_to_test, str)'
p7701
(F-3.3085619608561196
F-2.0036815915788924
tp7702
ssI163542
(dp7703
S'p.stdin.close()'
p7704
(F-1.184771219889323
F-3.096651349748884
tp7705
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p7706
(F-1.4105603253399883
F-3.089051019577753
tp7707
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7708
(F-1.9040756225585938
F-3.1012184506370906
tp7709
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p7710
(F-1.3404011581883286
F-3.1268782842726934
tp7711
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)"
p7712
(F-0.7421514070951022
F-3.1231289818173362
tp7713
sS'print grep_stdout.decode()'
p7714
(F-4.100870895385742
F-3.4024207705543157
tp7715
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p7716
(F-1.316742515563965
F-3.118782406761533
tp7717
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p7718
(F-0.8702878085049716
F-3.098603021530878
tp7719
sS'from subprocess import Popen, PIPE, STDOUT'
p7720
(F-2.233595275878906
F-3.155762445359003
tp7721
sS"pipe = os.popen(cmd, 'w', bufsize)\npipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin"
p7722
(F-3.1496412004743304
F-3.1124165852864585
tp7723
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p7724
(F-2.224408642999057
F-3.094757080078125
tp7725
sS'p.communicate()[0]'
p7726
(F-1.5759557723999023
F-3.1903199695405506
tp7727
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p7728
(F-1.2187823454538982
F-3.090045383998326
tp7729
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p7730
(F-0.8169049399239676
F-3.11008053734189
tp7731
sS"pipe = os.popen(cmd, 'w', bufsize)"
p7732
(F-3.0157192775181363
F-3.1320521036783853
tp7733
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p7734
(F-2.4138306598274077
F-3.057773771740141
tp7735
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p7736
(F-1.4772266588712994
F-3.1102752685546875
tp7737
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7738
(F-2.0445037841796876
F-3.0585755847749256
tp7739
sS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7740
(F-2.9709320068359375
F-3.158837454659598
tp7741
sS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p7742
(F-3.400907663198618
F-3.1514329456147694
tp7743
sS'p.communicate()[0]\np.stdin.close()'
p7744
(F-1.5283584594726562
F-3.0937412806919644
tp7745
sS'pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin'
p7746
(F-3.19556322964755
F-3.0994473411923362
tp7747
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p7748
(F-0.934256333571214
F-3.094823201497396
tp7749
ssI306400
(dp7750
S'second_random_item = list_of_random_items[1]'
p7751
(F-3.5537081824408636
F-1.8038525899251303
tp7752
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7753
(F-3.192201481309048
F-1.788189442952474
tp7754
sS'random_index = randrange(0, len(foo))\nprint foo[random_index]'
p7755
(F-3.059616752292799
F-1.7309766133626303
tp7756
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7757
(F-3.2862375743353547
F-1.8566271464029949
tp7758
sS'first_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7759
(F-3.177696010044643
F-1.7724405924479167
tp7760
sS'from random import randrange'
p7761
(F-3.5911887486775718
F-1.8253100077311197
tp7762
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7763
(F-3.2350336710611978
F-1.8492563883463542
tp7764
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7765
(F-3.2084827642331177
F-1.8338345845540365
tp7766
sS'print foo[random_index]'
p7767
(F-4.161455790201823
F-1.785607401529948
tp7768
sS'first_random_item = list_of_random_items[0]'
p7769
(F-3.379383299085829
F-1.7926256815592447
tp7770
sS'import random'
p7771
(F-4.81603479385376
F-2.010715357462565
tp7772
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p7773
(F-3.158632386405513
F-1.8605780283610025
tp7774
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))"
p7775
(F-2.0402239631204044
F-1.7398105621337892
tp7776
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7777
(F-3.2364964076450895
F-1.8434160868326823
tp7778
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p7779
(F-3.5352743530273436
F-1.952047602335612
tp7780
sS"foo = ['a', 'b', 'c', 'd', 'e']"
p7781
(F-1.6780799865722655
F-1.960747528076172
tp7782
sS'group_of_items = {1, 2, 3, 4}'
p7783
(F-3.413732640883502
F-1.9241043090820313
tp7784
sS'list_of_random_items = random.sample(group_of_items, num_to_select)'
p7785
(F-3.1028213500976562
F-1.7999629974365234
tp7786
sS"foo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p7787
(F-1.4076242861540422
F-1.7455493927001953
tp7788
sS'num_to_select = 2'
p7789
(F-4.1737111409505205
F-2.0686882019042967
tp7790
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p7791
(F-1.4948379810039814
F-1.7637163798014324
tp7792
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange"
p7793
(F-1.884749984741211
F-1.8383598327636719
tp7794
sS'from random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]'
p7795
(F-2.6904855455671037
F-1.744388961791992
tp7796
sS'import random\ngroup_of_items = {1, 2, 3, 4}'
p7797
(F-3.3652339935302735
F-1.9099747975667318
tp7798
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p7799
(F-3.2283294677734373
F-1.8735031127929687
tp7800
sS'from random import randrange\nrandom_index = randrange(0, len(foo))'
p7801
(F-2.6758712768554687
F-1.7541080474853517
tp7802
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p7803
(F-3.507047380719866
F-1.937762705485026
tp7804
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]"
p7805
(F-2.169690268380301
F-1.7330960591634115
tp7806
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7807
(F-3.216909969554228
F-1.810827382405599
tp7808
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']"
p7809
(F-1.859877692328559
F-1.944298807779948
tp7810
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7811
(F-3.3088678098192403
F-1.8180091857910157
tp7812
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7813
(F-3.1221608479817706
F-1.7911567687988281
tp7814
sS'print random.choice(foo)'
p7815
(F-2.5759065416124134
F-1.7799816131591797
tp7816
sS'random_index = randrange(0, len(foo))'
p7817
(F-2.9592356363932293
F-1.731414540608724
tp7818
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p7819
(F-3.343206517836627
F-1.843329620361328
tp7820
ssI3996904
(dp7821
S'print random.randint(0, 9)'
p7822
(F-1.7741198106245561
F-3.526781929863824
tp7823
sS'frand = uniform(0, 10)'
p7824
(F-2.3438690185546873
F-3.5461639828152127
tp7825
sS'irand = randrange(0, 10)'
p7826
(F-2.283775520324707
F-3.5511741638183594
tp7827
sS'import random'
p7828
(F-4.640979290008545
F-4.051016913519965
tp7829
sS'import random\nprint random.randint(0, 9)'
p7830
(F-1.4806810106549944
F-3.5350267622205944
tp7831
sS'from random import randrange, uniform'
p7832
(F-4.897382736206055
F-3.502521514892578
tp7833
sS'from random import randint\nprint randint(0, 9)'
p7834
(F-1.7962213243756975
F-3.58009762234158
tp7835
sS'from random import randrange, uniform\nirand = randrange(0, 10)'
p7836
(F-2.9792112462660847
F-3.507452223036024
tp7837
sS'print randint(0, 9)'
p7838
(F-2.452447679307726
F-3.6283976236979165
tp7839
sS'from random import randint'
p7840
(F-3.1517041524251304
F-3.64516364203559
tp7841
sS'random.randint(a, b)'
p7842
(F-2.3553340911865233
F-3.5425391727023654
tp7843
sS'irand = randrange(0, 10)\nfrand = uniform(0, 10)'
p7844
(F-2.1338573255037008
F-3.5017293294270835
tp7845
sS'from random import randrange, uniform\nirand = randrange(0, 10)\nfrand = uniform(0, 10)'
p7846
(F-2.5454342181865988
F-3.486172146267361
tp7847
ssI627435
(dp7848
S'global index\na.pop(index)'
p7849
(F-3.058768879283558
F-1.677063242594401
tp7850
sS'def __init__(self, items):\n    pass'
p7851
(F-1.5513839721679688
F-2.020394134521484
tp7852
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p7853
(F-1.479245682837258
F-1.691809590657552
tp7854
sS'def del_method():\n    global a'
p7855
(F-2.9553516932896207
F-2.05702756245931
tp7856
sS'a = range(10)\nindex = 3'
p7857
(F-3.4338413874308267
F-1.7459360758463542
tp7858
sS'def pop_method():\n    global a\nglobal index\na.pop(index)'
p7859
(F-3.496088663736979
F-1.9369210561116537
tp7860
sS'del a[index]'
p7861
(F-3.040947232927595
F-1.5391272226969401
tp7862
sS'global index\na = (a[:index] + a[(index + 1):])'
p7863
(F-3.1336898803710938
F-1.5465522766113282
tp7864
sS'def del_method():\n    global a\nglobal index'
p7865
(F-4.030505012063419
F-2.0431200663248696
tp7866
sS'index = 3\na = (a[:index] + a[(index + 1):])'
p7867
(F-2.96795166015625
F-1.5461696624755858
tp7868
sS'def slice_method():\n    global a\nglobal index\na = (a[:index] + a[(index + 1):])'
p7869
(F-3.442939139701225
F-1.6384465535481771
tp7870
sS'a\ndel a[(-1)]\na'
p7871
(F-5.585353306361607
F-1.5407754262288411
tp7872
sS'return foo((self.items + right.items))'
p7873
(F-3.8954388936360678
F-1.6452133178710937
tp7874
sS'a.pop(index)'
p7875
(F-2.3808400630950928
F-1.565267562866211
tp7876
sS'a.pop()'
p7877
(F-2.485274178641183
F-1.6425758361816407
tp7878
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])'
p7879
(F-1.4255129727450284
F-1.679267120361328
tp7880
sS'a = range(10)\na\ndel a[(-1)]'
p7881
(F-3.49213329114412
F-1.6045504252115885
tp7882
sS'a = [1, 2, 3, 4, 5, 6]\nindex = 3'
p7883
(F-2.0847916376023066
F-1.574884541829427
tp7884
sS'return foo(self.items[index])'
p7885
(F-3.090139071146647
F-1.6390174865722655
tp7886
sS'a = [1, 2, 3, 4, 5, 6]\nindex = 3\na = (a[:index] + a[(index + 1):])'
p7887
(F-2.2576956400057164
F-1.5470611572265625
tp7888
sS'a = (a[:index] + a[(index + 1):])'
p7889
(F-3.1125506446475075
F-1.596502685546875
tp7890
sS'class foo(object):\n    pass'
p7891
(F-2.0227457682291665
F-1.9507270812988282
tp7892
sS'a = range(10)\na\ndel a[(-1)]\na'
p7893
(F-4.247963678269159
F-1.6087642669677735
tp7894
sS'class foo(object):\n\n    def __init__(self, items):\n        pass'
p7895
(F-1.5232221163236177
F-1.8513445536295572
tp7896
sS'def slice_method():\n    global a\nglobal index'
p7897
(F-4.144802317899816
F-1.955682881673177
tp7898
sS'index = 3'
p7899
(F-4.652271270751953
F-1.752059809366862
tp7900
sS'a\ndel a[(-1)]'
p7901
(F-4.603610674540202
F-1.5373671213785807
tp7902
sS'def del_method():\n    pass'
p7903
(F-2.5153512221116285
F-2.188023885091146
tp7904
sS'a = range(10)\na'
p7905
(F-4.18468132019043
F-1.7546132405598958
tp7906
sS'a'
p7907
(F-8.977126439412435
F-1.7231295267740885
tp7908
sS'a.pop(1)'
p7909
(F-1.7168188095092773
F-1.6263582865397135
tp7910
sS'def slice_method():\n    global a'
p7911
(F-3.0775865827287947
F-1.9589374542236329
tp7912
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p7913
(F-2.0675497954746462
F-1.60230712890625
tp7914
sS'def pop_method():\n    global a'
p7915
(F-3.077009473528181
F-2.069940185546875
tp7916
sS'def del_method():\n    global a\nglobal index\ndel a[index]'
p7917
(F-3.596844548764436
F-1.736398696899414
tp7918
sS'a = range(10)'
p7919
(F-3.0448458194732666
F-1.7376141866048178
tp7920
sS'self.items = items'
p7921
(F-3.609118325369699
F-1.7191733042399089
tp7922
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    pass'
p7923
(F-1.4043939009956692
F-1.7090531667073567
tp7924
sS'global index\ndel a[index]'
p7925
(F-3.5044445037841796
F-1.5670249938964844
tp7926
sS'def __init__(self, items):\n    self.items = items'
p7927
(F-1.7670074462890626
F-1.7760635375976563
tp7928
sS'def pop_method():\n    pass'
p7929
(F-2.6628394493689904
F-2.1784741719563803
tp7930
sS'del a[(-1)]\na'
p7931
(F-4.668043772379558
F-1.5389561971028647
tp7932
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items'
p7933
(F-1.5234798431396483
F-1.7504707336425782
tp7934
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p7935
(F-1.733605074595256
F-1.685345967610677
tp7936
sS"a = ['a', 'b', 'c', 'd']\na.pop(1)"
p7937
(F-1.383542823791504
F-1.562884775797526
tp7938
sS'del a[(-1)]'
p7939
(F-3.1409534454345702
F-1.5369763692220053
tp7940
sS'global index'
p7941
(F-5.2850799560546875
F-1.922280248006185
tp7942
sS'def __getitem__(self, index):\n    return foo(self.items[index])'
p7943
(F-1.6432171630859376
F-1.6291982014973958
tp7944
sS'def __add__(self, right):\n    pass'
p7945
(F-1.9941771030426025
F-1.7997111002604167
tp7946
sS"a = ['a', 'b', 'c', 'd']\na.pop()"
p7947
(F-1.4770185570967824
F-1.568978500366211
tp7948
sS'def slice_method():\n    pass'
p7949
(F-2.637012481689453
F-2.008112589518229
tp7950
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p7951
(F-1.7149090650604992
F-1.6259902954101562
tp7952
sS"a = ['a', 'b', 'c', 'd']"
p7953
(F-1.7811362926776593
F-1.613228988647461
tp7954
sS'def __add__(self, right):\n    return foo((self.items + right.items))'
p7955
(F-2.594586508614676
F-1.681893539428711
tp7956
sS'def pop_method():\n    global a\nglobal index'
p7957
(F-4.144097720875459
F-2.054197057088216
tp7958
sS'global a'
p7959
(F-5.044841766357422
F-1.9117727915445963
tp7960
sS'a = [1, 2, 3, 4, 5, 6]'
p7961
(F-1.7929809794706457
F-1.5616602579752603
tp7962
sS'def __getitem__(self, index):\n    pass'
p7963
(F-1.5830037593841553
F-1.7483301798502604
tp7964
ssI1773805
(dp7965
S"with open('example.yaml') as stream:\n    pass"
p7966
(F-1.5780299050467355
F-1.8216008273037998
tp7967
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7968
(F-2.7030522057769497
F-1.7018855701793323
tp7969
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7970
(F-2.719942573879076
F-1.7049331665039062
tp7971
sS"with open('example.yaml', 'r') as stream:\n    pass"
p7972
(F-1.3781392574310303
F-1.8095507188276811
tp7973
sS'data_loaded = yaml.load(stream)'
p7974
(F-3.269474665323893
F-1.8752593994140625
tp7975
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p7976
(F-2.4251856310614226
F-1.7312729575417258
tp7977
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p7978
(F-2.781205264004794
F-1.721303939819336
tp7979
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p7980
(F-2.4970670427594865
F-1.6959448727694424
tp7981
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7982
(F-2.686144692557199
F-1.7172055677934126
tp7983
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p7984
(F-1.5783911618319424
F-1.7308561151677913
tp7985
sS'print exc'
p7986
(F-6.808890342712402
F-1.8401813507080078
tp7987
sS'import yaml'
p7988
(F-5.35953426361084
F-1.9289831681685015
tp7989
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p7990
(F-2.6767694573653373
F-1.7511411146684126
tp7991
sS"with open('data.yaml', 'r') as stream:\n    pass"
p7992
(F-1.3781392574310303
F-1.8095507188276811
tp7993
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p7994
(F-2.4137060820166742
F-1.7073291431773792
tp7995
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p7996
(F-2.7719222038022933
F-1.712461991743608
tp7997
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7998
(F-2.524248720994636
F-1.7330261577259412
tp7999
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8000
(F-2.6696305184994102
F-1.6982283158735796
tp8001
sS'import ruamel.yaml as yaml'
p8002
(F-5.061106204986572
F-1.9420852661132812
tp8003
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p8004
(F-2.742127221477918
F-1.7262328754771838
tp8005
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8006
(F-2.6275877721101333
F-1.7115568681196733
tp8007
sS'print (data == data_loaded)'
p8008
(F-4.2477256774902346
F-1.815502860329368
tp8009
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8010
(F-2.6697357532589936
F-1.7240409851074219
tp8011
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8012
(F-2.4499430656433105
F-1.693710673939098
tp8013
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8014
(F-2.8220701112851994
F-1.720340902155096
tp8015
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p8016
(F-2.5095605289234832
F-1.762130390514027
tp8017
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8018
(F-2.082016906738281
F-1.7493528886274858
tp8019
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p8020
(F-2.762241169557733
F-1.7146365425803445
tp8021
sS"import yaml\nwith open('example.yaml', 'r') as stream:\n    pass"
p8022
(F-1.698705974378084
F-1.749985088001598
tp8023
sS'yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)'
p8024
(F-3.718014717102051
F-1.9254027279940518
tp8025
sS'import io'
p8026
(F-5.34922456741333
F-1.8180521184747869
tp8027
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8028
(F-2.951585520868716
F-1.8056885112415662
tp8029
sS'print yaml.load(stream)'
p8030
(F-2.7613016764322915
F-1.7763078862970525
tp8031
sS'import yaml\nimport io'
p8032
(F-4.49035998753139
F-1.8597999919544568
tp8033
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8034
(F-3.0323635801977042
F-1.8091146295720881
tp8035
sS"import ruamel.yaml as yaml\nwith open('example.yaml') as stream:\n    pass"
p8036
(F-2.4653643653506325
F-1.7100089680064807
tp8037
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8038
(F-2.9959276775981105
F-1.8458942066539417
tp8039
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8040
(F-2.8038662181181064
F-1.7125920382412998
tp8041
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8042
(F-2.6487823486328126
F-1.6976505626331677
tp8043
ssI663171
(dp8044
S"x = 'Hello World!'"
p8045
(F-2.8459823608398436
F-1.8616085052490234
tp8046
sS'x[:2]\nx[:(-2)]\nx[(-2):]'
p8047
(F-3.5922772216796877
F-2.249381138728215
tp8048
sS'x[:(-2)]\nx[(-2):]'
p8049
(F-3.714265120656867
F-2.223376054030198
tp8050
sS'x[:2]'
p8051
(F-2.573195593697684
F-2.035752663245568
tp8052
sS'x[(-2):]\nx[2:(-2)]'
p8053
(F-3.9249336242675783
F-2.1768553807185245
tp8054
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]"
p8055
(F-3.5643857683454243
F-1.861878908597506
tp8056
sS'x[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8057
(F-3.6515595008587014
F-2.2444283412053037
tp8058
sS'x[:(-2)]'
p8059
(F-3.083880615234375
F-2.1165445767916164
tp8060
sS'x[2:]\nx[:2]'
p8061
(F-3.58553226177509
F-2.0943516951340895
tp8062
sS'x[:2]\nx[:(-2)]'
p8063
(F-3.17484712600708
F-2.1681370368370643
tp8064
sS"x = 'Hello World!'\nx[2:]\nx[:2]"
p8065
(F-3.157216464771944
F-1.7837078387920673
tp8066
sS'x[2:]'
p8067
(F-3.1684131622314453
F-1.9979550288273737
tp8068
sS"'H-e-l-l-o- -W-o-r-l-d'[::2]"
p8069
(F-3.015270233154297
F-1.7681190784160907
tp8070
sS'x[(-2):]'
p8071
(F-3.9806018829345704
F-2.083431977492112
tp8072
sS's = Substr(s, beginning, LENGTH)'
p8073
(F-4.243502616882324
F-2.136737823486328
tp8074
sS'x[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8075
(F-3.558817618233817
F-2.257295608520508
tp8076
sS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8077
(F-3.7217221143769055
F-2.246279056255634
tp8078
sS'some_string[::(-1)]'
p8079
(F-3.6728767981896033
F-1.7889542212853065
tp8080
sS"x = 'Hello World!'\nx[2:]"
p8081
(F-2.785726373845881
F-1.7574600806603065
tp8082
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]"
p8083
(F-3.5352708604600696
F-1.895889869103065
tp8084
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]"
p8085
(F-3.2963817302997294
F-1.8293726994441106
tp8086
sS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]'
p8087
(F-3.7973775556010585
F-2.2410901876596303
tp8088
sS'x[2:]\nx[:2]\nx[:(-2)]'
p8089
(F-3.5776172984730112
F-2.1736282935509315
tp8090
sS'x[2:(-2)]'
p8091
(F-3.312028711492365
F-2.0681309333214393
tp8092
sS's = s[beginning:(beginning + LENGTH)]'
p8093
(F-5.124299185616629
F-2.1237930884728065
tp8094
ssI1185524
(dp8095
S'str.lstrip()'
p8096
(F-2.833855220249721
F-4.0076352899724785
tp8097
sS'str.strip()\nstr.lstrip()'
p8098
(F-2.8900005634014425
F-3.973168806596236
tp8099
sS"s = '   foo    \\t   '"
p8100
(F-2.4075151443481446
F-4.007002743807706
tp8101
sS"s = s.strip(' \\t\\n\\r')"
p8102
(F-2.1470518112182617
F-3.991980119185014
tp8103
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8104
(F-1.9461039374856388
F-4.018643465909091
tp8105
sS"print pat.sub('', s)"
p8106
(F-2.566551381891424
F-4.004024158824574
tp8107
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8108
(F-1.8699297904968262
F-4.004861658269709
tp8109
sS"import re\nprint re.sub('[\\\\s+]', '', s)"
p8110
(F-0.8797581791877747
F-4.0181662819602275
tp8111
sS"print re.sub('[\\\\s+]', '', s)"
p8112
(F-1.2223673600416918
F-4.0206167047674
tp8113
sS's = s.lstrip()'
p8114
(F-2.74025387234158
F-3.9854257757013496
tp8115
sS'str.strip()'
p8116
(F-1.9226301738194056
F-4.019805214621804
tp8117
sS"pat = re.compile('\\\\s+')"
p8118
(F-1.5227148056030273
F-4.004637978293679
tp8119
sS"s = '  \\t a string example\\t  '"
p8120
(F-2.4075153350830076
F-4.007002743807706
tp8121
sS'str.rstrip()'
p8122
(F-2.4771107264927457
F-4.00432656028054
tp8123
sS'print s.strip()'
p8124
(F-2.4208805561065674
F-4.013976357199929
tp8125
sS'import re'
p8126
(F-4.176297664642334
F-4.04826528375799
tp8127
sS'str.lstrip()\nstr.rstrip()'
p8128
(F-3.3930898813100963
F-3.9542069868607954
tp8129
sS's = s.strip()'
p8130
(F-2.2625435723198786
F-3.9961565191095527
tp8131
sS"s = '   foo    \\t   '\nprint s.strip()"
p8132
(F-1.7065868377685547
F-3.9833627180619673
tp8133
sS"s = '  \\t a string example\\t  '\ns = s.strip()"
p8134
(F-1.9059847318209135
F-3.978433435613459
tp8135
sS's = s.rstrip()'
p8136
(F-2.5914213392469616
F-3.9698590365323154
tp8137
sS'str.strip()\nstr.lstrip()\nstr.rstrip()'
p8138
(F-3.0908857646741366
F-3.954111272638494
tp8139
sS'astringexample'
p8140
(F-7.430716832478841
F-4.26312880082564
tp8141
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8142
(F-1.5950686136881511
F-4.01348911632191
tp8143
sS"s = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8144
(F-1.9888660430908203
F-3.9812816273082388
tp8145
sS"import re\npat = re.compile('\\\\s+')"
p8146
(F-1.2954126504751353
F-4.011810996315696
tp8147
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8148
(F-2.3074793134416853
F-4.00758847323331
tp8149
sS"s = '  \\t  foo   \\t   bar \\t  '"
p8150
(F-2.4075153350830076
F-4.007002743807706
tp8151
ssI354038
(dp8152
S"b = '963spam'\nb.isdigit()"
p8153
(F-2.261760711669922
F-1.5504466162787542
tp8154
sS"a = '03523'\na.isdigit()\nb = '963spam'\nb.isdigit()"
p8155
(F-2.286406017485119
F-1.5689226786295574
tp8156
sS'a.isdigit()'
p8157
(F-2.193307876586914
F-1.5527588526407878
tp8158
sS"a = '03523'"
p8159
(F-3.3987152099609377
F-1.6554781595865886
tp8160
sS"a = '03523'\na.isdigit()\nb = '963spam'"
p8161
(F-2.804482014973958
F-1.5399688084920247
tp8162
sS"a.isdigit()\nb = '963spam'"
p8163
(F-3.4894384904341265
F-1.5402610566880968
tp8164
sS'b.isdigit()'
p8165
(F-2.3308655875069753
F-1.5483672883775499
tp8166
sS"b = '963spam'"
p8167
(F-3.5017059326171873
F-1.6762835184733074
tp8168
sS"a.isdigit()\nb = '963spam'\nb.isdigit()"
p8169
(F-2.559408748851103
F-1.5692812601725261
tp8170
sS"float('NaN')"
p8171
(F-2.3594589233398438
F-1.5230274200439453
tp8172
sS"a = '03523'\na.isdigit()"
p8173
(F-2.0954537825150923
F-1.5398168563842773
tp8174
ssI2600191
(dp8175
S'[1, 2, 3, 4, 1, 4, 1].count(1)'
p8176
(F-2.4711544730446557
F-1.7555067698160807
tp8177
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]"
p8178
(F-2.201869841544859
F-1.6298734029134114
tp8179
sS"l = ['a', 'b', 'b']"
p8180
(F-2.1434031399813565
F-1.8197588602701822
tp8181
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8182
(F-3.643907581676136
F-1.9672927856445312
tp8183
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))"
p8184
(F-2.3715246695059315
F-1.624201202392578
tp8185
sS'import timeit'
p8186
(F-6.663558006286621
F-2.116612752278646
tp8187
sS"l.count('a')\nl.count('b')"
p8188
(F-3.0184293111165363
F-1.7824251810709635
tp8189
sS'from collections import Counter\nCounter(l)'
p8190
(F-2.194150057705966
F-1.6059444427490235
tp8191
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8192
(F-4.076806270714962
F-1.81849365234375
tp8193
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8194
(F-1.5472344292534723
F-1.6405316670735677
tp8195
sS'from collections import Counter'
p8196
(F-3.1398404439290366
F-1.6887906392415364
tp8197
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8198
(F-1.6071955736945658
F-1.8745110829671223
tp8199
sS"l = ['a', 'b', 'b']\nfrom collections import Counter"
p8200
(F-1.9605185985565186
F-1.7087974548339844
tp8201
sS'Counter(l)'
p8202
(F-2.497002283732096
F-1.629030736287435
tp8203
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8204
(F-1.5450600710782139
F-1.6532943725585938
tp8205
sS"print 'count():   ', t2.repeat(repeat=3, number=10000)"
p8206
(F-4.045849968405331
F-1.8108287811279298
tp8207
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8208
(F-3.503419876098633
F-2.2600133260091146
tp8209
sS'dict(((x, l.count(x)) for x in set(l)))'
p8210
(F-2.4008466402689614
F-1.65250612894694
tp8211
sS"l.count('b')"
p8212
(F-2.8964810371398926
F-1.807184092203776
tp8213
sS"l = ['a', 'b', 'b']\nl.count('a')"
p8214
(F-2.005549536810981
F-1.7290692647298178
tp8215
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8216
(F-3.8597360090775923
F-1.8792803446451822
tp8217
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8218
(F-3.1112615145169773
F-2.1646654764811197
tp8219
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8220
(F-3.7868052891322543
F-1.9618006388346354
tp8221
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8222
(F-3.331275213332403
F-2.0880517323811847
tp8223
sS"l = ['a', 'b', 'b']\nl.count('a')\nl.count('b')"
p8224
(F-2.113556213378906
F-1.7142364501953125
tp8225
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8226
(F-3.521713892618815
F-2.1021947224934894
tp8227
sS"l.count('a')"
p8228
(F-2.8964810371398926
F-1.807184092203776
tp8229
sS'[[x, l.count(x)] for x in set(l)]'
p8230
(F-2.6009427025204612
F-1.6443289438883464
tp8231
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8232
(F-3.4795426993534484
F-1.9215044657389322
tp8233
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8234
(F-3.252324643342391
F-2.22063725789388
tp8235
sS"l = ['a', 'b', 'b']\nfrom collections import Counter\nCounter(l)"
p8236
(F-1.7639688764299666
F-1.6178287506103515
tp8237
sS'[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))'
p8238
(F-2.6902392994273794
F-1.6471122741699218
tp8239
sS'Counter(z)'
p8240
(F-2.914992650349935
F-1.669268544514974
tp8241
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8242
(F-1.6026890494606711
F-1.7754764556884766
tp8243
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8244
(F-3.42683842976888
F-2.1589144388834636
tp8245
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8246
(F-3.4981243426983175
F-2.132022221883138
tp8247
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8248
(F-4.007626701803768
F-1.8804293314615885
tp8249
ssI845058
(dp8250
S'def mapcount(filename):\n    pass'
p8251
(F-1.839511235555013
F-2.4698063243519175
tp8252
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8253
(F-2.218374992819393
F-2.5351298939098013
tp8254
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8255
(F-2.9853526076225387
F-2.3792190551757812
tp8256
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8257
(F-3.0063625428734757
F-2.3962535858154297
tp8258
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p8259
(F-2.5407025146484377
F-2.4315261840820312
tp8260
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8261
(F-3.065408679022305
F-2.409104433926669
tp8262
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8263
(F-2.983903055297398
F-2.3860404274680396
tp8264
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8265
(F-2.99044572814437
F-2.4167343486439097
tp8266
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8267
(F-2.771044921875
F-2.3852969082919033
tp8268
sS'lines = 0'
p8269
(F-5.298702621459961
F-2.4350915388627485
tp8270
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8271
(F-2.6696089258733786
F-2.4614618474786933
tp8272
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8273
(F-2.759144638523911
F-2.4001509926535864
tp8274
sS'from __future__ import with_statement'
p8275
(F-2.1838590621948244
F-2.479503631591797
tp8276
sS'return lines\n\ndef bufcount(filename):\n    pass'
p8277
(F-2.816772937774658
F-2.4587121443314985
tp8278
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p8279
(F-2.764900507889395
F-2.3929188468239526
tp8280
sS'def simplecount(filename):\n    pass'
p8281
(F-1.839511235555013
F-2.4698063243519175
tp8282
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8283
(F-2.9314994206504217
F-2.392426230690696
tp8284
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8285
(F-2.9808185801786533
F-2.3946075439453125
tp8286
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8287
(F-2.7945246157438857
F-2.3895795995538887
tp8288
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8289
(F-3.093364530396693
F-2.3698747808283027
tp8290
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8291
(F-1.6746725718180338
F-2.576806155118075
tp8292
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8293
(F-2.8751906010142543
F-2.4270022999156606
tp8294
sS"def mapcount(filename):\n    f = open(filename, 'r+')"
p8295
(F-1.8453501651161595
F-2.4674020247025923
tp8296
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8297
(F-2.9245493611491535
F-2.4129054329612036
tp8298
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8299
(F-2.6943348475864957
F-2.4722409681840376
tp8300
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8301
(F-2.2821623336437136
F-2.4287473505193535
tp8302
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8303
(F-2.964572794766606
F-2.3864676735617896
tp8304
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8305
(F-2.953488436612216
F-2.398710250854492
tp8306
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p8307
(F-2.600052969796317
F-2.520949277010831
tp8308
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8309
(F-2.649695676915786
F-2.4592288624156606
tp8310
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8311
(F-2.9596072812623615
F-2.353961771184748
tp8312
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8313
(F-3.083936840707805
F-2.3984127044677734
tp8314
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass'
p8315
(F-3.2374646222149885
F-2.3518139232288706
tp8316
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8317
(F-3.0144562052789134
F-2.403274189342152
tp8318
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8319
(F-3.1513943917410714
F-2.3986117623069068
tp8320
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8321
(F-3.1985969312263256
F-2.379325173117898
tp8322
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8323
(F-2.901211282481318
F-2.412843010642312
tp8324
sS'readline = buf.readline'
p8325
(F-7.322951180594308
F-2.3499537381258877
tp8326
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8327
(F-1.9598101565712376
F-2.4664089896462182
tp8328
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8329
(F-2.572601061909139
F-2.469397631558505
tp8330
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8331
(F-3.284729709514993
F-2.3775020946155894
tp8332
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p8333
(F-1.7215750558035714
F-2.4337839646772905
tp8334
sS"print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8335
(F-3.4119171142578124
F-2.618756901134144
tp8336
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8337
(F-3.037173093020261
F-2.3658405650745737
tp8338
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8339
(F-2.4367357889811196
F-2.459562821821733
tp8340
sS'return lines\n\ndef simplecount(filename):\n    lines = 0'
p8341
(F-3.460290061102973
F-2.439332441850142
tp8342
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8343
(F-2.8674100240071616
F-2.394035512750799
tp8344
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8345
(F-3.520714364400724
F-2.309549158269709
tp8346
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8347
(F-3.109324008603639
F-2.399921937422319
tp8348
sS'pass'
p8349
(F-3.0497105916341147
F-2.524048545143821
tp8350
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8351
(F-3.1725649761064405
F-2.3866121118718926
tp8352
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8353
(F-3.0670419088224086
F-2.3845625790682705
tp8354
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8355
(F-2.7708514873798076
F-2.444385528564453
tp8356
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8357
(F-2.914767663455704
F-2.4020538330078125
tp8358
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8359
(F-3.167034662257858
F-2.384619105945934
tp8360
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p8361
(F-3.4331486540020637
F-2.4011693434281782
tp8362
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8363
(F-2.8264846046372214
F-2.4028315110640093
tp8364
sS'lines += 1'
p8365
(F-4.158438110351563
F-2.4184161099520596
tp8366
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8367
(F-3.450237616177263
F-2.3522349270907315
tp8368
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8369
(F-2.9361489785684123
F-2.399030858820135
tp8370
sS"f = open(filename, 'r+')"
p8371
(F-2.4140384674072264
F-2.436865373091264
tp8372
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8373
(F-2.7356598286689082
F-2.4069692438299004
tp8374
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8375
(F-3.179200219326332
F-2.3920340104536577
tp8376
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8377
(F-2.6606832650991588
F-2.4057050184770064
tp8378
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8379
(F-3.1635516050050585
F-2.3910994096235796
tp8380
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8381
(F-2.8494606711647728
F-2.39993632923473
tp8382
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8383
(F-3.001310909495634
F-2.3928085673939097
tp8384
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8385
(F-3.0024053955078127
F-2.378965204412287
tp8386
sS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8387
(F-4.297274271647136
F-2.3349245244806465
tp8388
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p8389
(F-4.7199524589206865
F-2.3623390197753906
tp8390
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8391
(F-3.1869682065902216
F-2.380369533192028
tp8392
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8393
(F-2.3088097085758132
F-2.4194760756059126
tp8394
sS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8395
(F-3.1002617660833867
F-2.5819657065651636
tp8396
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8397
(F-2.9093969544368004
F-2.3957467512650923
tp8398
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8399
(F-3.021438396974807
F-2.397958755493164
tp8400
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8401
(F-3.0743240848664315
F-2.3970987146550957
tp8402
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8403
(F-3.081138849258423
F-2.377574920654297
tp8404
sS'buf = mmap.mmap(f.fileno(), 0)'
p8405
(F-2.8767848014831543
F-2.3969121412797407
tp8406
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8407
(F-2.8041180419921874
F-2.408369931307706
tp8408
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8409
(F-3.1968004563275505
F-2.3929207541725854
tp8410
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8411
(F-2.9841196060180666
F-2.3994423259388316
tp8412
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8413
(F-2.859565869658238
F-2.3877038088711826
tp8414
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8415
(F-2.077474335093557
F-2.5297809947620737
tp8416
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8417
(F-2.916143629286024
F-2.375978123057972
tp8418
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8419
(F-2.974443624575679
F-2.3824214935302734
tp8420
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8421
(F-3.2591688855946495
F-2.356834064830433
tp8422
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8423
(F-3.248105135830966
F-2.359685551036488
tp8424
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p8425
(F-2.601593017578125
F-2.393650921908292
tp8426
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8427
(F-3.017693387545072
F-2.39211724021218
tp8428
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8429
(F-3.2574691772460938
F-2.3794810555197974
tp8430
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8431
(F-3.043375172334559
F-2.3955041711980645
tp8432
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8433
(F-2.84722883051092
F-2.4178329814564097
tp8434
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8435
(F-2.945626553622159
F-2.374483281915838
tp8436
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8437
(F-2.510841123519405
F-2.442892247980291
tp8438
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8439
(F-3.0601278165491617
F-2.395915464921431
tp8440
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8441
(F-3.3311250647720025
F-2.3595659082586113
tp8442
sS'read_f = f.read'
p8443
(F-5.2119945949978295
F-2.4113391529430044
tp8444
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8445
(F-2.8742540147569446
F-2.3936939239501953
tp8446
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8447
(F-2.96398388499945
F-2.3948854966597124
tp8448
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8449
(F-3.582821273803711
F-2.3310800032182173
tp8450
sS'buf = read_f(buf_size)\nreturn lines'
p8451
(F-3.993536122639974
F-2.327638799493963
tp8452
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8453
(F-3.085820212293027
F-2.391742706298828
tp8454
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline'
p8455
(F-4.182002727801983
F-2.4052999669855293
tp8456
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8457
(F-2.9526552215335875
F-2.411796223033558
tp8458
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p8459
(F-2.8323351326635327
F-2.404076662930575
tp8460
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8461
(F-3.0151820107111855
F-2.3899796225807886
tp8462
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8463
(F-3.2500958712595813
F-2.3549014004794033
tp8464
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8465
(F-3.3607965284778225
F-2.354460282759233
tp8466
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p8467
(F-2.892908913748605
F-2.415648720481179
tp8468
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8469
(F-2.8253871372767856
F-2.388905785300515
tp8470
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8471
(F-2.7186156242124495
F-2.4915062297474253
tp8472
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8473
(F-3.0515028211805557
F-2.3896231217817827
tp8474
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8475
(F-3.005895700421713
F-2.3781084580854936
tp8476
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8477
(F-2.995035921589712
F-2.348766500299627
tp8478
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8479
(F-2.596497479607077
F-2.425630049272017
tp8480
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8481
(F-2.823638383732286
F-2.3908824920654297
tp8482
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8483
(F-3.0488874912261963
F-2.3693082982843574
tp8484
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8485
(F-3.054460466114295
F-2.3773176019841973
tp8486
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8487
(F-3.2129519848113364
F-2.3791568062522193
tp8488
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8489
(F-2.454089106345663
F-2.4618185216730293
tp8490
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8491
(F-3.064261484954317
F-2.3854106556285513
tp8492
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8493
(F-3.1070021827622214
F-2.3810450813987036
tp8494
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8495
(F-3.694669451032366
F-2.332615765658292
tp8496
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8497
(F-3.1470541080958405
F-2.3917402787642046
tp8498
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8499
(F-3.0072638329039227
F-2.3991893421519888
tp8500
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8501
(F-3.361657419512349
F-2.374142039905895
tp8502
sS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8503
(F-3.4174103275422127
F-2.512609135020863
tp8504
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p8505
(F-3.9674588371725643
F-2.3545013774525034
tp8506
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8507
(F-2.3260514454175065
F-2.491737885908647
tp8508
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8509
(F-3.1169143304592226
F-2.3781679326837715
tp8510
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8511
(F-3.393065289753239
F-2.364908391779119
tp8512
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8513
(F-3.8292437962123325
F-2.294891184026545
tp8514
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8515
(F-2.9186105439157197
F-2.39324951171875
tp8516
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8517
(F-2.9978058283230125
F-2.403249220414595
tp8518
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8519
(F-3.1085364539344034
F-2.407128247347745
tp8520
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8521
(F-2.9463280943867556
F-2.387604453346946
tp8522
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8523
(F-2.9493146270875505
F-2.408496683294123
tp8524
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8525
(F-3.143363052273389
F-2.381563186645508
tp8526
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8527
(F-2.903169837364784
F-2.408709092573686
tp8528
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8529
(F-2.9779174148395495
F-2.4197037436745386
tp8530
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8531
(F-2.609581234580592
F-2.4226349917325107
tp8532
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8533
(F-3.158868577745226
F-2.3699913024902344
tp8534
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8535
(F-3.805875311957465
F-2.2905797091397373
tp8536
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8537
(F-2.695561726888021
F-2.4472472450949927
tp8538
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8539
(F-3.4996707665659215
F-2.363448056307706
tp8540
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8541
(F-3.282197788783482
F-2.3998713059858843
tp8542
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p8543
(F-3.517884996202257
F-2.3837658275257456
tp8544
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8545
(F-3.0339006246979703
F-2.359575791792436
tp8546
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8547
(F-3.0843968155360457
F-2.383670460094105
tp8548
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8549
(F-2.909781265258789
F-2.3953229730779473
tp8550
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p8551
(F-2.226321467646846
F-2.4025556390935723
tp8552
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8553
(F-2.911740417480469
F-2.408937627618963
tp8554
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p8555
(F-3.868655734592014
F-2.3725365725430576
tp8556
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8557
(F-3.2518007020692568
F-2.388528650457209
tp8558
sS'read_f = f.read\nbuf = read_f(buf_size)'
p8559
(F-4.509249877929688
F-2.3749561309814453
tp8560
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8561
(F-3.1434534637021345
F-2.393366726962003
tp8562
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8563
(F-3.0119327659770656
F-2.40394418889826
tp8564
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8565
(F-3.2089367541638047
F-2.374684767289595
tp8566
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8567
(F-3.1258447391470683
F-2.3694881092418325
tp8568
sS'import mmap\nimport random\nfrom collections import defaultdict'
p8569
(F-3.2116883595784507
F-2.4243521256880327
tp8570
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8571
(F-3.617566144024884
F-2.3142982829700816
tp8572
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8573
(F-2.872730166413063
F-2.3898873762650923
tp8574
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8575
(F-2.909798000169837
F-2.383372740312056
tp8576
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8577
(F-2.9828038533528645
F-2.397127324884588
tp8578
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8579
(F-2.836640343299279
F-2.4086043617942114
tp8580
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8581
(F-2.4244647392859826
F-2.5290700739080254
tp8582
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict'
p8583
(F-3.069593811035156
F-2.4235097711736504
tp8584
sS'buf_size = (1024 * 1024)\nread_f = f.read'
p8585
(F-4.76529251901727
F-2.360544378107244
tp8586
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random'
p8587
(F-2.807748694168894
F-2.437679810957475
tp8588
sS"lines += buf.count('\\n')"
p8589
(F-3.750932312011719
F-2.4598839499733667
tp8590
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8591
(F-3.0188868045806885
F-2.4043825322931465
tp8592
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict'
p8593
(F-2.5048009554545083
F-2.432068564675071
tp8594
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8595
(F-2.930813716008113
F-2.4006534923206675
tp8596
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8597
(F-3.379448820415296
F-2.3571548461914062
tp8598
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8599
(F-2.378659889914773
F-2.4819101853804155
tp8600
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8601
(F-3.1457030010707485
F-2.376146663318981
tp8602
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8603
(F-3.137594699859619
F-2.3911411978981714
tp8604
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8605
(F-2.5098782141231797
F-2.4758963151411577
tp8606
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8607
(F-3.259756261652166
F-2.376413171941584
tp8608
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8609
(F-2.4161667823791504
F-2.4553565979003906
tp8610
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    start_time = time.time()'
p8611
(F-2.392672786006221
F-2.4598182331431997
tp8612
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8613
(F-2.8895967717756306
F-2.4202454306862573
tp8614
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8615
(F-2.6332161756065804
F-2.4765729037198154
tp8616
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8617
(F-3.47283751389076
F-2.3586772571910513
tp8618
sS'read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8619
(F-3.7776778084891185
F-2.316640333695845
tp8620
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8621
(F-3.0685979908910292
F-2.3656428943980825
tp8622
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8623
(F-3.2243712625385803
F-2.3807674754749644
tp8624
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8625
(F-3.44844970703125
F-2.4005440798672764
tp8626
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8627
(F-3.9085548400878904
F-2.3036844080144707
tp8628
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8629
(F-3.5363513081013656
F-2.3507936651056465
tp8630
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8631
(F-3.2406735110592533
F-2.355518341064453
tp8632
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8633
(F-2.626610677750384
F-2.436695792458274
tp8634
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p8635
(F-4.02428476434005
F-2.3775707591663706
tp8636
sS'readline = buf.readline\nwhile readline():\n    lines += 1'
p8637
(F-5.090329621967516
F-2.3171360709450464
tp8638
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8639
(F-2.955962169019482
F-2.3826675415039062
tp8640
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8641
(F-2.8895325199250252
F-2.3965707258744673
tp8642
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8643
(F-3.1459623877681904
F-2.3895938179709693
tp8644
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8645
(F-3.1903350830078123
F-2.4076851931485264
tp8646
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8647
(F-3.0173762784459286
F-2.3893876509232954
tp8648
sS"num_lines = sum((1 for line in open('myfile.txt')))"
p8649
(F-3.230017812628495
F-2.5811777981844815
tp8650
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8651
(F-3.0245240599244507
F-2.418020421808416
tp8652
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8653
(F-2.900137108492564
F-2.3943790089000356
tp8654
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8655
(F-3.14544388620477
F-2.394190874966708
tp8656
sS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8657
(F-3.8674203973067436
F-2.306374289772727
tp8658
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p8659
(F-4.053775024414063
F-2.372060949152166
tp8660
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8661
(F-2.905748386838737
F-2.3767840645530005
tp8662
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8663
(F-3.1163132240032327
F-2.390036843039773
tp8664
sS'for (key, vals) in counts.items():\n    pass'
p8665
(F-2.231768959446957
F-2.681510231711648
tp8666
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p8667
(F-3.238973396975978
F-2.3889487873424184
tp8668
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8669
(F-2.9763914538967993
F-2.4169079173694956
tp8670
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8671
(F-3.40122798039363
F-2.330350702459162
tp8672
sS'with open(fname) as f:\n    pass'
p8673
(F-1.891373634338379
F-2.398720481178977
tp8674
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8675
(F-2.98372309681647
F-2.3871720053932886
tp8676
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8677
(F-2.8987989977980213
F-2.3947419253262607
tp8678
sS'readline = buf.readline\nwhile readline():\n    pass'
p8679
(F-4.786210452809053
F-2.3120568015358667
tp8680
sS'for i in range(5):\n    pass'
p8681
(F-1.2579073224748885
F-2.43579084222967
tp8682
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8683
(F-3.2539035252162387
F-2.406942540949041
tp8684
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8685
(F-3.6771519978841147
F-2.367525274103338
tp8686
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8687
(F-3.0130698955164545
F-2.400624015114524
tp8688
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8689
(F-2.647534019068668
F-2.4272287542169746
tp8690
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8691
(F-3.636802978515625
F-2.3127066872336646
tp8692
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8693
(F-3.3486636126482927
F-2.2886168740012427
tp8694
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8695
(F-2.8237235216590446
F-2.411479949951172
tp8696
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8697
(F-3.153796932561611
F-2.369369160045277
tp8698
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8699
(F-3.0449374272273135
F-2.3812971982088955
tp8700
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p8701
(F-3.0896741462476327
F-2.3779964447021484
tp8702
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8703
(F-3.2262860107421876
F-2.4108843369917436
tp8704
sS'counts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass'
p8705
(F-2.8530735113681893
F-2.666147232055664
tp8706
sS'lines = 0\nbuf_size = (1024 * 1024)'
p8707
(F-4.679615275065104
F-2.316905281760476
tp8708
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8709
(F-3.330822385590652
F-2.3817114396528765
tp8710
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8711
(F-2.8833264337069746
F-2.385923212224787
tp8712
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8713
(F-3.333822076970881
F-2.385856281627308
tp8714
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8715
(F-2.9240617423221984
F-2.391847783868963
tp8716
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p8717
(F-2.6657949748792147
F-2.364992315118963
tp8718
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8719
(F-3.961522783551897
F-2.2921683571555396
tp8720
sS"while buf:\n    lines += buf.count('\\n')"
p8721
(F-2.968421459197998
F-2.299973401156339
tp8722
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8723
(F-3.2971422244340944
F-2.358983646739613
tp8724
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8725
(F-3.4211027893839003
F-2.3319102200594815
tp8726
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8727
(F-2.8975607862750303
F-2.4088387922807173
tp8728
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8729
(F-2.892377614068441
F-2.413747267289595
tp8730
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8731
(F-3.2441256009615387
F-2.3924740878018467
tp8732
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p8733
(F-4.227195739746094
F-2.3557180924849077
tp8734
sS'lines = 0\nreadline = buf.readline'
p8735
(F-5.896487149325284
F-2.4031231620094995
tp8736
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8737
(F-3.148857607478984
F-2.378366296941584
tp8738
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8739
(F-2.904356051217481
F-2.390233126553622
tp8740
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p8741
(F-2.6988763248219207
F-2.3854380520907315
tp8742
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p8743
(F-1.9864942762586806
F-2.4497916481711646
tp8744
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8745
(F-2.450071334838867
F-2.447035702792081
tp8746
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p8747
(F-3.0711326599121094
F-2.377391815185547
tp8748
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8749
(F-3.494269249423238
F-2.363687688654119
tp8750
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8751
(F-3.1179610336382773
F-2.381582086736506
tp8752
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8753
(F-3.2369294885086686
F-2.406250693581321
tp8754
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p8755
(F-4.705603166060015
F-2.3288007216020064
tp8756
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8757
(F-3.4971755113058944
F-2.3727540102871982
tp8758
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8759
(F-3.4796206825657894
F-2.3283179890025747
tp8760
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8761
(F-3.2562679714626737
F-2.3663631785999644
tp8762
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8763
(F-2.9551426729709984
F-2.382979999889027
tp8764
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8765
(F-2.202306287042026
F-2.3937596407803623
tp8766
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8767
(F-2.8977689389829284
F-2.3850489529696377
tp8768
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8769
(F-2.994648147841631
F-2.3760015314275567
tp8770
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8771
(F-2.9375160835884713
F-2.39394118569114
tp8772
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8773
(F-3.2569099984517913
F-2.3204964724454014
tp8774
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8775
(F-3.0358802208533655
F-2.399253151633523
tp8776
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8777
(F-2.583022291642906
F-2.5224233107133345
tp8778
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8779
(F-3.5115061442057294
F-2.32737211747603
tp8780
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8781
(F-3.33807373046875
F-2.40968825600364
tp8782
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8783
(F-3.193229489210175
F-2.3834159157492896
tp8784
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8785
(F-2.8565013918102298
F-2.4165918176824395
tp8786
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8787
(F-3.1730418655107604
F-2.3451283194802026
tp8788
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8789
(F-3.6457965327244177
F-2.3821900107643823
tp8790
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8791
(F-2.974279416487521
F-2.375830737027255
tp8792
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p8793
(F-2.5180529330639128
F-2.4327572909268467
tp8794
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8795
(F-3.3024913859817215
F-2.3158728859641333
tp8796
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8797
(F-2.94204259801794
F-2.424096540971236
tp8798
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8799
(F-3.4873570033482144
F-2.377926913174716
tp8800
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p8801
(F-1.895934566374748
F-2.426788330078125
tp8802
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8803
(F-3.4449077061244417
F-2.400648984042081
tp8804
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8805
(F-2.4220721312243527
F-2.4680083881724966
tp8806
sS'from collections import defaultdict'
p8807
(F-3.245903968811035
F-2.4812687960538
tp8808
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8809
(F-2.9281164781102595
F-2.396696090698242
tp8810
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8811
(F-3.003137257473528
F-2.3794479370117188
tp8812
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8813
(F-3.0822571476447185
F-2.3685366890647193
tp8814
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8815
(F-3.587878578587582
F-2.3006355979225854
tp8816
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8817
(F-3.134664101175743
F-2.4278215928511186
tp8818
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8819
(F-3.086759779188368
F-2.3707570162686435
tp8820
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8821
(F-3.084684164217203
F-2.408323808149858
tp8822
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8823
(F-3.3034141177222844
F-2.3577821904962715
tp8824
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8825
(F-2.7940018417051173
F-2.3889342221346768
tp8826
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8827
(F-3.0779453889104245
F-2.3912922252308237
tp8828
sS'for line in open(filename):\n    lines += 1\nreturn lines'
p8829
(F-2.50641531693308
F-2.478155482899059
tp8830
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8831
(F-3.231682550339472
F-2.3252247897061435
tp8832
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p8833
(F-2.265103547469429
F-2.5089106126265093
tp8834
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8835
(F-2.591325006565126
F-2.406307567249645
tp8836
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8837
(F-3.3089382127783766
F-2.369980725375089
tp8838
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8839
(F-3.2597565569196427
F-2.3705272674560547
tp8840
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8841
(F-3.507162094116211
F-2.351043874567205
tp8842
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8843
(F-3.0592791703495665
F-2.388329419222745
tp8844
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8845
(F-2.8223304028780953
F-2.349777568470348
tp8846
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8847
(F-3.4270963013627145
F-2.3638423572887075
tp8848
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8849
(F-3.5576558850475193
F-2.373031269420277
tp8850
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8851
(F-3.2770565032958983
F-2.3703186728737573
tp8852
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    pass'
p8853
(F-2.0199512682462992
F-2.613872528076172
tp8854
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p8855
(F-3.7540086226029827
F-2.3791670365767046
tp8856
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8857
(F-3.0286042811506886
F-2.420207803899592
tp8858
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8859
(F-3.0548217221083145
F-2.396684473211115
tp8860
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p8861
(F-2.569743589921431
F-2.441626115278764
tp8862
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8863
(F-3.094296233822601
F-2.388253992254084
tp8864
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8865
(F-2.929417784784881
F-2.3824386596679688
tp8866
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8867
(F-3.1765979585193453
F-2.3822860717773438
tp8868
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8869
(F-2.7423026344992896
F-2.3892376639626245
tp8870
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8871
(F-2.9394591614440246
F-2.3676834106445312
tp8872
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8873
(F-3.4593497828433386
F-2.3661714033647017
tp8874
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p8875
(F-3.2701351084607713
F-2.3868555589155718
tp8876
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8877
(F-3.5655635780012105
F-2.3082603107799184
tp8878
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8879
(F-2.949667478862562
F-2.375830043445934
tp8880
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8881
(F-2.9285802067937077
F-2.3882687308571557
tp8882
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8883
(F-3.0501708984375
F-2.371101726185192
tp8884
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8885
(F-2.9001591714580406
F-2.368207584727894
tp8886
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8887
(F-2.4625917322495403
F-2.4494247436523438
tp8888
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8889
(F-3.2622583974706063
F-2.3687414689497515
tp8890
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8891
(F-3.5596202503551138
F-2.4030636874112217
tp8892
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8893
(F-3.5061401859406502
F-2.3427595658735796
tp8894
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8895
(F-3.52832926126351
F-2.3522193215110083
tp8896
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8897
(F-2.8283137107382017
F-2.4303868033669214
tp8898
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8899
(F-2.8630367881373355
F-2.4095767628062856
tp8900
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8901
(F-3.216695699605856
F-2.369198192249645
tp8902
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8903
(F-2.942514656415952
F-2.40901010686701
tp8904
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8905
(F-2.3061079025268554
F-2.438365936279297
tp8906
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8907
(F-2.8538829258510043
F-2.3959244814786045
tp8908
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8909
(F-2.868371087151605
F-2.36923564564098
tp8910
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8911
(F-2.7163753869398586
F-2.419147664850408
tp8912
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8913
(F-3.261004638671875
F-2.401590520685369
tp8914
sS'while readline():\n    lines += 1\nreturn lines'
p8915
(F-3.4568793773651123
F-2.321290449662642
tp8916
sS'def simplecount(filename):\n    lines = 0'
p8917
(F-2.8278876713344028
F-2.43503154407848
tp8918
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8919
(F-2.8994981719226374
F-2.430790987881747
tp8920
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8921
(F-2.928603172302246
F-2.4619875821200283
tp8922
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8923
(F-3.7428258779097576
F-2.337548342618075
tp8924
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8925
(F-3.557040744357639
F-2.367240212180398
tp8926
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0'
p8927
(F-2.9281151181175593
F-2.454811616377397
tp8928
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p8929
(F-1.6846885681152344
F-2.452520890669389
tp8930
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8931
(F-3.0075115238854644
F-2.4172902540727095
tp8932
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8933
(F-3.3632775668440194
F-2.3390050367875532
tp8934
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8935
(F-3.392979672080592
F-2.3371353149414062
tp8936
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8937
(F-2.9763588806405603
F-2.4043738625266333
tp8938
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8939
(F-2.9184316197258027
F-2.4095112193714487
tp8940
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8941
(F-2.883843414974909
F-2.3947056857022373
tp8942
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8943
(F-2.7933464603147646
F-2.41369646245783
tp8944
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8945
(F-2.7768172760923466
F-2.4061894850297407
tp8946
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8947
(F-2.9484442995305646
F-2.4597923972389917
tp8948
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8949
(F-2.8710848250479066
F-2.4027364904230293
tp8950
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8951
(F-3.6049019949776784
F-2.3778759349476206
tp8952
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8953
(F-2.832870674133301
F-2.378008582375266
tp8954
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8955
(F-3.605303692561324
F-2.3664377385919746
tp8956
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8957
(F-3.1129502360026042
F-2.3648079958829014
tp8958
sS'for line in open(filename):\n    lines += 1'
p8959
(F-2.463970899581909
F-2.4946280392733486
tp8960
sS'return lines'
p8961
(F-4.622260093688965
F-2.437549591064453
tp8962
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8963
(F-3.2162502212012374
F-2.3779381838711826
tp8964
sS'counts[func].append((time.time() - start_time))'
p8965
(F-3.0019117082868303
F-2.5491844524036753
tp8966
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8967
(F-3.0971805505585253
F-2.4066512367942114
tp8968
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p8969
(F-2.267170030243543
F-2.4529025337912818
tp8970
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8971
(F-3.5325860595703125
F-2.3664819544011895
tp8972
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8973
(F-3.0555370189525464
F-2.3684059489857066
tp8974
sS'import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p8975
(F-1.6532345726376487
F-2.46377251364968
tp8976
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p8977
(F-4.528249104817708
F-2.3461862043900923
tp8978
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8979
(F-3.0234005267803488
F-2.402685685591264
tp8980
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8981
(F-3.1034331081965782
F-2.396524602716619
tp8982
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8983
(F-2.9541843060365656
F-2.409144488247958
tp8984
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8985
(F-2.9982493386339786
F-2.378294511274858
tp8986
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8987
(F-3.237400599888393
F-2.4084646051580254
tp8988
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8989
(F-3.1920660400390624
F-2.3786121715198862
tp8990
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8991
(F-3.1635342368596717
F-2.378673553466797
tp8992
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8993
(F-3.085562313304228
F-2.343387083573775
tp8994
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8995
(F-3.1033055291103957
F-2.384348089044744
tp8996
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8997
(F-2.834255279704211
F-2.408842086791992
tp8998
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8999
(F-3.1797787173763736
F-2.3907817493785513
tp9000
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9001
(F-2.985004513762718
F-2.4188482111150567
tp9002
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9003
(F-2.7636037726151317
F-2.377558794888583
tp9004
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9005
(F-2.006355794270833
F-2.5151797207919033
tp9006
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9007
(F-3.3235209307332676
F-2.3574839505282315
tp9008
sS'return (i + 1)'
p9009
(F-3.0540764331817627
F-2.5115911310369317
tp9010
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9011
(F-2.994140440044981
F-2.3924794630570845
tp9012
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9013
(F-3.1893075182546977
F-2.3892107876864346
tp9014
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9015
(F-2.9286442473292733
F-2.3700438412753018
tp9016
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9017
(F-1.65804029765882
F-2.4920061284845527
tp9018
sS'return (i + 1)\ncounts = defaultdict(list)'
p9019
(F-3.860173543294271
F-2.602655757557262
tp9020
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9021
(F-2.944356354954404
F-2.3877308585427026
tp9022
sS'while readline():\n    pass'
p9023
(F-2.8831100463867188
F-2.405357014049183
tp9024
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9025
(F-2.845379384358724
F-2.416459170254794
tp9026
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9027
(F-3.5472185920266543
F-2.36445444280451
tp9028
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9029
(F-3.203764481977983
F-2.4316071597012607
tp9030
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9031
(F-2.9634003931162307
F-2.3610191345214844
tp9032
sS'def opcount(fname):\n    pass'
p9033
(F-1.9094101587931316
F-2.529012853449041
tp9034
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9035
(F-2.8718412853422617
F-2.39111987027255
tp9036
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9037
(F-2.8489314753834796
F-2.407875581221147
tp9038
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9039
(F-3.445068359375
F-2.4030064669522373
tp9040
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9041
(F-2.796412272625659
F-2.3729579231955786
tp9042
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9043
(F-1.855905577193859
F-2.415426427667791
tp9044
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9045
(F-3.4288629385141225
F-2.377094442194158
tp9046
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p9047
(F-2.839313564015858
F-2.4412141279740767
tp9048
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9049
(F-2.9639144682548415
F-2.3853090459650215
tp9050
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9051
(F-3.277700985179228
F-2.3771989995783027
tp9052
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0'
p9053
(F-3.5007171630859375
F-2.4113204262473364
tp9054
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9055
(F-3.2038821658572636
F-2.3740754560990767
tp9056
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9057
(F-3.848053220718626
F-2.3087411360307173
tp9058
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9059
(F-3.2176370741445806
F-2.3686098618940874
tp9060
sS'import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9061
(F-1.9146335919698079
F-2.4456553025679155
tp9062
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9063
(F-2.884271509507123
F-2.400416287508878
tp9064
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9065
(F-3.2324113046656775
F-2.3783125443892046
tp9066
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9067
(F-2.4903309161846456
F-2.426629673350941
tp9068
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9069
(F-3.8603545398246952
F-2.3785478418523613
tp9070
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9071
(F-2.9726275453473083
F-2.360687082464045
tp9072
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9073
(F-3.8931218361367983
F-2.2994346618652344
tp9074
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9075
(F-2.956592391022539
F-2.3686405528675425
tp9076
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9077
(F-2.966732978820801
F-2.392139434814453
tp9078
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9079
(F-3.253026130871895
F-2.378335952758789
tp9080
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9081
(F-2.39855710921749
F-2.3974139473655005
tp9082
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9083
(F-3.5126107637999486
F-2.340865048495206
tp9084
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9085
(F-3.036336854446766
F-2.3840267874977807
tp9086
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9087
(F-2.941607850970644
F-2.3618252494118432
tp9088
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9089
(F-2.7834459940592446
F-2.427197716452859
tp9090
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9091
(F-3.0772632252086294
F-2.4186456853693183
tp9092
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9093
(F-3.183534034522804
F-2.37669545953924
tp9094
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9095
(F-1.8551964230007596
F-2.449278224598278
tp9096
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9097
(F-3.5125066017617983
F-2.3816788413307886
tp9098
sS'start_time = time.time()'
p9099
(F-2.65164496681907
F-2.417369148947976
tp9100
sS'return lines\n\ndef opcount(fname):\n    pass'
p9101
(F-2.8694305419921875
F-2.455214587124911
tp9102
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9103
(F-2.963870634668293
F-2.3807619268243965
tp9104
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9105
(F-3.1702566245167527
F-2.379228418523615
tp9106
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9107
(F-2.2099542510643433
F-2.4861502213911577
tp9108
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9109
(F-3.2117232259114585
F-2.3867007168856533
tp9110
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9111
(F-2.4436872005462646
F-2.455896030772816
tp9112
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9113
(F-3.0575179596860966
F-2.4218881780450996
tp9114
sS'while buf:\n    pass'
p9115
(F-2.63874880472819
F-2.3886423977938565
tp9116
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9117
(F-3.347921502100278
F-2.4006805419921875
tp9118
sS'from __future__ import with_statement\nimport time\nimport mmap'
p9119
(F-2.956197500228882
F-2.4418276006525215
tp9120
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9121
(F-2.6637487103862147
F-2.4615712599320845
tp9122
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9123
(F-2.9409689331054687
F-2.4081876928156074
tp9124
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9125
(F-2.7158252804778344
F-2.389886335893111
tp9126
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9127
(F-2.959558794575353
F-2.37743481722745
tp9128
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9129
(F-2.8192035130092075
F-2.386052218350497
tp9130
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9131
(F-2.9059627925124123
F-2.3930457722056997
tp9132
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9133
(F-3.078448142840233
F-2.4063784859397193
tp9134
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9135
(F-3.227795769186581
F-2.3984980149702593
tp9136
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9137
(F-2.9005177349125573
F-2.4120622114701704
tp9138
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9139
(F-2.419264112200056
F-2.5527643723921343
tp9140
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9141
(F-3.597399491530198
F-2.3613142533735796
tp9142
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9143
(F-2.8639779772077287
F-2.408687938343395
tp9144
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9145
(F-2.937621548644498
F-2.3844113783402876
tp9146
sS'import time'
p9147
(F-5.629439353942871
F-2.4636816544966265
tp9148
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9149
(F-3.189875577756872
F-2.378045515580611
tp9150
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9151
(F-2.7538650914242395
F-2.453589526089755
tp9152
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9153
(F-3.0359464372907365
F-2.396490617231889
tp9154
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9155
(F-3.2369807578997905
F-2.3782726634632456
tp9156
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9157
(F-3.3017380976043973
F-2.3556794253262607
tp9158
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9159
(F-3.0649069081182065
F-2.3770503997802734
tp9160
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9161
(F-3.2105726304945055
F-2.3803383220325816
tp9162
sS"assert (func('big_file.txt') == 1209138)"
p9163
(F-3.35778149691495
F-2.517628409645774
tp9164
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9165
(F-3.080106735229492
F-2.42395695773038
tp9166
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9167
(F-2.9514522552490234
F-2.338337638161399
tp9168
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9169
(F-3.772828182931674
F-2.2999954223632812
tp9170
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9171
(F-2.781368039688974
F-2.459746620871804
tp9172
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9173
(F-3.1482112544993455
F-2.3677243319424717
tp9174
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9175
(F-3.0696292930925395
F-2.405156222256747
tp9176
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9177
(F-2.8136967005354636
F-2.3966425115411933
tp9178
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9179
(F-4.405370272122896
F-2.365228999744762
tp9180
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9181
(F-3.0024506942085596
F-2.3935775756835938
tp9182
sS'import random\nfrom collections import defaultdict'
p9183
(F-2.995424270629883
F-2.4549088911576704
tp9184
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9185
(F-3.5390119410272853
F-2.3610401153564453
tp9186
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9187
(F-2.9024341511276535
F-2.414487838745117
tp9188
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9189
(F-3.0671946628034608
F-2.3699701482599433
tp9190
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9191
(F-2.847973521162824
F-2.485292608087713
tp9192
sS'return lines\n\ndef simplecount(filename):\n    pass'
p9193
(F-2.816772937774658
F-2.4587121443314985
tp9194
sS'import mmap'
p9195
(F-6.6066131591796875
F-2.420284964821555
tp9196
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9197
(F-3.333678301642923
F-2.4002092534845527
tp9198
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9199
(F-3.4245224511063337
F-2.3628418662331323
tp9200
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9201
(F-3.057024152888808
F-2.3958587646484375
tp9202
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9203
(F-2.851372543646365
F-2.408587195656516
tp9204
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9205
(F-3.224675496419271
F-2.398651123046875
tp9206
sS'for (i, l) in enumerate(f):\n    pass'
p9207
(F-2.0764425065782337
F-2.691170432350852
tp9208
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9209
(F-2.8639739280523258
F-2.3859426325017754
tp9210
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9211
(F-2.6022001139322914
F-2.4789322939786045
tp9212
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9213
(F-2.9827016550344188
F-2.3949203491210938
tp9214
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9215
(F-2.894820548392631
F-2.3920088681307705
tp9216
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9217
(F-3.8153726328974185
F-2.331504301591353
tp9218
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9219
(F-2.8548762434619968
F-2.4068275798450816
tp9220
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9221
(F-3.453241762907609
F-2.3660519339821557
tp9222
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9223
(F-3.052077467424156
F-2.3890540383078833
tp9224
sS'from collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9225
(F-1.5883825090196397
F-2.4904590953480112
tp9226
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9227
(F-2.6018054921139955
F-2.5210120461203833
tp9228
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9229
(F-2.994325029089096
F-2.4126337224786933
tp9230
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9231
(F-2.933074951171875
F-2.382711583917791
tp9232
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9233
(F-2.932984375
F-2.4023382013494317
tp9234
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9235
(F-3.534595213074615
F-2.3339323564009233
tp9236
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9237
(F-3.019532349732545
F-2.3793666146018286
tp9238
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9239
(F-3.17654230176788
F-2.369123632257635
tp9240
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9241
(F-2.3181079366932744
F-2.4292949329723013
tp9242
sS'import mmap\nimport random'
p9243
(F-4.607879093715122
F-2.41320783441717
tp9244
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9245
(F-3.1595275313765914
F-2.405278119173917
tp9246
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9247
(F-2.7412608132433536
F-2.42868371443315
tp9248
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9249
(F-3.5015551559324187
F-2.3621077104048296
tp9250
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9251
(F-2.9399606613885787
F-2.381688204678622
tp9252
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9253
(F-2.229466473614728
F-2.464678157459606
tp9254
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9255
(F-2.5446977286503234
F-2.4584874239834873
tp9256
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9257
(F-2.8137634959300803
F-2.4290024150501597
tp9258
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9259
(F-2.715084431966146
F-2.4040145874023438
tp9260
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9261
(F-2.794302749633789
F-2.407906272194602
tp9262
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9263
(F-2.8411772484872855
F-2.4105266224254263
tp9264
sS'import time\nimport mmap'
p9265
(F-4.909658704485212
F-2.4125721671364526
tp9266
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9267
(F-2.7621996137830944
F-2.4558174826882104
tp9268
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9269
(F-2.893017326433634
F-2.377683986317028
tp9270
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9271
(F-2.982125529837101
F-2.406421661376953
tp9272
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9273
(F-2.5225432773806014
F-2.422285253351385
tp9274
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9275
(F-3.2567923990885417
F-2.3910612626509233
tp9276
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9277
(F-3.30523827832616
F-2.3751033436168325
tp9278
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9279
(F-2.8817352881798377
F-2.401449030095881
tp9280
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9281
(F-3.2927434167196585
F-2.3816932331431997
tp9282
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9283
(F-2.9487129847208657
F-2.3937962271950464
tp9284
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9285
(F-2.9200890695946846
F-2.3803842717950996
tp9286
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9287
(F-3.5302840012770433
F-2.3787307739257812
tp9288
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9289
(F-3.514411650508283
F-2.3346321799538354
tp9290
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9291
(F-2.964481097165779
F-2.3990473313765093
tp9292
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9293
(F-3.193038426088483
F-2.37588813088157
tp9294
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9295
(F-3.008834558030579
F-2.41904033314098
tp9296
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9297
(F-2.983468350497159
F-2.403017217462713
tp9298
sS'with open(fname) as f:\n    for (i, l) in enumerate(f):\n        pass'
p9299
(F-1.7852382002205684
F-2.530801946466619
tp9300
sS'def opcount(fname):\n    with open(fname) as f:\n        pass'
p9301
(F-1.5945623646611753
F-2.393389268354936
tp9302
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9303
(F-2.0572393508184526
F-2.49194318597967
tp9304
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9305
(F-4.69400289784307
F-2.3343575217507104
tp9306
sS'buf_size = (1024 * 1024)'
p9307
(F-4.643637570467862
F-2.377860502763228
tp9308
sS'counts = defaultdict(list)'
p9309
(F-2.826997756958008
F-2.7125226801091973
tp9310
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9311
(F-2.9852520702331047
F-2.363252292979847
tp9312
sS'from __future__ import with_statement\nimport time'
p9313
(F-2.792128636286809
F-2.45798058943315
tp9314
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9315
(F-3.498788897910815
F-2.372216658158736
tp9316
sS'while readline():\n    lines += 1'
p9317
(F-3.575962946965144
F-2.3192596435546875
tp9318
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9319
(F-3.169842825995551
F-2.354403409090909
tp9320
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9321
(F-3.0109183571555396
F-2.390183535489169
tp9322
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p9323
(F-3.044812090985187
F-2.3815078735351562
tp9324
sS'counts = defaultdict(list)\nfor i in range(5):\n    pass'
p9325
(F-1.5669837225051153
F-2.5572554848410864
tp9326
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9327
(F-2.9749687056107956
F-2.3841542330655185
tp9328
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9329
(F-3.3552783468495244
F-2.371092536232688
tp9330
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9331
(F-3.063834687583467
F-2.41064470464533
tp9332
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9333
(F-2.8858528371237537
F-2.418149774724787
tp9334
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9335
(F-3.566514213130159
F-2.3750889518044214
tp9336
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9337
(F-2.9283081503475414
F-2.405111139470881
tp9338
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9339
(F-3.1105251736111112
F-2.3690612099387427
tp9340
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9341
(F-3.7119747428006904
F-2.3815236525102095
tp9342
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9343
(F-3.211273193359375
F-2.368255615234375
tp9344
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9345
(F-3.8172671669407894
F-2.3662112842906606
tp9346
sS'def bufcount(filename):\n    pass'
p9347
(F-1.839511235555013
F-2.4698063243519175
tp9348
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9349
(F-3.160632011217949
F-2.3858680725097656
tp9350
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9351
(F-3.3334567047828854
F-2.3267581246115943
tp9352
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9353
(F-1.9422201268813188
F-2.424376747824929
tp9354
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9355
(F-4.351089028751149
F-2.322152918035334
tp9356
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9357
(F-2.9610977172851562
F-2.3698314319957388
tp9358
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9359
(F-3.2709228085799955
F-2.399290778420188
tp9360
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9361
(F-2.506042056613498
F-2.464845830743963
tp9362
sS'f = open(filename)'
p9363
(F-3.3439643383026123
F-2.4491419358686968
tp9364
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9365
(F-2.9566813990012886
F-2.4122064763849433
tp9366
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9367
(F-3.5691251314603365
F-2.349380839954723
tp9368
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9369
(F-2.730562310469778
F-2.455055063421076
tp9370
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9371
(F-3.065926722796315
F-2.3755002455277876
tp9372
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9373
(F-2.898975626627604
F-2.42055962302468
tp9374
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9375
(F-3.007455896448206
F-2.3729815049604936
tp9376
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9377
(F-2.642370889353198
F-2.5069474306973545
tp9378
sS'for line in open(filename):\n    pass'
p9379
(F-1.8452791486467635
F-2.499012513594194
tp9380
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9381
(F-3.3318991088867187
F-2.4556576121937144
tp9382
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9383
(F-2.9408577773977536
F-2.382042104547674
tp9384
sS'def bufcount(filename):\n    f = open(filename)'
p9385
(F-2.015429552863626
F-2.4741086092862217
tp9386
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9387
(F-2.9117133027763775
F-2.3976130052046343
tp9388
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9389
(F-2.998414492277506
F-2.3751019564541904
tp9390
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9391
(F-2.917201784823803
F-2.3945621143687856
tp9392
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9393
(F-2.9091839260525174
F-2.421917135065252
tp9394
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9395
(F-2.913160986770676
F-2.376769325949929
tp9396
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p9397
(F-2.3930279658390927
F-2.5176252885298296
tp9398
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9399
(F-1.7433917071368243
F-2.6476974487304688
tp9400
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9401
(F-2.078552715594952
F-2.5041120702570137
tp9402
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9403
(F-2.8771635543468386
F-2.392149491743608
tp9404
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9405
(F-3.329608372279576
F-2.3662138852206143
tp9406
sS'import time\nimport mmap\nimport random'
p9407
(F-3.9688880920410154
F-2.416459863836115
tp9408
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9409
(F-2.6344355589954565
F-2.5202558690851387
tp9410
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9411
(F-2.519232177734375
F-2.4346901286732066
tp9412
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9413
(F-3.2305499066363326
F-2.3767694993452593
tp9414
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9415
(F-2.427509811689269
F-2.417513067072088
tp9416
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p9417
(F-3.1040295316972806
F-2.389762531627308
tp9418
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9419
(F-3.0449172394185124
F-2.4046606584028765
tp9420
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9421
(F-2.8984773642902444
F-2.4005517092618076
tp9422
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9423
(F-2.9568771806735437
F-2.4160320975563745
tp9424
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9425
(F-3.014055769020152
F-2.395273728804155
tp9426
sS'import random'
p9427
(F-5.057374000549316
F-2.439558896151456
tp9428
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9429
(F-2.8783614395448827
F-2.410342649980025
tp9430
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9431
(F-3.1820808022709217
F-2.407783855091442
tp9432
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9433
(F-3.474348449707031
F-2.362707484852184
tp9434
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9435
(F-2.9672756958007813
F-2.4228940443559126
tp9436
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9437
(F-3.092834766094501
F-2.3502058549360796
tp9438
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9439
(F-3.398748083959652
F-2.413249969482422
tp9440
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9441
(F-3.2880869989809782
F-2.3686547712846235
tp9442
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9443
(F-1.9806915565773293
F-2.4417464516379614
tp9444
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9445
(F-2.9822567355248237
F-2.3703197132457388
tp9446
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9447
(F-2.938691413265535
F-2.4137531627308237
tp9448
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9449
(F-2.9207508689478825
F-2.3935669985684482
tp9450
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9451
(F-2.918992707223603
F-2.4577210166237573
tp9452
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9453
(F-3.3070672003777473
F-2.3347306685014204
tp9454
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9455
(F-2.8197891235351564
F-2.369822762229226
tp9456
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9457
(F-2.7403990916716747
F-2.370115973732688
tp9458
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9459
(F-2.9163605220734126
F-2.3975982666015625
tp9460
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9461
(F-2.8024331665039064
F-2.526732184670188
tp9462
sS'buf = read_f(buf_size)'
p9463
(F-4.272948582967122
F-2.3192242709073154
tp9464
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9465
(F-3.084897238110739
F-2.359465859153054
tp9466
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9467
(F-3.0654805501302085
F-2.4185128645463423
tp9468
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9469
(F-3.330400427993463
F-2.3651355396617544
tp9470
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9471
(F-2.8541084621263586
F-2.4089397083629263
tp9472
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9473
(F-3.2200033833661417
F-2.368790019642223
tp9474
sS'buf = read_f(buf_size)\nwhile buf:\n    pass'
p9475
(F-3.38321533203125
F-2.27764875238592
tp9476
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9477
(F-2.8779450610168
F-2.4075353795831855
tp9478
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9479
(F-3.1379521122685183
F-2.3914978720925073
tp9480
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9481
(F-2.2768055308948862
F-2.637438340620561
tp9482
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9483
(F-2.5315513267173424
F-2.4366607666015625
tp9484
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9485
(F-2.961612638879995
F-2.4037199887362393
tp9486
ssI6416131
(dp9487
S'copy = self.copy()'
p9488
(F-3.354633543226454
F-2.774202346801758
tp9489
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()'
p9490
(F-2.216876745223999
F-2.658339500427246
tp9491
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9492
(F-4.290118049172794
F-2.639430522918701
tp9493
sS'class Dict(dict):\n\n    def __add__(self, other):\n        pass'
p9494
(F-1.6711185161884015
F-2.667093276977539
tp9495
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9496
(F-3.527921582831711
F-2.6264350414276123
tp9497
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9498
(F-3.0865448661472485
F-2.6045689582824707
tp9499
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9500
(F-3.4598787095811634
F-2.688934803009033
tp9501
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9502
(F-3.2684529622395835
F-2.6069889068603516
tp9503
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9504
(F-3.376586204351381
F-2.682072162628174
tp9505
sS'copy.update(self)'
p9506
(F-3.01595139503479
F-2.6925253868103027
tp9507
sS"(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9508
(F-4.570733642578125
F-2.7639243602752686
tp9509
sS'def __add__(self, other):\n    copy = self.copy()'
p9510
(F-2.5455908341841265
F-2.8278794288635254
tp9511
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9512
(F-3.784811902402052
F-2.646371841430664
tp9513
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9514
(F-2.9501523971557617
F-2.717190742492676
tp9515
sS'copy = other.copy()'
p9516
(F-3.6370201110839844
F-2.87233304977417
tp9517
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9518
(F-3.599726924189815
F-2.648482084274292
tp9519
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9520
(F-4.004660470145089
F-2.68228816986084
tp9521
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9522
(F-3.8948984781901044
F-2.6148452758789062
tp9523
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9524
(F-4.024821888316762
F-2.6795618534088135
tp9525
sS'return copy\n\ndef __radd__(self, other):\n    pass'
p9526
(F-3.1340946197509765
F-2.8525283336639404
tp9527
sS"({'test1': 1, } + Dict(test2=2))"
p9528
(F-4.680568021886489
F-2.6529295444488525
tp9529
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9530
(F-3.455310916112474
F-2.6043741703033447
tp9531
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9532
(F-3.649569584773137
F-2.7609527111053467
tp9533
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9534
(F-3.423537976814039
F-2.692532777786255
tp9535
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p9536
(F-2.5700854597420526
F-2.6260743141174316
tp9537
sS'class Dict(dict):\n    pass'
p9538
(F-2.1507719357808432
F-2.6142048835754395
tp9539
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9540
(F-3.768534986278679
F-2.6563141345977783
tp9541
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy'
p9542
(F-2.708719707670666
F-2.6077702045440674
tp9543
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9544
(F-2.8603569236961572
F-2.6095659732818604
tp9545
sS'copy.update(other)'
p9546
(F-2.943138599395752
F-2.7522382736206055
tp9547
sS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9548
(F-3.5603106021881104
F-2.7854104042053223
tp9549
sS"default_data = Dict({'item1': 1, 'item2': 2, })"
p9550
(F-3.1018152738872327
F-2.7834222316741943
tp9551
sS'copy.update(self)\nreturn copy'
p9552
(F-4.115872469815341
F-2.688570022583008
tp9553
sS'def __radd__(self, other):\n    copy = other.copy()'
p9554
(F-2.90934926813299
F-2.8183465003967285
tp9555
sS'def __radd__(self, other):\n    pass'
p9556
(F-2.002591609954834
F-2.977017402648926
tp9557
sS"default_data['item3'] = 3"
p9558
(F-2.658331298828125
F-2.9894213676452637
tp9559
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9560
(F-2.811853972958847
F-2.60878849029541
tp9561
sS'return copy'
p9562
(F-7.0003180503845215
F-2.813908576965332
tp9563
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9564
(F-3.819384344692888
F-2.6568098068237305
tp9565
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9566
(F-3.709060256545608
F-2.6262147426605225
tp9567
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9568
(F-3.53171624077691
F-2.674142360687256
tp9569
sS'copy.update(other)\nreturn copy'
p9570
(F-4.201453122225675
F-2.766561985015869
tp9571
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)'
p9572
(F-2.581649975898938
F-2.6033873558044434
tp9573
sS'def __add__(self, other):\n    pass'
p9574
(F-1.736626386642456
F-2.9830477237701416
tp9575
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9576
(F-4.213763532967403
F-2.636174201965332
tp9577
sS"(default_data + {'item3': 3, })"
p9578
(F-4.3635550907679965
F-3.1124801635742188
tp9579
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9580
(F-2.8314366340637207
F-2.6237852573394775
tp9581
sS"default_data.update({'item3': 3, })"
p9582
(F-3.223857879638672
F-2.821499824523926
tp9583
sS"default_data.update({'item4': 4, 'item5': 5, })"
p9584
(F-2.827815808747944
F-2.7764642238616943
tp9585
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9586
(F-3.9756179258047815
F-2.633399248123169
tp9587
sS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9588
(F-3.9517014821370444
F-2.6763546466827393
tp9589
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9590
(F-2.8494901985957704
F-2.7283782958984375
tp9591
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9592
(F-3.490136580033736
F-2.7532763481140137
tp9593
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9594
(F-3.3184478759765623
F-2.690121650695801
tp9595
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9596
(F-4.079766409737723
F-2.701282501220703
tp9597
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9598
(F-3.268426818847656
F-2.6698648929595947
tp9599
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p9600
(F-3.1101721304434315
F-2.742058753967285
tp9601
ssI3964681
(dp9602
S"import glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p9603
(F-1.389385768345424
F-2.55203129695012
tp9604
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    pass"
p9605
(F-1.8489199829101564
F-2.5482171865609975
tp9606
sS"glob.glob('./*.txt')"
p9607
(F-1.142768383026123
F-2.704050504244291
tp9608
sS'import glob, os'
p9609
(F-4.60383415222168
F-2.8728103637695312
tp9610
sS"for file in os.listdir('/mydir'):\n    pass"
p9611
(F-1.2464280128479004
F-2.589855487530048
tp9612
sS"for file in glob.glob('*.txt'):\n    pass"
p9613
(F-1.1642507314682007
F-2.6380392221304088
tp9614
sS"import glob\nglob.glob('./*.txt')"
p9615
(F-1.3660609505393289
F-2.6767202524038463
tp9616
sS"os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p9617
(F-1.337990138841712
F-2.60844480074369
tp9618
sS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p9619
(F-1.3683154408524676
F-2.5296255258413463
tp9620
sS'print os.path.join(root, file)'
p9621
(F-1.5192803602952223
F-2.714630420391376
tp9622
sS"for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p9623
(F-0.9289158008716725
F-2.5804076561561
tp9624
sS"import os\nfor file in os.listdir('/mydir'):\n    pass"
p9625
(F-1.022733487580952
F-2.621185302734375
tp9626
sS"for (root, dirs, files) in os.walk('/mydir'):\n    pass"
p9627
(F-1.9664632623845881
F-2.552975287804237
tp9628
sS"for file in files:\n    if file.endswith('.txt'):\n        pass"
p9629
(F-1.0072210485284978
F-2.649707500751202
tp9630
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p9631
(F-1.3299921209161931
F-2.517022939828726
tp9632
sS'import os'
p9633
(F-3.637714385986328
F-3.4755835899939904
tp9634
sS"if file.endswith('.txt'):\n    pass"
p9635
(F-1.3450463158743722
F-2.9196897653432994
tp9636
sS'print file'
p9637
(F-5.875585079193115
F-3.158455775334285
tp9638
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p9639
(F-1.6055998368696733
F-2.5180608309232273
tp9640
sS"import os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p9641
(F-0.8237297058105468
F-2.5999529911921573
tp9642
sS'import glob'
p9643
(F-4.56627082824707
F-2.9727504436786356
tp9644
sS"os.chdir('/mydir')"
p9645
(F-1.1501903533935547
F-2.8546820420485277
tp9646
sS'for file in files:\n    pass'
p9647
(F-1.491408954967152
F-2.687784341665415
tp9648
sS"import glob, os\nos.chdir('/mydir')"
p9649
(F-1.8281876490666316
F-2.6974813021146336
tp9650
sS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p9651
(F-1.6774930318196615
F-2.538633493276743
tp9652
ssI849674
(dp9653
S"import thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9654
(F-2.9507313896627987
F-3.3661402384440104
tp9655
sS'print errtxt'
p9656
(F-4.605876922607422
F-3.4346524556477864
tp9657
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    pass'
p9658
(F-2.325117383684431
F-3.268377431233724
tp9659
sS'import thread, time'
p9660
(F-4.522980372111003
F-3.35745849609375
tp9661
sS'while 1:\n    pass'
p9662
(F-2.209307564629449
F-3.28037109375
tp9663
sS'pass'
p9664
(F-3.2649571100870767
F-3.4498690287272136
tp9665
sS'import thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p9666
(F-3.376247787475586
F-3.3637367248535157
tp9667
sS"import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9668
(F-2.928835974799262
F-3.355956776936849
tp9669
sS'import thread'
p9670
(F-4.111080646514893
F-3.3266626993815103
tp9671
sS'import thread\n\ndef myfunction(mystring, *args):\n    pass'
p9672
(F-2.8251800537109375
F-3.3218757629394533
tp9673
sS"Thread(target=myfunction, args=('MyStringHere', 1)).start()"
p9674
(F-2.2236948013305664
F-3.2587000528971353
tp9675
sS'def myfunction(mystring, *args):\n    pass'
p9676
(F-2.9577486673990885
F-3.3727755228678387
tp9677
sS'def myfunction(mystring, *args):\n    print mystring'
p9678
(F-3.6296582221984863
F-3.4293858846028646
tp9679
sS"from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9680
(F-2.6467473771837025
F-3.29976323445638
tp9681
sS't.start()\nt.join()'
p9682
(F-1.8504336430476263
F-3.388203430175781
tp9683
sS't.start()'
p9684
(F-1.5818710327148438
F-3.32830810546875
tp9685
sS'time.sleep(5)'
p9686
(F-1.1485950946807861
F-3.335211181640625
tp9687
sS'print mystring'
p9688
(F-5.988827705383301
F-3.670518747965495
tp9689
sS't.join()'
p9690
(F-1.7380629948207311
F-3.6421918233235675
tp9691
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p9692
(F-2.88479961048473
F-3.2789845784505207
tp9693
sS'from threading import Thread'
p9694
(F-2.739612261454264
F-3.2601577758789064
tp9695
sS"def myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9696
(F-2.940759023030599
F-3.410136413574219
tp9697
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring'
p9698
(F-3.3201460404829546
F-3.348927307128906
tp9699
sS"if (__name__ == '__main__'):\n    pass"
p9700
(F-1.9615361531575521
F-3.41699701944987
tp9701
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    pass'
p9702
(F-2.832993643624442
F-3.315144348144531
tp9703
sS"thread.start_new_thread(myfunction, ('MyStringHere', 1))"
p9704
(F-2.9290067884657116
F-3.267938232421875
tp9705
sS"t = Thread(None, myfunction, None, ('MyStringHere', 1))"
p9706
(F-3.512013965182834
F-3.2630294799804687
tp9707
ssI8270092
(dp9708
S"pattern = re.compile('\\\\s+')"
p9709
(F-1.4718908309936523
F-2.057306077745226
tp9710
sS'import re'
p9711
(F-4.400424957275391
F-2.177537282307943
tp9712
sS"import re\npattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p9713
(F-1.463384775015024
F-2.0143968794080944
tp9714
sS"pattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p9715
(F-1.6159830508024797
F-2.011162439982096
tp9716
sS"import re\npattern = re.compile('\\\\s+')"
p9717
(F-1.3233331533578725
F-2.041351742214627
tp9718
sS"sentence = sentence.replace(' ', '')"
p9719
(F-1.9152258237202961
F-2.0705778333875866
tp9720
sS"sentence = re.sub('\\\\s+', '', sentence, flags=re.UNICODE)"
p9721
(F-1.6610015869140624
F-2.0498523712158203
tp9722
sS"'helloapple'"
p9723
(F-4.054511706034343
F-2.520007027520074
tp9724
sS'sentence = sentence.strip()'
p9725
(F-2.77354007297092
F-2.1511400010850696
tp9726
sS"sentence = re.sub(pattern, '', sentence)"
p9727
(F-2.236917631966727
F-2.002732594807943
tp9728
sS"'hello  apple'"
p9729
(F-4.054511706034343
F-2.520007027520074
tp9730
sS"'hello apple'"
p9731
(F-4.054511706034343
F-2.520007027520074
tp9732
sS"sentence = ''.join(sentence.split())"
p9733
(F-1.913214819771903
F-2.049356884426541
tp9734
ssI7961363
(dp9735
S"list(OrderedDict.fromkeys('abracadabra'))"
p9736
(F-2.6780500411987305
F-2.607751210530599
tp9737
sS's = [1, 2, 3]\nlist((set(t) - set(s)))'
p9738
(F-2.5918350219726562
F-2.4327430725097656
tp9739
sS"list(dict.fromkeys('abracadabra'))"
p9740
(F-2.3264954306862573
F-2.7566906611124673
tp9741
sS't\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p9742
(F-3.501128726535373
F-2.42679770787557
tp9743
sS'list(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p9744
(F-2.7450536840102253
F-2.42584228515625
tp9745
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt'
p9746
(F-2.435452880859375
F-2.807369867960612
tp9747
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]'
p9748
(F-2.65479367278343
F-2.554702123006185
tp9749
sS'from collections import OrderedDict'
p9750
(F-2.617539542061942
F-2.6810986200968423
tp9751
sS'list((set(t) - set(s)))'
p9752
(F-2.9079952239990234
F-2.4671592712402344
tp9753
sS't\nlist(set(t))'
p9754
(F-4.7494191256436435
F-2.667975107828776
tp9755
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))'
p9756
(F-2.434355302290483
F-2.56708033879598
tp9757
sS'list(set(t))'
p9758
(F-2.0997435251871743
F-2.593007723490397
tp9759
sS't'
p9760
(F-10.283279418945312
F-3.4864606857299805
tp9761
sS'list(set(t))\ns = [1, 2, 3]'
p9762
(F-2.8702816210295024
F-2.697088877360026
tp9763
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p9764
(F-2.6269860103212554
F-2.474231719970703
tp9765
sS's = [1, 2, 3]'
p9766
(F-2.4250946044921875
F-2.741147994995117
tp9767
sS't\nlist(set(t))\ns = [1, 2, 3]'
p9768
(F-4.151017325265067
F-2.7242298126220703
tp9769
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]'
p9770
(F-1.8893089294433594
F-2.8019240697224936
tp9771
sS"from collections import OrderedDict\nlist(OrderedDict.fromkeys('abracadabra'))"
p9772
(F-2.1192137400309243
F-2.5351489384969077
tp9773
ssI931092
(dp9774
S"'foo'[reverse_slice]"
p9775
(F-5.0931715965271
F-2.430201394217355
tp9776
sS'def reverse_a_string_slowly(a_string):\n    pass'
p9777
(F-2.725178909301758
F-2.329481397356306
tp9778
sS'def reversed_string(a_string):\n    return a_string[::(-1)]'
p9779
(F-2.558154070818866
F-1.920449665614537
tp9780
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)'
p9781
(F-3.292171902126736
F-1.9563484191894531
tp9782
sS"return ''.join(reversed(string))"
p9783
(F-2.0355707804361978
F-1.9121123722621374
tp9784
sS'string[slice_obj]'
p9785
(F-4.813818454742432
F-1.9357836587088448
tp9786
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9787
(F-4.468819049873737
F-2.3800392150878906
tp9788
sS'step = (-1)'
p9789
(F-4.765318393707275
F-2.373351505824498
tp9790
sS"new_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9791
(F-2.8628671264648435
F-1.8604380743844169
tp9792
sS"'foo'[::(-1)]"
p9793
(F-3.918616208163175
F-2.0088987350463867
tp9794
sS"index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9795
(F-2.7969688068736684
F-1.8538060869489397
tp9796
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1"
p9797
(F-2.865643168604651
F-1.9400341851370675
tp9798
sS'return a_string[::(-1)]'
p9799
(F-3.7479370662144254
F-1.9451687676565987
tp9800
sS'index = len(a_string)'
p9801
(F-3.9220176696777345
F-1.9933455330984933
tp9802
sS'def reverse_a_string_more_slowly(a_string):\n    pass'
p9803
(F-2.93747953935103
F-2.2267283030918668
tp9804
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''"
p9805
(F-2.7959671020507812
F-2.2277379717145647
tp9806
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p9807
(F-3.001068115234375
F-1.935934339250837
tp9808
sS'start = stop = None\nstep = (-1)'
p9809
(F-4.873710632324219
F-2.301101412091936
tp9810
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))"
p9811
(F-4.355632816979645
F-2.2255503790719167
tp9812
sS"return ''.join(new_strings)"
p9813
(F-1.9936865026300603
F-1.8848911012922014
tp9814
sS'return new_string'
p9815
(F-3.046980539957682
F-2.1905608858381
tp9816
sS'slice_obj = slice(start, stop, step)'
p9817
(F-4.513410023280552
F-2.4696401868547713
tp9818
sS'new_strings = []'
p9819
(F-3.113137722015381
F-1.9406258719308036
tp9820
sS'while index:\n    index -= 1\nnew_string += a_string[index]'
p9821
(F-3.0883858420632104
F-1.983722141810826
tp9822
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))"
p9823
(F-4.342185572574013
F-2.089581080845424
tp9824
sS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9825
(F-4.3449871135207845
F-2.34197507585798
tp9826
sS"reverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p9827
(F-4.925595601399739
F-2.4147592272077287
tp9828
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    pass"
p9829
(F-2.803939261087557
F-1.936448233468192
tp9830
sS"new_string = ''"
p9831
(F-2.3005463736397878
F-2.0988976614815846
tp9832
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    pass'
p9833
(F-2.9911183443936435
F-1.9619127001081194
tp9834
sS'def reversed_string(a_string):\n    pass'
p9835
(F-2.527432918548584
F-2.0086705344063893
tp9836
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p9837
(F-2.8909752789665673
F-1.8662766047886439
tp9838
sS"reversed_string('foo')"
p9839
(F-2.8288278579711914
F-2.0979072025844028
tp9840
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []'
p9841
(F-3.044533058449074
F-2.019152505057199
tp9842
sS'min(timeit.repeat((lambda : reversed_string(a_string))))'
p9843
(F-4.59219013560902
F-2.2734557560511996
tp9844
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]'
p9845
(F-2.9808273315429688
F-1.9195289611816406
tp9846
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))"
p9847
(F-4.061022016737196
F-1.9872943333217077
tp9848
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))'
p9849
(F-4.5861215794340096
F-2.3146305084228516
tp9850
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p9851
(F-2.9261072794596354
F-1.8976146153041296
tp9852
sS"'hello world'[::(-1)]"
p9853
(F-3.918616208163175
F-2.0088987350463867
tp9854
sS'string[start:stop:step]'
p9855
(F-4.55310287475586
F-1.848518235342843
tp9856
sS'slice_obj = slice(start, stop, step)\nstring[slice_obj]'
p9857
(F-4.786703927176339
F-2.387748990740095
tp9858
sS"step = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p9859
(F-4.785158429827009
F-2.3962805611746654
tp9860
sS'index -= 1'
p9861
(F-3.375545883178711
F-2.1747470583234514
tp9862
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p9863
(F-4.498325347900391
F-2.3404366629464284
tp9864
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1'
p9865
(F-3.0326004028320312
F-1.9613309587751115
tp9866
sS'new_string += a_string[index]\nreturn new_string'
p9867
(F-3.5004209630629597
F-1.9044297082083566
tp9868
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]"
p9869
(F-2.855152553982205
F-1.903435298374721
tp9870
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)"
p9871
(F-3.098605994022254
F-1.9291929517473494
tp9872
sS'new_string += a_string[index]'
p9873
(F-3.381598790486654
F-1.869701930454799
tp9874
sS'index = len(a_string)\nwhile index:\n    pass'
p9875
(F-3.0036578708224826
F-2.0341197422572543
tp9876
sS'start = stop = None'
p9877
(F-4.552476065499442
F-2.197443280901228
tp9878
sS"start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p9879
(F-4.852130216710708
F-2.4229935237339566
tp9880
sS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p9881
(F-4.492281649975067
F-2.3190672738211497
tp9882
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))'
p9883
(F-4.3463748051570015
F-2.2334371294294084
tp9884
sS"def reverse_string_readable_answer(string):\n    return ''.join(reversed(string))"
p9885
(F-2.302986427589699
F-1.9956275394984655
tp9886
sS"while index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9887
(F-2.8920091901506697
F-1.8705263137817383
tp9888
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))"
p9889
(F-4.342058507407584
F-2.167259080069406
tp9890
sS'start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)'
p9891
(F-4.563182689525463
F-2.470597130911691
tp9892
sS"a_string = ('amanaplanacanalpanama' * 10)"
p9893
(F-3.5376597317782315
F-1.9424689156668526
tp9894
sS'reverse_slice = slice(start, stop, step)'
p9895
(F-4.360358374459403
F-2.4893907819475447
tp9896
sS'while index:\n    index -= 1'
p9897
(F-2.7324645302512427
F-2.1729613712855746
tp9898
sS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p9899
(F-4.229148277869592
F-2.2412798745291576
tp9900
sS'while index:\n    pass'
p9901
(F-2.3775978088378906
F-2.3692550659179688
tp9902
sS'min(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9903
(F-4.3615602765764505
F-2.293109621320452
tp9904
sS'string[subscript]'
p9905
(F-3.771582285563151
F-1.909522465297154
tp9906
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string"
p9907
(F-2.854857363943326
F-1.9124347141810827
tp9908
sS'step = (-1)\nreverse_slice = slice(start, stop, step)'
p9909
(F-4.428781055268788
F-2.4802611214773997
tp9910
sS'index = len(a_string)\nwhile index:\n    index -= 1'
p9911
(F-3.0736534118652346
F-2.004119328090123
tp9912
sS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9913
(F-4.455218340899493
F-2.378317424229213
tp9914
sS'def reverse_string_readable_answer(string):\n    pass'
p9915
(F-2.7936058044433594
F-2.219564982822963
tp9916
sS'new_strings.append(a_string[index])'
p9917
(F-2.7888114929199217
F-1.9131709507533483
tp9918
sS'while index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p9919
(F-3.1114880597149885
F-2.007960183279855
tp9920
sS'while index:\n    index -= 1\nnew_strings.append(a_string[index])'
p9921
(F-3.0196542358398437
F-1.9258805683680944
tp9922
sS"def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9923
(F-2.855448913574219
F-1.8852829251970564
tp9924
ssI415511
(dp9925
S'import datetime'
p9926
(F-3.6465282440185547
F-1.5323028564453125
tp9927
sS'from time import gmtime, strftime'
p9928
(F-3.125725746154785
F-1.5177103678385417
tp9929
sS'datetime.datetime.now()'
p9930
(F-1.0512409210205078
F-1.4466446770562067
tp9931
sS'str(datetime.now())'
p9932
(F-1.429457950592041
F-1.5564278496636286
tp9933
sS'datetime.datetime.time(datetime.datetime.now())'
p9934
(F-1.3520570993423462
F-1.4169416427612305
tp9935
sS'from datetime import datetime'
p9936
(F-2.517391840616862
F-1.505173577202691
tp9937
sS'datetime.datetime.now().time()'
p9938
(F-0.8971836383526142
F-1.4184224870469835
tp9939
sS'import datetime\ndatetime.datetime.now()'
p9940
(F-1.0861746470133464
F-1.384584003024631
tp9941
sS"from time import gmtime, strftime\nstrftime('%Y-%m-%d %H:%M:%S', gmtime())"
p9942
(F-2.453779332778033
F-1.4980218675401475
tp9943
sS"strftime('%Y-%m-%d %H:%M:%S', gmtime())"
p9944
(F-2.3257776260375977
F-1.761492411295573
tp9945
sS'from datetime import datetime\nstr(datetime.now())'
p9946
(F-1.1788889567057292
F-1.3896257612440321
tp9947
ssI14043934
(dp9948
S'import datetime'
p9949
(F-3.7001118659973145
F-3.662493133544922
tp9950
sS'dt = datetime.datetime.combine(datetime.date.today(), t)'
p9951
(F-1.7243553161621095
F-3.494015121459961
tp9952
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p9953
(F-2.2597170743075283
F-3.4923683166503907
tp9954
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p9955
(F-2.103401336669922
F-3.480466842651367
tp9956
sS'(t - datetime.timedelta(hours=1, minutes=10))'
p9957
(F-2.361004935370551
F-3.552808380126953
tp9958
sS't = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p9959
(F-1.9432469776698522
F-3.4814491271972656
tp9960
sS'import datetime\nt = datetime.datetime.now()'
p9961
(F-1.6138356072562081
F-3.4929794311523437
tp9962
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p9963
(F-2.689962560480291
F-3.5007110595703126
tp9964
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)'
p9965
(F-1.7293135120022682
F-3.4916492462158204
tp9966
sS'dt.time()'
p9967
(F-1.8102711268833704
F-3.5813026428222656
tp9968
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p9969
(F-2.0857127796519888
F-3.490351104736328
tp9970
sS'dt -= datetime.timedelta(hours=5)\ndt.time()'
p9971
(F-2.091518825954861
F-3.463745880126953
tp9972
sS'import datetime\nt = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p9973
(F-1.7983626088788431
F-3.4903244018554687
tp9974
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p9975
(F-2.2920066637870593
F-3.4828716278076173
tp9976
sS't = datetime.time(1, 2)'
p9977
(F-2.170032024383545
F-3.4530055999755858
tp9978
sS't = datetime.datetime.now()'
p9979
(F-1.680126883766868
F-3.4819759368896483
tp9980
sS'dt'
p9981
(F-9.036242802937826
F-4.139487457275391
tp9982
sS'dt\ndt -= datetime.timedelta(hours=5)'
p9983
(F-3.054119655064174
F-3.496961212158203
tp9984
sS'dt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p9985
(F-2.911701965332031
F-3.479200744628906
tp9986
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p9987
(F-2.2994643702651514
F-3.494183349609375
tp9988
sS'dt -= datetime.timedelta(hours=5)'
p9989
(F-1.7807278633117676
F-3.4781898498535155
tp9990
ssI3940128
(dp9991
S'array = [0, 10, 20, 40]'
p9992
(F-3.092298067533053
F-1.286014036698775
tp9993
sS'L = [0, 10, 20, 40]\nL.reverse()\nL'
p9994
(F-3.4329972040085566
F-1.1842892386696555
tp9995
sS'array = [0, 10, 20, 40]\nfor i in reversed(array):\n    pass'
p9996
(F-2.0368961921105018
F-1.2162392356178977
tp9997
sS'L = [0, 10, 20, 40]\nL.reverse()'
p9998
(F-2.5967294793379936
F-1.1989805048162288
tp9999
sS'L = [0, 10, 20, 40]\nL[::(-1)]'
p10000
(F-3.2298375005307407
F-1.1857608448375354
tp10001
sS'print i'
p10002
(F-4.223038673400879
F-1.5871233506636186
tp10003
sS'L'
p10004
(F-9.893365224202475
F-1.2413957769220525
tp10005
sS'L = [0, 10, 20, 40]'
p10006
(F-2.9564828139085035
F-1.1957988739013672
tp10007
sS'L[::(-1)]'
p10008
(F-3.8177819685502485
F-1.1618591655384412
tp10009
sS'L.reverse()\nL'
p10010
(F-5.255479176839192
F-1.350097569552335
tp10011
sS'for i in reversed(array):\n    pass'
p10012
(F-1.6865392412458147
F-1.2524973262440076
tp10013
sS'L.reverse()'
p10014
(F-2.916325432913644
F-1.551314267245206
tp10015
ssI1949318
(dp10016
S'import httplib'
p10017
(F-5.028419017791748
F-3.0921295166015623
tp10018
sS'200'
p10019
(F-7.437801996866862
F-3.207569122314453
tp10020
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10021
(F-2.152069664001465
F-2.998855209350586
tp10022
sS"conn = httplib.HTTPConnection('www.python.org')"
p10023
(F-1.922215375033292
F-3.0029922485351563
tp10024
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10025
(F-1.8542971403702446
F-2.993969535827637
tp10026
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10027
(F-2.364240222507053
F-2.99197998046875
tp10028
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)'
p10029
(F-2.217645263671875
F-2.992817687988281
tp10030
sS'r1 = conn.getresponse()'
p10031
(F-2.408949534098307
F-3.035843086242676
tp10032
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p10033
(F-2.5394439697265625
F-3.0217557907104493
tp10034
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()"
p10035
(F-1.7121992844801683
F-3.0906902313232423
tp10036
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')"
p10037
(F-1.9713802337646484
F-2.973735809326172
tp10038
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10039
(F-1.9145111083984374
F-3.017853927612305
tp10040
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10041
(F-2.7495179352936923
F-3.053174591064453
tp10042
sS"conn.request('HEAD', '/')"
p10043
(F-2.12030029296875
F-3.074783515930176
tp10044
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10045
(F-1.8045594000047254
F-2.9666210174560548
tp10046
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10047
(F-2.283105180070207
F-3.0257349014282227
tp10048
sS'r = requests.head(url)'
p10049
(F-2.330870819091797
F-3.022937774658203
tp10050
sS'print r1.status, r1.reason'
p10051
(F-4.039020538330078
F-3.402109146118164
tp10052
sS'def url_ok(url):\n    pass'
p10053
(F-2.3124803815569197
F-3.149383544921875
tp10054
sS'r1 = conn.getresponse()\nprint r1.status, r1.reason'
p10055
(F-2.957927703857422
F-3.154585075378418
tp10056
sS'def url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p10057
(F-2.6796064376831055
F-3.140475273132324
tp10058
sS'import requests\n\ndef url_ok(url):\n    pass'
p10059
(F-2.066116544935438
F-2.9874759674072267
tp10060
sS'import requests'
p10061
(F-3.954026222229004
F-2.954926109313965
tp10062
sS'def url_ok(url):\n    r = requests.head(url)'
p10063
(F-2.4232501075381325
F-3.1180088043212892
tp10064
sS'return (r.status_code == 200)'
p10065
(F-3.353907267252604
F-3.2224632263183595
tp10066
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10067
(F-1.906338827950614
F-2.9865427017211914
tp10068
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()\n200"
p10069
(F-2.9697723388671875
F-3.0945425033569336
tp10070
ssI2052390
(dp10071
S'raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10072
(F-2.2264266543918185
F-4.707766446200284
tp10073
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    pass'
p10074
(F-2.6063345772879463
F-4.484825134277344
tp10075
sS'raise AppError, error, sys.exc_info()[2]\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p10076
(F-2.8836341271033654
F-4.494031039151278
tp10077
sS'raise AppError, error, sys.exc_info()[2]'
p10078
(F-3.390750461154514
F-4.485230879350142
tp10079
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\nraise'
p10080
(F-3.1218700408935547
F-4.415332447398793
tp10081
sS'do_something_in_app_that_breaks_easily()'
p10082
(F-2.723653232350069
F-4.500674161044034
tp10083
sS'if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    pass'
p10084
(F-3.725185271232359
F-4.777826829390093
tp10085
sS'class MyAppLookupError(LookupError):\n    "raise this when there\'s a lookup error for my app"'
p10086
(F-4.956841468811035
F-4.689865459095348
tp10087
sS'raise'
p10088
(F-7.80214246114095
F-4.467652754350142
tp10089
sS'if (foo not in _ALLOWED_ARGS):\n    pass'
p10090
(F-2.761378288269043
F-4.8424204046076
tp10091
sS"('message', 'foo', 'bar', 'baz')"
p10092
(F-2.33968804099343
F-4.634918212890625
tp10093
sS'if (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10094
(F-2.3865324451077368
F-4.90551064231179
tp10095
sS'logger.error(error)'
p10096
(F-3.3775813579559326
F-4.463089336048473
tp10097
sS'"raise this when there\'s a lookup error for my app"'
p10098
(F-4.19540278116862
F-4.70037876475941
tp10099
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."'
p10100
(F-3.0033373151506697
F-4.524459492076527
tp10101
sS'def api_func(foo):\n    pass'
p10102
(F-2.2010180609566823
F-4.51262803511186
tp10103
sS'demo_bad_catch()'
p10104
(F-4.174874199761285
F-4.397066289728338
tp10105
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10106
(F-2.5535652854225854
F-4.773390336470171
tp10107
sS"raise Exception('I know python!')"
p10108
(F-1.589599609375
F-4.45613583651456
tp10109
sS'raise error.with_traceback(sys.exc_info()[2])'
p10110
(F-3.246133041381836
F-4.412169716574929
tp10111
sS'"foo should be either \'baz\' or \'bar\'. returns something very useful."'
p10112
(F-4.19540278116862
F-4.70037876475941
tp10113
sS'print err.args'
p10114
(F-3.8463001251220703
F-4.448721798983487
tp10115
sS"raise 'message'"
p10116
(F-5.993995666503906
F-4.541795210404829
tp10117
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    pass'
p10118
(F-2.8896400188577585
F-4.676567077636719
tp10119
sS'demo_no_catch()'
p10120
(F-4.095010121663411
F-4.60430908203125
tp10121
sS'if (0 < distance <= RADIUS):\n    pass'
p10122
(F-3.9977684020996094
F-4.75261098688299
tp10123
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)'
p10124
(F-2.645332135652241
F-4.415119517933238
tp10125
sS"raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz')"
p10126
(F-2.1530650002615794
F-4.5865936279296875
tp10127
sS"raise Exception('I know Python!')"
p10128
(F-1.589599609375
F-4.45613583651456
tp10129
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print err.args'
p10130
(F-2.8557632847836145
F-4.487689625133168
tp10131
sS"raise ValueError('A very specific bad thing happened')"
p10132
(F-1.4855999946594238
F-4.536893671209162
tp10133
sS"if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    raise MyAppLookupError('resource is missing, and that is not ok.')"
p10134
(F-4.327898928993626
F-4.682748967950994
tp10135
sS"raise MyAppLookupError('resource is missing, and that is not ok.')"
p10136
(F-4.6383922576904295
F-4.5677268288352275
tp10137
sS'some_code_that_may_raise_our_value_error()'
p10138
(F-3.7077407836914062
F-4.59180381081321
tp10139
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    pass'
p10140
(F-2.3241757479580967
F-4.44409145008434
tp10141
sS"raise ValueError, 'message'"
p10142
(F-2.706892830984933
F-4.524707447398793
tp10143
sS'raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p10144
(F-2.38021240234375
F-4.516305750066584
tp10145
sS'class MyAppLookupError(LookupError):\n    pass'
p10146
(F-4.399844169616699
F-4.669147838245738
tp10147
sS'raise AssertionError("Unexpected value of \'distance\'!", distance)'
p10148
(F-3.1135467529296874
F-4.7323996803977275
tp10149
ssI2331943
(dp10150
S"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10151
(F-1.8602691650390626
F-1.5927619934082031
tp10152
sS'print json.load(u)\nu.close()'
p10153
(F-2.6551063537597654
F-1.4974510669708252
tp10154
sS'try:\n    import json\nexcept ImportError:\n    pass'
p10155
(F-1.0546213785807292
F-1.951114296913147
tp10156
sS'import urllib2'
p10157
(F-4.8463568687438965
F-1.815851092338562
tp10158
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10159
(F-2.28408416112264
F-1.741882085800171
tp10160
sS'import json'
p10161
(F-4.123467445373535
F-1.4637444019317627
tp10162
sS'import simplejson as json'
p10163
(F-4.232033093770345
F-1.4922785758972168
tp10164
sS'print json.load(u)'
p10165
(F-2.426871405707465
F-1.4524818658828735
tp10166
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10167
(F-1.754334222702753
F-1.5183279514312744
tp10168
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10169
(F-1.7300440470377605
F-1.5854341983795166
tp10170
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p10171
(F-1.950124740600586
F-1.670532464981079
tp10172
sS'u.close()'
p10173
(F-2.4370498657226562
F-2.3033387660980225
tp10174
sS'import urllib2\nimport json'
p10175
(F-3.207080296107701
F-1.6216511726379395
tp10176
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10177
(F-1.9203848662199798
F-1.5334980487823486
tp10178
sS"u = urllib2.urlopen('http://www.reddit.com/.json')"
p10179
(F-2.378474807739258
F-1.9360729455947876
tp10180
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p10181
(F-1.9249606499305139
F-1.5891369581222534
tp10182
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10183
(F-2.1989148457845054
F-1.7552034854888916
tp10184
sS'try:\n    import json\nexcept ImportError:\n    import simplejson as json'
p10185
(F-1.8068409874325706
F-1.6507692337036133
tp10186
ssI273192
(dp10187
S'os.makedirs(path, exist_ok=True)'
p10188
(F-2.7580599103655135
F-3.1738713582356772
tp10189
sS'if (not os.path.isdir(path)):\n    raise'
p10190
(F-2.1751725046258223
F-3.0463943481445312
tp10191
sS'if (not os.path.isdir(path)):\n    pass'
p10192
(F-1.5882909674393504
F-3.038671875
tp10193
sS'os.makedirs(directory)'
p10194
(F-1.6159188747406006
F-3.103358205159505
tp10195
sS'distutils.dir_util.mkpath(path)'
p10196
(F-3.377068201700846
F-3.094731903076172
tp10197
sS'import distutils.dir_util'
p10198
(F-4.607566833496094
F-3.103352355957031
tp10199
sS'raise'
p10200
(F-8.106512705485025
F-3.393397013346354
tp10201
sS'import distutils.dir_util\ndistutils.dir_util.mkpath(path)'
p10202
(F-3.7876249614514803
F-3.0421409606933594
tp10203
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        raise'
p10204
(F-1.4866714477539062
F-3.02482172648112
tp10205
sS'if (exception.errno != errno.EEXIST):\n    pass'
p10206
(F-3.0762571447035847
F-3.3931905110677083
tp10207
sS'import errno'
p10208
(F-5.249338150024414
F-3.3246365865071614
tp10209
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    pass'
p10210
(F-1.0188671458851208
F-3.053430684407552
tp10211
sS'if (not os.path.exists(directory)):\n    os.makedirs(directory)'
p10212
(F-1.612885316212972
F-3.059855651855469
tp10213
sS'if (not os.path.exists(directory)):\n    pass'
p10214
(F-1.7238809685958059
F-3.0587977091471354
tp10215
sS'import errno\n\ndef make_sure_path_exists(path):\n    pass'
p10216
(F-2.5268171483820137
F-3.2029459635416666
tp10217
sS'import os'
p10218
(F-3.7181167602539062
F-3.2239117940266926
tp10219
sS'os.makedirs(path)'
p10220
(F-1.3994758129119873
F-3.0782079060872394
tp10221
sS'def make_sure_path_exists(path):\n    pass'
p10222
(F-2.4258361392550998
F-3.187641906738281
tp10223
sS'if (exception.errno != errno.EEXIST):\n    raise'
p10224
(F-3.8413566140567554
F-3.4017822265625
tp10225
sS'import os\nimport errno\n\ndef make_sure_path_exists(path):\n    pass'
p10226
(F-2.18468994140625
F-3.1578643798828123
tp10227
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        pass'
p10228
(F-1.3210117942408512
F-3.017380777994792
tp10229
sS'import os\nimport errno'
p10230
(F-3.6735875265938893
F-3.2123138427734377
tp10231
ssI4020539
(dp10232
S'import codecs'
p10233
(F-5.210587024688721
F-3.2529476165771483
tp10234
sS"myString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10235
(F-3.042322794596354
F-2.9398866653442384
tp10236
sS"decoded_string = myString.decode('string_escape')\nprint decoded_string"
p10237
(F-2.895003000895182
F-3.014535903930664
tp10238
sS"return codecs.decode(match.group(0), 'unicode-escape')"
p10239
(F-2.984820604324341
F-2.980582046508789
tp10240
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10241
(F-3.1472069524949595
F-2.993844413757324
tp10242
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p10243
(F-2.698145839146205
F-2.975250244140625
tp10244
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10245
(F-2.738127731695408
F-2.9341026306152345
tp10246
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10247
(F-2.686560781378495
F-2.968815231323242
tp10248
sS'print decoded_string'
p10249
(F-4.40098508199056
F-3.0618852615356444
tp10250
sS"s = 'na\\xc3\\xafve \\\\t test'"
p10251
(F-2.3458072662353517
F-3.0131452560424803
tp10252
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10253
(F-3.087288185402199
F-2.921164703369141
tp10254
sS"def decode_match(match):\n    return codecs.decode(match.group(0), 'unicode-escape')"
p10255
(F-2.271967711272063
F-2.912158203125
tp10256
sS"myString = 'na\\xc3\\xafve \\\\t test'"
p10257
(F-2.6503562927246094
F-2.9501644134521485
tp10258
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10259
(F-3.127474251440016
F-2.942299652099609
tp10260
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10261
(F-3.2436651932565788
F-2.9797529220581054
tp10262
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p10263
(F-2.75542516293733
F-2.979862594604492
tp10264
sS'def decode_match(match):\n    pass'
p10265
(F-2.2425973074776784
F-2.9400588989257814
tp10266
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10267
(F-3.0901484633937026
F-2.9909027099609373
tp10268
sS"import codecs\nprint codecs.decode(s, 'unicode_escape')"
p10269
(F-3.055793217250279
F-3.1081886291503906
tp10270
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10271
(F-3.4024121319806135
F-2.9965900421142577
tp10272
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10273
(F-3.1248626708984375
F-2.911621856689453
tp10274
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10275
(F-2.8662661781793908
F-2.9445831298828127
tp10276
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10277
(F-2.5734005882626487
F-2.933399200439453
tp10278
sS"print decode_escapes('Ern\\xc5\\x91 \\\\t Rubik')"
p10279
(F-3.2918194664849176
F-3.1093210220336913
tp10280
sS'return ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10281
(F-3.992968839757583
F-3.219073486328125
tp10282
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10283
(F-2.6761279296875
F-2.9438716888427736
tp10284
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')"
p10285
(F-2.2338853493714943
F-2.984104347229004
tp10286
sS"decoded_string = myString.decode('string_escape')"
p10287
(F-2.6768241295447717
F-2.9920991897583007
tp10288
sS'import re\nimport codecs'
p10289
(F-3.866806302751814
F-2.9854267120361326
tp10290
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10291
(F-2.8477707806755514
F-2.9244478225708006
tp10292
sS'import re'
p10293
(F-4.289275646209717
F-3.063191032409668
tp10294
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p10295
(F-2.9362253824869793
F-3.03280029296875
tp10296
sS"print 'Ern\\xc5\\x91 \\\\t Rubik'.encode('latin-1').decode('unicode_escape')"
p10297
(F-1.297724996294294
F-3.072142791748047
tp10298
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)"
p10299
(F-2.8236794211647727
F-3.006333351135254
tp10300
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10301
(F-3.042322794596354
F-2.9398866653442384
tp10302
sS'def decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10303
(F-2.249325532179612
F-3.03782958984375
tp10304
sS"import codecs\nmyString = 'spam\\\\neggs'"
p10305
(F-3.735443115234375
F-3.0676727294921875
tp10306
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10307
(F-3.6993334452311197
F-2.98238582611084
tp10308
sS"s = 'na\\xc3\\xafve \\\\t test'\nprint s.encode('utf-8').decode('unicode_escape')"
p10309
(F-1.2473310894436307
F-3.0059667587280274
tp10310
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10311
(F-2.6142802382960464
F-2.9180355072021484
tp10312
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p10313
(F-2.7493144989013674
F-2.9841611862182615
tp10314
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10315
(F-2.70370795510032
F-2.9274738311767576
tp10316
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p10317
(F-2.937968995836046
F-3.0445966720581055
tp10318
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10319
(F-2.590004741281703
F-2.9149551391601562
tp10320
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10321
(F-2.878769665229611
F-2.929452133178711
tp10322
sS"myString = 'spam\\\\neggs'"
p10323
(F-2.6503562927246094
F-2.9501644134521485
tp10324
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p10325
(F-2.9427645002092633
F-3.0450956344604494
tp10326
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10327
(F-3.1902901785714284
F-2.9291828155517576
tp10328
sS'def decode_escapes(s):\n    pass'
p10329
(F-1.80520384652274
F-3.237896728515625
tp10330
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10331
(F-2.7100887658461086
F-2.9262725830078127
tp10332
sS"print codecs.decode(s, 'unicode_escape')"
p10333
(F-3.2105220447887075
F-3.0463186264038087
tp10334
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10335
(F-2.9976819356282554
F-2.98406925201416
tp10336
sS"print s.encode('utf-8').decode('unicode_escape')"
p10337
(F-1.4609996250697546
F-3.051530456542969
tp10338
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10339
(F-3.561513671875
F-2.99019718170166
tp10340
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10341
(F-2.6815403529575894
F-2.921293258666992
tp10342
sS"print s.encode('latin-1').decode('unicode_escape')"
p10343
(F-1.4609996250697546
F-3.051530456542969
tp10344
ssI21129020
(dp10345
S"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    pass"
p10346
(F-1.4125410715738933
F-4.083081697162829
tp10347
sS'import sys'
p10348
(F-4.1298909187316895
F-4.163822374845806
tp10349
sS'use_unicode = True'
p10350
(F-3.5528262002127513
F-4.294405485454359
tp10351
sS"sys.setdefaultencoding('utf8')"
p10352
(F-1.0873949527740479
F-3.9452390168842517
tp10353
sS'sys.getdefaultencoding()'
p10354
(F-2.287155423845564
F-4.0433096634714225
tp10355
sS"(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10356
(F-4.353387099045974
F-3.936297768040707
tp10357
sS"(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10358
(F-3.6751365661621094
F-3.9339977063630758
tp10359
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'"
p10360
(F-3.508721487862723
F-4.04157859400699
tp10361
sS'import sys\nreload(sys)'
p10362
(F-1.881296157836914
F-4.197513781095806
tp10363
sS'type(my_u)'
p10364
(F-3.2617297172546387
F-4.038719578793175
tp10365
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10366
(F-4.0321502685546875
F-3.9362640380859375
tp10367
sS"reload(sys)\nsys.setdefaultencoding('utf8')"
p10368
(F-1.3607069162222056
F-3.880552994577508
tp10369
sS"(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10370
(F-4.357559476579938
F-3.9322947451942847
tp10371
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'\ntype(my_u)"
p10372
(F-3.4157041822160994
F-4.039176539370888
tp10373
sS'my_unicode_string = my_file.read()'
p10374
(F-2.5424402872721354
F-4.104429947702508
tp10375
sS'import sys\nreload(sys)\nsys.getdefaultencoding()'
p10376
(F-1.7240740458170574
F-4.1703346653988485
tp10377
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p10378
(F-3.821410894393921
F-3.983895552785773
tp10379
sS"source = unicode(source, 'utf-8')"
p10380
(F-2.976618766784668
F-3.888040642989309
tp10381
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10382
(F-3.78082389831543
F-3.946651257966694
tp10383
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')"
p10384
(F-2.3050246238708496
F-3.9392949154502466
tp10385
sS"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    my_unicode_string = my_file.read()"
p10386
(F-1.8759498596191406
F-4.14071334035773
tp10387
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)\npsycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p10388
(F-4.142103625882056
F-4.085764834755345
tp10389
sS'reload(sys)'
p10390
(F-2.403330167134603
F-4.111461438630757
tp10391
sS'reload(sys)\nsys.getdefaultencoding()'
p10392
(F-2.3072071075439453
F-4.123660840486226
tp10393
sS"u'Z\\xfcrich'"
p10394
(F-3.5619519551595054
F-3.9900311921772205
tp10395
sS"charset = ('utf8',)"
p10396
(F-4.157785415649414
F-3.8917918958162008
tp10397
sS"charset = ('utf8',)\nuse_unicode = True"
p10398
(F-4.574643816266741
F-4.045096547980058
tp10399
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10400
(F-3.558325631277902
F-3.9420406943873356
tp10401
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10402
(F-3.964129799290707
F-3.9268047935084294
tp10403
sS"unicode('\\xe2\\x82\\xac')"
p10404
(F-3.1370197931925454
F-3.9481522409539473
tp10405
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')"
p10406
(F-3.2560128432053785
F-3.918890300549959
tp10407
sS"import sys\nreload(sys)\nsys.setdefaultencoding('utf8')"
p10408
(F-0.9676351547241211
F-3.8887939453125
tp10409
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)'
p10410
(F-4.434149742126465
F-4.0232993678042765
tp10411
ssI1854
(dp10412
S'platform.system()'
p10413
(F-2.956261771065848
F-4.777763366699219
tp10414
sS'import os\nprint os.name\nimport platform\nplatform.system()'
p10415
(F-2.7640389336480036
F-4.753044475208629
tp10416
sS'import platform\nplatform.system()'
p10417
(F-2.795568084716797
F-4.763522061434659
tp10418
sS'import os\nos.name\nimport platform\nplatform.system()'
p10419
(F-3.4457011503331803
F-4.7528509660200635
tp10420
sS'os.name'
p10421
(F-2.6959962844848633
F-4.770069469105113
tp10422
sS'os.name\nimport platform\nplatform.system()'
p10423
(F-3.58751950945173
F-4.741661071777344
tp10424
sS'os.name\nimport platform'
p10425
(F-4.039335250854492
F-4.723637667569247
tp10426
sS'os.name\nimport platform\nplatform.system()\nplatform.release()'
p10427
(F-3.327503204345703
F-4.756378867409446
tp10428
sS'import os\nprint os.name\nimport platform'
p10429
(F-2.852209726969401
F-4.734331304376775
tp10430
sS'import os\nos.name\nimport platform\nplatform.system()\nplatform.release()'
p10431
(F-3.2329018634298574
F-4.760379791259766
tp10432
sS'platform.system()\nplatform.release()'
p10433
(F-3.118282904991737
F-4.775029962713068
tp10434
sS'import os\nos.name\nimport platform'
p10435
(F-3.7112464904785156
F-4.738633589311079
tp10436
sS'import platform\nplatform.system()\nplatform.release()'
p10437
(F-2.8882522583007812
F-4.776596762917259
tp10438
sS'import os\nos.name'
p10439
(F-3.1287176609039307
F-4.755850358442827
tp10440
sS'platform.release()'
p10441
(F-3.0020463126046315
F-4.822907881303267
tp10442
sS'import os'
p10443
(F-3.6340832710266113
F-4.797266873446378
tp10444
sS'import platform'
p10445
(F-4.341142654418945
F-4.744379216974432
tp10446
sS'print os.name\nimport platform\nplatform.system()\nplatform.release()'
p10447
(F-3.179359799339658
F-4.756892117587003
tp10448
sS'print os.name\nimport platform\nplatform.system()'
p10449
(F-3.3825637817382814
F-4.7414422468705615
tp10450
sS'print os.name\nimport platform'
p10451
(F-4.065375434027778
F-4.707088123668324
tp10452
sS'print os.name'
p10453
(F-3.456451416015625
F-4.748194954612038
tp10454
sS'import os\nprint os.name\nimport platform\nplatform.system()\nplatform.release()'
p10455
(F-2.729759852091471
F-4.758818886496804
tp10456
sS'import os\nprint os.name'
p10457
(F-2.027328703138563
F-4.746635437011719
tp10458
ssI613183
(dp10459
S'd = defaultdict(int)\nfor w in text.split():\n    pass'
p10460
(F-2.142528360540217
F-2.9671852588653564
tp10461
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10462
(F-1.7414310773213704
F-1.9419910907745361
tp10463
sS'for w in text.split():\n    d[w] += 1'
p10464
(F-2.068519401550293
F-3.0469377040863037
tp10465
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10466
(F-1.877743590111826
F-1.9872519969940186
tp10467
sS'for w in sorted(d, key=d.get, reverse=True):\n    pass'
p10468
(F-2.0992282231648765
F-2.0236258506774902
tp10469
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10470
(F-1.7664052645365398
F-1.9369001388549805
tp10471
sS'd = defaultdict(int)'
p10472
(F-2.9061121940612793
F-2.626774311065674
tp10473
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10474
(F-1.8548690197514552
F-1.992031455039978
tp10475
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10476
(F-1.4993624479874321
F-1.7556157112121582
tp10477
sS'd = defaultdict(int)\nfor w in text.split():\n    d[w] += 1'
p10478
(F-2.1392008463541665
F-2.8346798419952393
tp10479
sS'import operator'
p10480
(F-5.240857124328613
F-2.9921116828918457
tp10481
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10482
(F-1.551116943359375
F-1.7460277080535889
tp10483
sS'for w in text.split():\n    pass'
p10484
(F-2.0522753397623696
F-3.2827064990997314
tp10485
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p10486
(F-2.4134061089877425
F-2.834585189819336
tp10487
sS'print w, d[w]'
p10488
(F-4.268756866455078
F-2.7729275226593018
tp10489
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p10490
(F-2.280442164494441
F-2.8311381340026855
tp10491
sS'd[w] += 1'
p10492
(F-3.243399143218994
F-2.67429518699646
tp10493
ssI3501382
(dp10494
S'x = Spam(0)'
p10495
(F-4.302731990814209
F-3.593780517578125
tp10496
sS'(type(x) == int)'
p10497
(F-3.8017906188964843
F-3.1345232183283027
tp10498
sS'try:\n    x += 1\nexcept TypeError:\n    pass'
p10499
(F-1.266378402709961
F-2.9911571849476206
tp10500
sS'for index in range(y):\n    pass'
p10501
(F-1.9916771480015345
F-2.9595440951260654
tp10502
sS'pass'
p10503
(F-2.6979904174804688
F-3.4885115189985796
tp10504
sS'import numbers\nisinstance(3, numbers.Integral)'
p10505
(F-3.9174722524789662
F-3.0421211936257104
tp10506
sS'float(5).is_integer()\nfloat(5.1).is_integer()'
p10507
(F-3.7837895932404892
F-3.0799754749644888
tp10508
sS'(type(x) == int)\nisinstance(x, int)'
p10509
(F-3.743282542509191
F-3.0967480052601206
tp10510
sS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p10511
(F-3.443806457519531
F-3.291756023060192
tp10512
sS'def is_int(val):\n    pass'
p10513
(F-1.9650468826293945
F-3.016847783868963
tp10514
sS'return True'
p10515
(F-2.930006980895996
F-3.2587901028719815
tp10516
sS'class Spam(int):\n    pass'
p10517
(F-2.6891053517659507
F-3.320492137562145
tp10518
sS'if (type(val) == int):\n    return True'
p10519
(F-2.574495427748736
F-3.0985658819025215
tp10520
sS'x = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p10521
(F-3.910053253173828
F-3.343547821044922
tp10522
sS'if (type(val) == int):\n    pass'
p10523
(F-2.491703987121582
F-3.095237038352273
tp10524
sS'return False'
p10525
(F-3.0517687797546387
F-3.2514384876598013
tp10526
sS'float(5).is_integer()\nfloat(5.1).is_integer()\nfloat(5.0).is_integer()'
p10527
(F-3.9036905625287224
F-3.088517969304865
tp10528
sS'def is_int(val):\n    if (type(val) == int):\n        return True'
p10529
(F-2.10662773677281
F-3.032576474276456
tp10530
sS'x += 1'
p10531
(F-2.7756912231445314
F-3.0433197021484375
tp10532
sS'float(5.1).is_integer()\nfloat(5.0).is_integer()'
p10533
(F-3.9284648065981655
F-3.1293217052112925
tp10534
sS'class Spam(int):\n    pass\nx = Spam(0)'
p10535
(F-3.284530238101357
F-3.4092767888849433
tp10536
sS'import numbers'
p10537
(F-4.843837261199951
F-2.987351504239169
tp10538
sS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)'
p10539
(F-3.4049715314592635
F-3.3415756225585938
tp10540
sS'float(5).is_integer()'
p10541
(F-3.0610373814900718
F-3.0530222112482246
tp10542
sS'def is_int(val):\n    if (type(val) == int):\n        pass'
p10543
(F-2.1808138246889466
F-3.0298045765269888
tp10544
sS'float(5.1).is_integer()'
p10545
(F-3.6446660359700522
F-3.127887725830078
tp10546
sS'isinstance(3, numbers.Integral)'
p10547
(F-4.047317123413086
F-3.0527624650435015
tp10548
sS'float(5.0).is_integer()'
p10549
(F-3.2459583282470703
F-3.0820492831143467
tp10550
sS'x = Spam(0)\n(type(x) == int)'
p10551
(F-4.0973367130055145
F-3.4282101717862217
tp10552
sS'isinstance(x, int)'
p10553
(F-2.341841220855713
F-3.0627982399680396
tp10554
ssI89228
(dp10555
S'print line,'
p10556
(F-4.877288055419922
F-2.5417137145996094
tp10557
sS'import subprocess'
p10558
(F-4.11272668838501
F-2.187392473220825
tp10559
sS"return_code = subprocess.call('echo Hello World', shell=True)"
p10560
(F-2.1882715225219727
F-2.113694429397583
tp10561
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p10562
(F-1.4506056352095171
F-2.1007766723632812
tp10563
sS'from subprocess import call'
p10564
(F-2.7691033681233725
F-2.1219727993011475
tp10565
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p10566
(F-1.1021876017252603
F-2.0889081954956055
tp10567
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p10568
(F-1.151692889985584
F-2.081653594970703
tp10569
sS"print os.popen('echo Hello World').read()"
p10570
(F-1.4326055966890776
F-2.1762239933013916
tp10571
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p10572
(F-1.008808576143705
F-2.063103437423706
tp10573
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p10574
(F-0.9711672684241985
F-2.0751452445983887
tp10575
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p10576
(F-1.5090411259577825
F-2.0946123600006104
tp10577
sS'for line in p.stdout.readlines():\n    pass'
p10578
(F-1.5663438684800093
F-2.223505735397339
tp10579
sS"print subprocess.Popen(('echo %s ' % user_input), stdout=PIPE).stdout.read()"
p10580
(F-2.271229095458984
F-2.112379789352417
tp10581
sS"os.system('some_command < input_file | another_command > output_file')"
p10582
(F-0.6678541898727417
F-2.1755285263061523
tp10583
sS"from subprocess import call\ncall(['ls', '-l'])"
p10584
(F-1.260797373453776
F-2.1493823528289795
tp10585
sS'for line in p.stdout.readlines():\n    print line,\nretval = p.wait()'
p10586
(F-2.181093004014757
F-2.18119740486145
tp10587
sS'retval = p.wait()'
p10588
(F-2.6036559210883246
F-2.152894973754883
tp10589
sS"print subprocess.Popen('echo Hello World', shell=True, stdout=subprocess.PIPE).stdout.read()"
p10590
(F-1.3925483703613282
F-2.080305576324463
tp10591
sS"call(['ls', '-l'])"
p10592
(F-1.2407723426818849
F-2.22275447845459
tp10593
ssI493386
(dp10594
S'print i,'
p10595
(F-5.817379379272461
F-3.2849146525065103
tp10596
sS"import sys\nsys.stdout.write('.')"
p10597
(F-1.0260970775897686
F-3.107262293497721
tp10598
sS"print ('Item %d: %s' % (i, strings[i]))"
p10599
(F-1.9958999633789063
F-2.9895057678222656
tp10600
sS'import sys'
p10601
(F-4.497166156768799
F-3.4540583292643228
tp10602
sS'sys.stdout.flush()'
p10603
(F-1.0857937071058485
F-3.103857676188151
tp10604
sS"strings = ['one', 'two', 'three']\nfor i in xrange(3):\n    pass"
p10605
(F-1.331302801767985
F-3.1164636611938477
tp10606
sS'from __future__ import print_function'
p10607
(F-1.6197427749633788
F-3.367469151814779
tp10608
sS'for i in xrange(3):\n    pass'
p10609
(F-1.333212035042899
F-3.2512779235839844
tp10610
sS'for i in range(10):\n    pass'
p10611
(F-1.1890152522495814
F-3.2379433314005532
tp10612
sS"strings = ['one', 'two', 'three']"
p10613
(F-2.155929218639027
F-3.1748603185017905
tp10614
sS'print'
p10615
(F-6.396015167236328
F-3.252326329549154
tp10616
sS"sys.stdout.write('.')"
p10617
(F-1.1221155166625976
F-3.089118321736654
tp10618
sS'for i in range(10):\n    print i,\nelse:\n    pass'
p10619
(F-1.4379289046577786
F-3.2208995819091797
tp10620
sS'for i in range(10):\n    print i,\nelse:\n    print'
p10621
(F-1.9323869788128396
F-3.1984761555989585
tp10622
sS"print ('.' * 10)"
p10623
(F-1.9502544403076172
F-3.0121278762817383
tp10624
ssI311627
(dp10625
S"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10626
(F-1.5640153695415977
F-2.1897688645582933
tp10627
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p10628
(F-2.0819072065682245
F-2.132211391742413
tp10629
sS'import datetime\nmylist = []\ntoday = datetime.date.today()'
p10630
(F-2.5304430911415503
F-2.1650995107797475
tp10631
sS"print ('This is a new day : ' + mylist[0])"
p10632
(F-2.0858244462446733
F-2.321642802311824
tp10633
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10634
(F-1.5246096241230866
F-2.1752571692833533
tp10635
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10636
(F-1.5256243192232573
F-2.181062404926007
tp10637
sS'today = datetime.date.today()\nmylist.append(today)'
p10638
(F-2.0558463202582464
F-2.1934295067420373
tp10639
sS"import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10640
(F-3.06278076171875
F-2.1429192469670224
tp10641
sS'print mylist[0]'
p10642
(F-3.101677485874721
F-2.5934498126690206
tp10643
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10644
(F-1.3115562092174182
F-2.1617167546198917
tp10645
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10646
(F-1.5257900122440222
F-2.1654092348538914
tp10647
sS"print 'Day of year: ', datetime.date.today().strftime('%j')"
p10648
(F-1.4424153496237362
F-2.145234914926382
tp10649
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10650
(F-1.5544077555338542
F-2.179231203519381
tp10651
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10652
(F-1.5257900122440222
F-2.1654092348538914
tp10653
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10654
(F-1.4612742832728796
F-2.1907633267916164
tp10655
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10656
(F-1.5560457384264148
F-2.1728602189284105
tp10657
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())"
p10658
(F-1.8103711869981554
F-2.1169151893028846
tp10659
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10660
(F-1.5683019728887648
F-2.14889408991887
tp10661
sS"print mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10662
(F-4.125352783203125
F-2.718928410456731
tp10663
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p10664
(F-2.476286263301455
F-2.13013428908128
tp10665
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10666
(F-1.5313018528761062
F-2.1903758415809045
tp10667
sS'import time\nimport datetime'
p10668
(F-3.196112496512277
F-2.283980736365685
tp10669
sS'import datetime\nmylist = []'
p10670
(F-3.3256893157958984
F-2.3201734102689304
tp10671
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10672
(F-1.5274365272051023
F-2.185033211341271
tp10673
sS'import datetime'
p10674
(F-3.8627562522888184
F-2.2278160682091346
tp10675
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())"
p10676
(F-1.6963240305582683
F-2.1177252255953274
tp10677
sS'for date in mylist:\n    pass'
p10678
(F-2.0743397799405185
F-2.742115020751953
tp10679
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p10680
(F-2.259221947711447
F-2.093938974233774
tp10681
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10682
(F-1.4511648608792214
F-2.1884165543776293
tp10683
sS"print 'This is a new day : ', mylist[0]"
p10684
(F-2.7257798512776694
F-2.4076370826134315
tp10685
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10686
(F-1.5741146050610588
F-2.179095048170823
tp10687
sS"'We are the 22, Nov 2008'"
p10688
(F-3.3686351776123047
F-2.4567190317007213
tp10689
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p10690
(F-2.3883977143660835
F-2.1382283430833082
tp10691
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10692
(F-1.5359495126517715
F-2.190843728872446
tp10693
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10694
(F-1.580395227191092
F-2.172632804283729
tp10695
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10696
(F-1.537195556640625
F-2.1848646310659556
tp10697
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10698
(F-1.5458266022917513
F-2.1684419191800632
tp10699
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10700
(F-3.267096799962661
F-2.154889620267428
tp10701
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10702
(F-1.5257900122440222
F-2.1654092348538914
tp10703
sS"today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10704
(F-3.2091783796037947
F-2.15717521080604
tp10705
sS"print 'Day of week: ', datetime.date.today().strftime('%A')"
p10706
(F-1.4424153496237362
F-2.145235061645508
tp10707
sS"print ('Time in seconds since the epoch: %s' % time.time())"
p10708
(F-1.6580483118693035
F-2.0997474376971903
tp10709
sS"print ('This is a new day : ' + str(mylist[0]))"
p10710
(F-1.717134611947196
F-2.3181985708383412
tp10711
sS"print 'We are the {:%d, %b %Y}'.format(today)"
p10712
(F-1.8393383026123047
F-2.152166953453651
tp10713
sS'print str(date)'
p10714
(F-2.6834348951067244
F-2.114141610952524
tp10715
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10716
(F-1.2102049418858118
F-2.144833491398738
tp10717
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10718
(F-1.0370729109820198
F-2.132283430833083
tp10719
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10720
(F-1.5274365272051023
F-2.185033211341271
tp10721
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10722
(F-1.464864005029729
F-2.1869788536658654
tp10723
sS'mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10724
(F-4.164382616678874
F-2.84215574998122
tp10725
sS'mylist = []\ntoday = datetime.date.today()'
p10726
(F-2.8823330402374268
F-2.1616433950570912
tp10727
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10728
(F-1.5274365272051023
F-2.185033211341271
tp10729
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p10730
(F-2.1850223541259766
F-2.1341940072866588
tp10731
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p10732
(F-2.2810821533203125
F-2.151704788208008
tp10733
sS"import time\nprint time.strftime('%Y-%m-%d %H:%M')"
p10734
(F-1.3724857966105144
F-2.0917323185847354
tp10735
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10736
(F-1.421904356583305
F-2.182075940645658
tp10737
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10738
(F-1.5696786832408745
F-2.1836588932917667
tp10739
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10740
(F-3.0674801781063987
F-2.136372052706205
tp10741
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10742
(F-1.541228755827873
F-2.1755237579345703
tp10743
sS"print 'Current date and time: ', datetime.datetime.now()"
p10744
(F-1.8926235834757488
F-2.1524936969463644
tp10745
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10746
(F-1.6046848643909801
F-2.146518120398888
tp10747
sS"mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10748
(F-3.2138149180310838
F-2.1822151770958533
tp10749
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10750
(F-1.566441175672743
F-2.187077155480018
tp10751
sS'mylist.append(today)\nprint mylist[0]'
p10752
(F-2.9807611192975725
F-2.7386436462402344
tp10753
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10754
(F-1.5256243192232573
F-2.181062551645132
tp10755
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10756
(F-1.5256243192232573
F-2.181062404926007
tp10757
sS"print 'We are the {:%d, %b %Y}'.format(today)\n'We are the 22, Nov 2008'"
p10758
(F-2.445546410300515
F-2.168814879197341
tp10759
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10760
(F-1.552521252241291
F-2.1879354623647838
tp10761
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p10762
(F-2.2713239192962646
F-2.1121258368858924
tp10763
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10764
(F-1.5533214065263856
F-2.1840890737680287
tp10765
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10766
(F-1.5246096241230866
F-2.1752571692833533
tp10767
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p10768
(F-2.1193360548753004
F-2.145705296443059
tp10769
sS"((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10770
(F-4.60428860313014
F-2.5125711881197414
tp10771
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10772
(F-1.5257900122440222
F-2.1654090881347656
tp10773
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10774
(F-1.5246096241230866
F-2.1752571692833533
tp10775
sS"print today.strftime('We are the %d, %b %Y')"
p10776
(F-1.8923136393229167
F-2.1136685884915867
tp10777
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10778
(F-1.453029199973824
F-2.1841605259821963
tp10779
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10780
(F-1.5514166695731026
F-2.1936168670654297
tp10781
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10782
(F-1.4384567825882524
F-2.185590010422927
tp10783
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10784
(F-1.5256243192232573
F-2.181062404926007
tp10785
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10786
(F-1.5768536037868923
F-2.138433896578275
tp10787
sS'print mylist[0]\n((2008 - 11) - 22)'
p10788
(F-4.662188361672794
F-2.7668348459097056
tp10789
sS"mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10790
(F-3.8940815925598145
F-2.8001324580265927
tp10791
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10792
(F-1.4150267380934496
F-2.1757976825420675
tp10793
sS"import datetime\nprint datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p10794
(F-0.7380332946777344
F-2.1531568673940806
tp10795
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10796
(F-1.4424153496237362
F-2.145235061645508
tp10797
sS'((2008 - 11) - 22)'
p10798
(F-5.268154144287109
F-2.502285883976863
tp10799
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10800
(F-1.5897095371300065
F-2.1628489861121545
tp10801
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10802
(F-1.5550572129546618
F-2.157814759474534
tp10803
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10804
(F-1.5294044730589562
F-2.1880119030292215
tp10805
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10806
(F-1.4424153496237362
F-2.145235061645508
tp10807
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10808
(F-1.5246096241230866
F-2.1752571692833533
tp10809
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10810
(F-1.5294044730589562
F-2.1880119030292215
tp10811
sS'import time'
p10812
(F-4.674698352813721
F-2.5517522371732273
tp10813
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10814
(F-1.3992504320646588
F-2.177507840670072
tp10815
sS"print 'Current year: ', datetime.date.today().strftime('%Y')"
p10816
(F-1.4424153496237362
F-2.145235061645508
tp10817
sS"print time.strftime('%Y-%m-%d %H:%M')"
p10818
(F-1.4959776136610243
F-2.089191436767578
tp10819
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10820
(F-1.3659456888834636
F-2.1711920224703274
tp10821
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10822
(F-1.5257901278409092
F-2.1654092348538914
tp10823
sS"print datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p10824
(F-0.9137245814005533
F-2.145504584679237
tp10825
sS'mylist = []'
p10826
(F-3.957056999206543
F-2.823311732365535
tp10827
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10828
(F-1.524609779825016
F-2.1752571692833533
tp10829
sS'today = datetime.date.today()'
p10830
(F-2.193426478992809
F-2.2530366457425632
tp10831
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10832
(F-1.5519044295601223
F-2.191049575805664
tp10833
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10834
(F-1.3802585212551817
F-2.168778346135066
tp10835
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10836
(F-3.2680622981144833
F-2.168902323796199
tp10837
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')"
p10838
(F-1.4424153496237362
F-2.145235061645508
tp10839
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10840
(F-1.5363698107130983
F-2.1881495255690355
tp10841
sS"print 'Month of year: ', datetime.date.today().strftime('%B')"
p10842
(F-1.4424153496237362
F-2.145234914926382
tp10843
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10844
(F-1.5257900122440222
F-2.1654092348538914
tp10845
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10846
(F-1.3150674068566524
F-2.1569348848783054
tp10847
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10848
(F-1.4741468799206638
F-2.18930171086238
tp10849
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10850
(F-1.5386677313288417
F-2.1807719010573168
tp10851
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10852
(F-1.6284690270057092
F-2.11408937894381
tp10853
sS'mylist.append(today)'
p10854
(F-2.494331121444702
F-2.673008551964393
tp10855
sS"print today.strftime('We are the %d, %b %Y')\n'We are the 22, Nov 2008'"
p10856
(F-2.6142874631014736
F-2.1025138268103967
tp10857
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10858
(F-1.4372918399763697
F-2.180591729971079
tp10859
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10860
(F-1.5592831578747979
F-2.163839193490835
tp10861
ssI1024847
(dp10862
S'print x\nx.update({3: 4, })\nprint x'
p10863
(F-4.224678441097862
F-2.064546585083008
tp10864
sS'data.pop(key)\ndata.clear()'
p10865
(F-2.6930324009486606
F-1.897237777709961
tp10866
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10867
(F-2.5201162610735213
F-1.8221380233764648
tp10868
sS"data.update({'a': 1, })"
p10869
(F-2.8547140268179088
F-1.996281051635742
tp10870
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10871
(F-2.515562551992911
F-1.9144941329956056
tp10872
sS'data.update(a=1)\ndata.update(data2)'
p10873
(F-2.9795853109920727
F-2.034415435791016
tp10874
sS'data = {}\ndata = dict()'
p10875
(F-2.53438663482666
F-1.8637149810791016
tp10876
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p10877
(F-2.362457275390625
F-1.9742950439453124
tp10878
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10879
(F-2.826998601194288
F-1.845700454711914
tp10880
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10881
(F-2.4983659082529495
F-1.8571491241455078
tp10882
sS'data.update(dict(a=1))'
p10883
(F-2.1862630110520582
F-1.857112503051758
tp10884
sS"d['mynewkey'] = 'mynewvalue'"
p10885
(F-1.7514927387237549
F-1.9673202514648438
tp10886
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10887
(F-2.7972554957613034
F-1.8600736618041993
tp10888
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]'
p10889
(F-3.0924191682235054
F-1.8858476638793946
tp10890
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p10891
(F-2.6685826371355756
F-1.8833305358886718
tp10892
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10893
(F-2.3895630306667752
F-1.8429605484008789
tp10894
sS'data.pop(key)'
p10895
(F-2.457585334777832
F-1.850680160522461
tp10896
sS'x = {1: 2, }'
p10897
(F-3.7730663299560545
F-2.0573776245117186
tp10898
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p10899
(F-2.274443860323924
F-1.9311256408691406
tp10900
sS'data = dict()'
p10901
(F-2.924891880580357
F-1.8728811264038085
tp10902
sS'data.update(dict(a=1))\ndata.update(a=1)'
p10903
(F-2.637561624700373
F-1.906964111328125
tp10904
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10905
(F-2.5859712299547697
F-1.8431182861328126
tp10906
sS'data.update(a=1)'
p10907
(F-2.7618183135986327
F-2.134627342224121
tp10908
sS"data['a'] = 1"
p10909
(F-1.9292807579040527
F-2.1334278106689455
tp10910
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10911
(F-2.566839770735981
F-1.8298519134521485
tp10912
sS"d = {'key': 'value', }\nprint d"
p10913
(F-2.689799969012921
F-1.966722297668457
tp10914
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p10915
(F-2.5161103039253048
F-1.937598419189453
tp10916
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10917
(F-2.4766816418580335
F-1.8413414001464843
tp10918
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]'
p10919
(F-2.7824083600725444
F-1.8891639709472656
tp10920
sS'data.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p10921
(F-2.9531447799117476
F-1.7658771514892577
tp10922
sS'data.update(data2)\ndel data[key]\ndata.pop(key)'
p10923
(F-3.0032684689476374
F-1.7638820648193358
tp10924
sS'print d'
p10925
(F-4.336969375610352
F-2.132352828979492
tp10926
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p10927
(F-2.7711809943704044
F-1.8624101638793946
tp10928
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10929
(F-2.555309295654297
F-1.8562372207641602
tp10930
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10931
(F-2.7652264106564406
F-1.8707902908325196
tp10932
sS'print x\nx.update({3: 4, })'
p10933
(F-4.529097080230713
F-2.0171085357666017
tp10934
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10935
(F-2.507556843307783
F-1.8292505264282226
tp10936
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10937
(F-2.457552823153409
F-1.8521434783935546
tp10938
sS'data.update(data2)\ndel data[key]'
p10939
(F-3.0610081808907643
F-1.8006492614746095
tp10940
sS"print d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p10941
(F-2.658353533063616
F-1.8773202896118164
tp10942
sS"data = {'a': 1, 'b': 2, 'c': 3, }"
p10943
(F-2.384026209513346
F-2.1289424896240234
tp10944
sS'del data[key]'
p10945
(F-2.6742281232561385
F-1.7758146286010743
tp10946
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10947
(F-2.5719552040100098
F-1.86485595703125
tp10948
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p10949
(F-2.4634515380859376
F-1.8591352462768556
tp10950
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10951
(F-2.6760258030247046
F-1.8958501815795898
tp10952
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10953
(F-2.4198751596304087
F-1.8865116119384766
tp10954
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p10955
(F-2.2267992743130387
F-1.934163475036621
tp10956
sS'del data[key]\ndata.pop(key)'
p10957
(F-2.7870965685163225
F-1.7558835983276366
tp10958
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10959
(F-2.4094271095850135
F-1.8460906982421874
tp10960
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10961
(F-2.679194450378418
F-1.8825895309448242
tp10962
sS'x.update({3: 4, })\nprint x'
p10963
(F-3.988213062286377
F-2.080086517333984
tp10964
sS"d = {'key': 'value', }"
p10965
(F-3.02384090423584
F-2.0098567962646485
tp10966
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10967
(F-2.668793799171985
F-1.8656938552856446
tp10968
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10969
(F-2.7984573364257814
F-1.8302984237670898
tp10970
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10971
(F-2.4085836699514678
F-1.8527618408203126
tp10972
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10973
(F-2.5561188046294863
F-1.8364986419677733
tp10974
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10975
(F-2.69576908991887
F-1.8506244659423827
tp10976
sS'data.clear()'
p10977
(F-2.255685261317662
F-2.238515281677246
tp10978
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p10979
(F-2.9962374369303384
F-1.8127758026123046
tp10980
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10981
(F-2.4865180969238283
F-1.8918075561523438
tp10982
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10983
(F-2.480286016696837
F-1.8619344711303711
tp10984
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10985
(F-2.7015874953497026
F-1.841423225402832
tp10986
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p10987
(F-2.789393742879232
F-1.8314990997314453
tp10988
sS'data.update(data2)'
p10989
(F-2.5212812423706055
F-1.936587142944336
tp10990
sS'data = dict(a=1, b=2, c=3)'
p10991
(F-2.777857886420356
F-1.9874500274658202
tp10992
sS'x = {1: 2, }\nprint x\nx.update({3: 4, })\nprint x'
p10993
(F-3.575362069266183
F-1.9605136871337892
tp10994
sS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p10995
(F-2.36541051449983
F-1.8777984619140624
tp10996
sS"print d\nd['mynewkey'] = 'mynewvalue'"
p10997
(F-2.960738095370206
F-1.9012107849121094
tp10998
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10999
(F-2.572202477088341
F-1.8742435455322266
tp11000
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)'
p11001
(F-2.705645067938443
F-1.913120651245117
tp11002
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p11003
(F-2.419300245202106
F-1.9185667037963867
tp11004
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11005
(F-2.807824876573351
F-1.8404767990112305
tp11006
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11007
(F-2.4411768030237266
F-1.849448013305664
tp11008
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11009
(F-2.8254248775652986
F-1.8235233306884766
tp11010
sS"data['a'] = 1\ndata.update({'a': 1, })"
p11011
(F-2.7938804626464844
F-2.0266170501708984
tp11012
sS'x.update({3: 4, })'
p11013
(F-4.132173978365385
F-2.0390663146972656
tp11014
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11015
(F-2.3906927774118825
F-1.8446846008300781
tp11016
sS'x = {1: 2, }\nprint x'
p11017
(F-3.0260684673602762
F-2.0915912628173827
tp11018
sS'print x'
p11019
(F-4.333120346069336
F-2.511393928527832
tp11020
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11021
(F-2.526851085906333
F-1.8470878601074219
tp11022
sS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'"
p11023
(F-2.50440673828125
F-1.8858640670776368
tp11024
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11025
(F-2.3437118530273438
F-1.9495983123779297
tp11026
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p11027
(F-3.0544667561848957
F-1.825718879699707
tp11028
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11029
(F-2.806473908600984
F-1.8703125
tp11030
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11031
(F-2.597289434754022
F-1.8344602584838867
tp11032
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11033
(F-2.3595833551316034
F-2.000309371948242
tp11034
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11035
(F-2.5578765869140625
F-1.870214080810547
tp11036
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p11037
(F-2.8061596098400297
F-1.8510461807250977
tp11038
sS'data = {}'
p11039
(F-2.8935635884602866
F-2.0350833892822267
tp11040
sS"data.update({'a': 1, })\ndata.update(dict(a=1))"
p11041
(F-2.6751162719726564
F-1.8438413619995118
tp11042
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11043
(F-2.472801513671875
F-1.9908687591552734
tp11044
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p11045
(F-2.336451344675832
F-1.840362548828125
tp11046
sS"d['mynewkey'] = 'mynewvalue'\nprint d"
p11047
(F-2.1624285958030005
F-1.9260778427124023
tp11048
sS'del data[key]\ndata.pop(key)\ndata.clear()'
p11049
(F-2.814645195007324
F-1.7658838272094726
tp11050
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p11051
(F-2.5632862636021208
F-1.995201873779297
tp11052
sS'x = {1: 2, }\nprint x\nx.update({3: 4, })'
p11053
(F-3.726156921386719
F-1.9355127334594726
tp11054
ssI120656
(dp11055
S"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p11056
(F-1.778501934475369
F-2.9425923029581704
tp11057
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p11058
(F-1.7212455240885416
F-2.9291610717773438
tp11059
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11060
(F-1.8141979217529296
F-2.9511340459187827
tp11061
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p11062
(F-2.045789198441939
F-2.947503407796224
tp11063
sS'for filename in filenames:\n    pass'
p11064
(F-1.682434775612571
F-3.0438753763834634
tp11065
sS"import os\nfor filename in os.listdir('C:\\\\temp'):\n    pass"
p11066
(F-0.9921204416375411
F-2.9016526540120444
tp11067
sS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11068
(F-1.9782702797337581
F-2.9158188501993814
tp11069
sS'print os.path.join(dirname, subdirname)'
p11070
(F-1.6707807687612681
F-3.120776812235514
tp11071
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p11072
(F-1.6856497998507518
F-2.9373753865559897
tp11073
sS"if ('.git' in dirnames):\n    pass"
p11074
(F-2.340582334078275
F-3.4675000508626304
tp11075
sS"dirnames.remove('.git')"
p11076
(F-2.728146553039551
F-3.4589951833089194
tp11077
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p11078
(F-1.7572123718261718
F-2.9654515584309897
tp11079
sS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p11080
(F-1.8100961627382222
F-2.8675225575764975
tp11081
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11082
(F-1.8644300188337053
F-2.967169443766276
tp11083
sS'for subdirname in dirnames:\n    pass'
p11084
(F-2.170669902454723
F-3.383836110432943
tp11085
sS'import os'
p11086
(F-3.4552066326141357
F-3.141628901163737
tp11087
sS'print filename'
p11088
(F-3.5111048221588135
F-3.0758530298868814
tp11089
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p11090
(F-1.8231078639174954
F-2.987319310506185
tp11091
sS'os.listdir(path)'
p11092
(F-1.2671136856079102
F-2.9502245585123696
tp11093
sS"for filename in os.listdir('C:\\\\temp'):\n    pass"
p11094
(F-1.292626142501831
F-2.9547882080078125
tp11095
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p11096
(F-1.8560736083984375
F-2.900471051534017
tp11097
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p11098
(F-1.9534573872884116
F-3.058047294616699
tp11099
sS'print os.path.join(dirname, filename)'
p11100
(F-1.5515003204345703
F-2.9722865422566733
tp11101
sS"if ('.git' in dirnames):\n    dirnames.remove('.git')"
p11102
(F-2.574978086683485
F-3.5273447036743164
tp11103
ssI2150739
(dp11104
S'import datetime'
p11105
(F-3.6893277168273926
F-3.497367165305398
tp11106
sS"from datetime import datetime\ndatetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p11107
(F-0.7634120941162109
F-3.3493083607066763
tp11108
sS'def utcoffset(self, dt):\n    pass'
p11109
(F-2.1269403185163225
F-4.351264953613281
tp11110
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p11111
(F-2.074595206124442
F-3.3291501131924717
tp11112
sS'def utcoffset(self, dt):\n    return timedelta(minutes=(-399))'
p11113
(F-2.791087938391644
F-4.22362587668679
tp11114
sS'class TZ(tzinfo):\n    pass'
p11115
(F-1.9811188379923503
F-4.364650726318359
tp11116
sS'return timedelta(minutes=(-399))'
p11117
(F-3.737733840942383
F-4.110600558194247
tp11118
sS'from datetime import tzinfo, timedelta, datetime'
p11119
(F-3.4019115447998045
F-3.2728389393199575
tp11120
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p11121
(F-1.8390428225199382
F-4.352463808926669
tp11122
sS'datetime.fromtimestamp(x)'
p11123
(F-1.9101492166519165
F-3.3136586275967685
tp11124
sS"from time import strftime\nstrftime('%Y-%m-%d %H:%M:%S')"
p11125
(F-1.7455602125688032
F-3.3614127419211646
tp11126
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11127
(F-3.9509292602539063
F-4.429477691650391
tp11128
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p11129
(F-2.3941525545987217
F-3.3421044783158735
tp11130
sS'from mx.DateTime.ISO import ParseDateTimeUTC'
p11131
(F-5.366755558894231
F-4.032048312100497
tp11132
sS'import datetime\ndatetime.datetime.now().isoformat()'
p11133
(F-1.011041522026062
F-3.2381473888050425
tp11134
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11135
(F-4.070537708423756
F-3.875765020197088
tp11136
sS'import datetime\ndatetime.datetime.utcnow().isoformat()'
p11137
(F-1.1895265579223633
F-3.253750887784091
tp11138
sS'datetime.datetime.now().isoformat()'
p11139
(F-1.0395851135253906
F-3.2582896839488638
tp11140
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n    pass'
p11141
(F-2.394257586935292
F-3.2491635409268467
tp11142
sS"from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11143
(F-2.815263509750366
F-3.3134897405450996
tp11144
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p11145
(F-2.341362461899266
F-4.277268149636009
tp11146
sS'datetime.datetime.utcnow().isoformat()'
p11147
(F-1.253133040208083
F-3.285103537819602
tp11148
sS'from datetime import datetime'
p11149
(F-2.541332244873047
F-3.3647082935680044
tp11150
sS"datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11151
(F-3.2781935192289806
F-3.349448810924183
tp11152
sS"datetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p11153
(F-0.6442038059234619
F-3.38503716208718
tp11154
sS"strftime('%Y-%m-%d %H:%M:%S')"
p11155
(F-1.3189186255137126
F-3.5863994251598013
tp11156
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11157
(F-2.5454661629416724
F-3.5130733143199575
tp11158
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11159
(F-3.5059536204618564
F-3.642269481312145
tp11160
sS'from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime'
p11161
(F-4.330911424424913
F-3.6593281139026987
tp11162
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11163
(F-3.006895626292509
F-3.777796658602628
tp11164
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11165
(F-3.071374257405599
F-3.5808216441761362
tp11166
sS"class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11167
(F-2.90297454258181
F-3.5410118103027344
tp11168
sS'from time import strftime'
p11169
(F-3.116937001546224
F-3.491625352339311
tp11170
ssI1186789
(dp11171
S"if (__name__ == '__main__'):\n    service_func()"
p11172
(F-2.254802703857422
F-1.740160998176126
tp11173
sS"print 'test1.py'"
p11174
(F-2.871284008026123
F-1.6972822301528032
tp11175
sS"def service_func():\n    print 'service func'"
p11176
(F-2.2554073333740234
F-1.7433785831227022
tp11177
sS'def service_func():\n    pass'
p11178
(F-2.176640437199519
F-1.7301025390625
tp11179
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p11180
(F-2.289900302886963
F-1.8304170720717485
tp11181
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p11182
(F-2.849703008478338
F-1.7866262548110063
tp11183
sS'service_func()'
p11184
(F-3.056000300816127
F-1.8399016436408548
tp11185
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p11186
(F-2.0798849378313338
F-1.7629749073701746
tp11187
sS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    pass"
p11188
(F-1.9520059313092912
F-1.7693325491512524
tp11189
sS"print 'in test 1, unproductive'"
p11190
(F-2.871284008026123
F-1.6972822301528032
tp11191
sS'import test1'
p11192
(F-6.285734176635742
F-1.492379805620979
tp11193
sS'def some_func():\n    pass'
p11194
(F-1.9318563021146333
F-1.765466016881606
tp11195
sS"subprocess.call('test1.py', shell=True)"
p11196
(F-1.128539244333903
F-1.4658033707562614
tp11197
sS"execfile('test2.py')"
p11198
(F-1.8821487426757812
F-1.4086424883674173
tp11199
sS"import test1\n\ndef service_func():\n    print 'service func'"
p11200
(F-2.8185751173231335
F-1.5698904149672563
tp11201
sS'import subprocess'
p11202
(F-4.132451057434082
F-1.402719497680664
tp11203
sS'import test1\n\ndef service_func():\n    pass'
p11204
(F-2.8424103680778954
F-1.5417370515711166
tp11205
sS"print 'service func'"
p11206
(F-2.871284008026123
F-1.6972822301528032
tp11207
sS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    some_func()"
p11208
(F-1.9822618961334229
F-1.8733630460851334
tp11209
sS"if (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p11210
(F-2.788169578269676
F-1.814093309290269
tp11211
sS"import subprocess\nsubprocess.call('test1.py', shell=True)"
p11212
(F-1.0275138854980468
F-1.442891289206112
tp11213
sS'some_func()'
p11214
(F-2.49118777683803
F-1.8565188015208525
tp11215
sS'test1.some_func()'
p11216
(F-3.149541007147895
F-1.7774162292480469
tp11217
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p11218
(F-2.4575865268707275
F-1.6322279537425322
tp11219
sS"if (__name__ == '__main__'):\n    some_func()"
p11220
(F-2.044504266036184
F-1.8042200873879826
tp11221
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p11222
(F-2.637215423583984
F-1.878188413732192
tp11223
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p11224
(F-2.6049022674560547
F-1.712607552023495
tp11225
sS"if (__name__ == '__main__'):\n    pass"
p11226
(F-1.8765664418538412
F-1.5708028007956112
tp11227
sS"def some_func():\n    print 'in test 1, unproductive'"
p11228
(F-2.0332467215401784
F-1.8036646001479204
tp11229
ssI1747817
(dp11230
S'dict(gen)'
p11231
(F-3.1916027069091797
F-1.9425298690795898
tp11232
sS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11233
(F-3.984470054751537
F-2.4005668640136717
tp11234
sS'd = {k: v for (k, v) in iterable}'
p11235
(F-2.4152971155503216
F-1.8591041564941406
tp11236
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p11237
(F-3.9007331000434027
F-2.252542495727539
tp11238
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11239
(F-2.7909228006998696
F-1.99759521484375
tp11240
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11241
(F-2.2698580184072816
F-2.0228328704833984
tp11242
sS'd = dict(map(key_value_gen, range(26)))'
p11243
(F-3.4037322998046875
F-1.8724491119384765
tp11244
sS'ts = [(1, 2), (3, 4), (5, 6)]'
p11245
(F-1.7065487737240999
F-2.052017402648926
tp11246
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11247
(F-3.340312842166785
F-2.1315759658813476
tp11248
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11249
(F-2.29911862886869
F-2.2341426849365233
tp11250
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))'
p11251
(F-3.547125244140625
F-2.049923896789551
tp11252
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)'
p11253
(F-1.8368385859898158
F-1.9664337158203125
tp11254
sS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p11255
(F-3.884151277087984
F-2.60089168548584
tp11256
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11257
(F-3.4055709838867188
F-2.0657577514648438
tp11258
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11259
(F-2.6542255032447075
F-2.054132080078125
tp11260
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11261
(F-3.433304234554893
F-2.015781593322754
tp11262
sS'def key_value_gen(k):\n    pass'
p11263
(F-2.7415239810943604
F-2.178131866455078
tp11264
sS'yield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11265
(F-4.523777610377262
F-2.266581344604492
tp11266
sS'yield chr((k + 65))'
p11267
(F-4.071949351917613
F-2.6332508087158204
tp11268
sS'd = {key: value for (key, value) in iterable}'
p11269
(F-2.642851885627298
F-1.8681547164916992
tp11270
sS'dict(ts)'
p11271
(F-2.755321502685547
F-1.9540185928344727
tp11272
sS'gen\ndict(gen)'
p11273
(F-6.258608341217041
F-1.9783243179321288
tp11274
sS'yield chr((((k + 13) % 26) + 65))'
p11275
(F-4.634614643297698
F-2.705950927734375
tp11276
sS'def key_value_gen(k):\n    yield chr((k + 65))'
p11277
(F-3.165208180745443
F-2.4649320602416993
tp11278
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11279
(F-3.2805589948381697
F-2.2402063369750977
tp11280
sS'gen'
p11281
(F-10.594987233479818
F-2.4010250091552736
tp11282
sS'd = dict(((key, value) for (key, value) in iterable))'
p11283
(F-2.563468412919478
F-1.850459098815918
tp11284
sS'd = {value: foo(value) for value in sequence if bar(value)}'
p11285
(F-3.55015382312593
F-1.855961227416992
tp11286
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11287
(F-3.9650543957221798
F-2.1464920043945312
tp11288
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11289
(F-2.697998046875
F-2.025884819030762
tp11290
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    pass'
p11291
(F-3.4064599114495353
F-1.8658418655395508
tp11292
ssI2793324
(dp11293
S'a = [1, 2, 3, 4]'
p11294
(F-2.0013675689697266
F-1.9515468373018152
tp11295
sS'if (c in a):\n    a.remove(c)'
p11296
(F-2.412079281277127
F-1.9376388998592602
tp11297
sS'pass'
p11298
(F-2.920550982157389
F-2.366942013011259
tp11299
sS'if (c in a):\n    pass'
p11300
(F-2.419221437894381
F-1.965769599465763
tp11301
sS'print a'
p11302
(F-5.05604362487793
F-2.1375117582433365
tp11303
sS"a.remove('b')"
p11304
(F-2.695037841796875
F-1.9645212958840763
tp11305
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]'
p11306
(F-1.6385725067883004
F-1.9363210341509651
tp11307
sS'if (6 in a):\n    pass'
p11308
(F-2.691868708683894
F-1.9948200899011947
tp11309
sS'a.remove(6)'
p11310
(F-3.015153408050537
F-1.9639351788689108
tp11311
sS'if (6 in a):\n    a.remove(6)'
p11312
(F-3.0607952541775174
F-1.9829321468577665
tp11313
sS'a = [x for x in a if (x != 2)]'
p11314
(F-2.0434099085190716
F-1.9096753737505745
tp11315
sS'a = [x for x in a if (x != 2)]\nprint a'
p11316
(F-2.2454753875732423
F-1.9128736608168657
tp11317
sS'a = [1, 2, 3, 4]\nif (6 in a):\n    a.remove(6)'
p11318
(F-2.5265401204427085
F-1.957259683048024
tp11319
sS'a.remove(c)'
p11320
(F-2.176689624786377
F-1.9245796203613281
tp11321
sS"a.remove('b')\nprint a"
p11322
(F-2.9180068969726562
F-2.009796142578125
tp11323
sS'a = [1, 2, 3, 4]\nif (6 in a):\n    pass'
p11324
(F-2.241239318847656
F-1.9573608847225414
tp11325
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')"
p11326
(F-1.5762993812561035
F-1.9840657851275276
tp11327
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]'
p11328
(F-1.7325296020507812
F-1.958381877225988
tp11329
sS'try:\n    a.remove(6)\nexcept:\n    pass'
p11330
(F-1.7378395080566407
F-2.0196142757640168
tp11331
sS'try:\n    a.remove(c)\nexcept ValueError:\n    pass'
p11332
(F-1.1795690709894353
F-2.003516028909122
tp11333
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]\nprint a'
p11334
(F-1.6738917610862039
F-1.9362164665670956
tp11335
sS"a = ['a', 'b', 'c', 'd']"
p11336
(F-1.7578631180983324
F-1.9826740938074447
tp11337
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')\nprint a"
p11338
(F-1.5226664335831352
F-1.9909605138442095
tp11339
ssI123198
(dp11340
S'from shutil import copyfile\ncopyfile(src, dst)'
p11341
(F-2.9142315204326925
F-1.0868439240889116
tp11342
sS"shutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p11343
(F-1.8824806213378906
F-1.1014953960071912
tp11344
sS"shutil.copy2('/dir/file.ext', '/new/dir')"
p11345
(F-1.8824806213378906
F-1.1014953960071912
tp11346
sS"import shutil\nshutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p11347
(F-1.3955858670748198
F-1.0685390125621448
tp11348
sS'from shutil import copyfile'
p11349
(F-3.71040948232015
F-0.9935306202281605
tp11350
sS'copyfile(src, dst)'
p11351
(F-3.340193510055542
F-1.2119468342174182
tp11352
sS'import shutil'
p11353
(F-4.958754062652588
F-1.1015229658647017
tp11354
ssI1602934
(dp11355
S'from collections import defaultdict\nd = defaultdict((lambda : 0))'
p11356
(F-3.2176551818847656
F-2.625575542449951
tp11357
sS'key = (i % 10)'
p11358
(F-3.44248538547092
F-2.723572095235189
tp11359
sS"('a' in d)\n('c' in d)"
p11360
(F-4.994222787710337
F-2.7246306737264
tp11361
sS'for i in xrange(100):\n    d[(i % 10)] += 1'
p11362
(F-2.108981588612432
F-3.059936205546061
tp11363
sS'd = defaultdict((lambda : 0))'
p11364
(F-3.8711201349894204
F-2.6326189041137695
tp11365
sS'd[key] = 1'
p11366
(F-2.596001625061035
F-2.632429758707682
tp11367
sS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p11368
(F-2.5579601190029044
F-2.8329334259033203
tp11369
sS'd = dict()\nfor i in xrange(100):\n    pass'
p11370
(F-1.6662429809570312
F-2.65701961517334
tp11371
sS"d = {'a': 1, 'b': 2, }"
p11372
(F-2.610752650669643
F-2.695376714070638
tp11373
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11374
(F-2.0407734264026987
F-2.6591211954752603
tp11375
sS'if (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11376
(F-1.7820489247639975
F-2.632596015930176
tp11377
sS"if ('key1' in dict):\n    print 'blah'\nelse:\n    print 'boo'"
p11378
(F-1.444234848022461
F-2.708337148030599
tp11379
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p11380
(F-2.055183563232422
F-2.656672954559326
tp11381
sS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p11382
(F-2.7576388549804687
F-2.7412548065185547
tp11383
sS'if (key in d):\n    d[key] += 1'
p11384
(F-2.0343695746527777
F-2.628878116607666
tp11385
sS'd[key] += 1'
p11386
(F-2.652097225189209
F-2.6462119420369468
tp11387
sS"('a' in d)"
p11388
(F-4.543421609061105
F-2.720360438028971
tp11389
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)'
p11390
(F-2.291575651902419
F-2.712625821431478
tp11391
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p11392
(F-2.2321775569472204
F-2.6621909141540527
tp11393
sS'd = dict()'
p11394
(F-2.8144283294677734
F-2.610461711883545
tp11395
sS"if ('key1' in dict):\n    pass"
p11396
(F-2.2526030907264123
F-2.6786009470621743
tp11397
sS"d = {'a': 1, 'b': 2, }\n('a' in d)"
p11398
(F-3.4607162475585938
F-2.671640396118164
tp11399
sS"if ('key1' in dict):\n    print 'blah'\nelse:\n    pass"
p11400
(F-1.6444527762276786
F-2.6899582544962564
tp11401
sS'for i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p11402
(F-2.2896419324372945
F-2.707551956176758
tp11403
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p11404
(F-2.322879275760135
F-2.7483949661254883
tp11405
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p11406
(F-2.1992773576216265
F-2.6584030787150064
tp11407
sS'from collections import defaultdict'
p11408
(F-3.1202519734700522
F-2.671170234680176
tp11409
sS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p11410
(F-2.4599629720052083
F-2.7301047643025718
tp11411
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p11412
(F-2.431650161743164
F-2.8412675857543945
tp11413
sS'for i in xrange(100):\n    pass'
p11414
(F-1.6001224517822266
F-2.9824705123901367
tp11415
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p11416
(F-2.1260334361683237
F-2.7380803426106772
tp11417
sS'for i in xrange(100):\n    key = (i % 10)'
p11418
(F-2.3879493713378905
F-3.0033963521321616
tp11419
sS"d = {'a': 1, 'b': 2, }\n('a' in d)\n('c' in d)"
p11420
(F-3.9328472430889425
F-2.6622482935587564
tp11421
sS'd[key] = (d.get(key, 0) + 1)'
p11422
(F-2.2548322175678455
F-2.637857755025228
tp11423
sS"print 'blah'"
p11424
(F-5.028534412384033
F-3.026010831197103
tp11425
sS"('c' in d)"
p11426
(F-4.543421609061105
F-2.720360438028971
tp11427
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p11428
(F-2.307499132658306
F-2.663240909576416
tp11429
sS'd[(i % 10)] += 1'
p11430
(F-3.3095035552978516
F-2.8962154388427734
tp11431
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11432
(F-2.1002170796297035
F-2.7079855600992837
tp11433
sS'if (key in d):\n    pass'
p11434
(F-2.1997495797964244
F-2.6065096855163574
tp11435
sS'if (key in d):\n    d[key] += 1\nelse:\n    pass'
p11436
(F-1.74055908203125
F-2.6169466972351074
tp11437
sS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p11438
(F-2.7784567440257355
F-2.84808349609375
tp11439
sS"print 'boo'"
p11440
(F-5.028534412384033
F-3.026010831197103
tp11441
ssI9573244
(dp11442
S'if (not my_string):\n    pass'
p11443
(F-2.073416301182338
F-2.1864911397298177
tp11444
sS"bool('   '.strip())"
p11445
(F-2.401996040344238
F-2.192552439371745
tp11446
sS"bool('')\nbool('   ')"
p11447
(F-3.868362079967152
F-2.1670679728190105
tp11448
sS'if some_string:\n    pass'
p11449
(F-2.142913644964045
F-2.246201578776042
tp11450
sS'if (not myString):\n    pass'
p11451
(F-2.3325525430532603
F-2.1891151428222657
tp11452
sS'if (not some_string):\n    pass'
p11453
(F-2.212820053100586
F-2.218627166748047
tp11454
sS"bool('   ')\nbool('   '.strip())"
p11455
(F-3.1813374837239583
F-2.1710431416829428
tp11456
sS'pass'
p11457
(F-2.8889617919921875
F-2.50069580078125
tp11458
sS"bool('')\nbool('   ')\nbool('   '.strip())"
p11459
(F-3.4355045318603517
F-2.1651087443033856
tp11460
sS"bool('   ')"
p11461
(F-3.48038387298584
F-2.187267812093099
tp11462
sS"bool('')"
p11463
(F-3.48038387298584
F-2.187267812093099
tp11464
ssI743806
(dp11465
S"words = text.split(',')"
p11466
(F-2.2950119018554687
F-1.4789723290337458
tp11467
sS"line = 'a sentence with a few words'\nline.split()"
p11468
(F-2.1267391551624644
F-1.5482892990112305
tp11469
sS'words = text.split()'
p11470
(F-2.6811258527967663
F-1.4761566585964627
tp11471
sS'line.split()'
p11472
(F-2.0177274431501115
F-1.5622244940863714
tp11473
sS'word.append(words)'
p11474
(F-2.3757622241973877
F-1.5570527182685003
tp11475
sS"line = 'a sentence with a few words'"
p11476
(F-3.2615013122558594
F-1.8308489057752821
tp11477
sS'words.append(word)'
p11478
(F-2.01035737991333
F-1.5605667961968317
tp11479
sS'text.split()'
p11480
(F-2.4316024780273438
F-1.5056577258639865
tp11481
ssI518021
(dp11482
S'len(l)\nlen(s)'
p11483
(F-2.5069252360950816
F-1.8656768798828125
tp11484
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)\nlen(s)"
p11485
(F-2.0379536946614585
F-2.0362674713134767
tp11486
sS"s = 'abcde'"
p11487
(F-4.040427398681641
F-2.125339126586914
tp11488
sS'my_tuple = (1, 2, 3, 4, 5)'
p11489
(F-2.4064752915326286
F-1.7825794219970703
tp11490
sS'my_tuple = (1, 2, 3, 4, 5)\nlen(my_tuple)'
p11491
(F-2.2305418650309243
F-1.8320436477661133
tp11492
sS'len(l)'
p11493
(F-2.114220301310221
F-1.8252870559692382
tp11494
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)"
p11495
(F-1.972367373379794
F-1.947622299194336
tp11496
sS"l = [1, 2, 3, 4]\ns = 'abcde'"
p11497
(F-2.352143231560202
F-1.8492622375488281
tp11498
sS'len(my_list)'
p11499
(F-1.6139965057373047
F-1.821108055114746
tp11500
sS"s = 'abcde'\nlen(l)"
p11501
(F-2.534119987487793
F-2.0814794540405273
tp11502
sS'my_list = [1, 2, 3, 4, 5]\nlen(my_list)'
p11503
(F-1.6633793512980144
F-1.8540367126464843
tp11504
sS"my_string = 'hello world'"
p11505
(F-2.878277369907924
F-2.061145210266113
tp11506
sS"my_string = 'hello world'\nlen(my_string)"
p11507
(F-2.0291573660714284
F-2.098240089416504
tp11508
sS'my_list = [1, 2, 3, 4, 5]'
p11509
(F-1.9399909973144531
F-1.7964958190917968
tp11510
sS"s = 'abcde'\nlen(l)\nlen(s)"
p11511
(F-2.4515719095865887
F-2.150715637207031
tp11512
sS'len(my_string)'
p11513
(F-1.9937145709991455
F-1.905374526977539
tp11514
sS'l = [1, 2, 3, 4]'
p11515
(F-2.178002724280724
F-1.787987518310547
tp11516
sS'len(my_tuple)'
p11517
(F-2.1505398750305176
F-1.8066417694091796
tp11518
sS'len(s)'
p11519
(F-2.22423521677653
F-1.910658073425293
tp11520
ssI510348
(dp11521
S"import time\nwhile True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p11522
(F-1.2172553062438964
F-1.9172207514444988
tp11523
sS'time.sleep(60)'
p11524
(F-1.0393645763397217
F-1.9719379742940266
tp11525
sS'from time import sleep'
p11526
(F-2.6110278765360513
F-2.0029425621032715
tp11527
sS"print 'This prints once a minute.'"
p11528
(F-3.123892307281494
F-2.1810434659322104
tp11529
sS'import time'
p11530
(F-3.905953884124756
F-2.070446014404297
tp11531
sS'time.sleep(5)'
p11532
(F-0.94374018907547
F-1.9710536003112793
tp11533
sS'sleep(0.1)'
p11534
(F-2.536471366882324
F-2.0348939895629883
tp11535
sS'import time\ntime.sleep(60)'
p11536
(F-1.1244239807128906
F-1.95351775487264
tp11537
sS'import time\ntime.sleep(5)'
p11538
(F-1.0173506303267046
F-1.953640302022298
tp11539
sS'from time import sleep\nsleep(0.1)'
p11540
(F-1.9293330799449573
F-1.9504084587097168
tp11541
sS'while True:\n    pass'
p11542
(F-1.4696788787841797
F-1.9643832842508953
tp11543
sS'time.sleep(0.1)'
p11544
(F-1.3211865425109863
F-1.9731591542561848
tp11545
sS"while True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p11546
(F-1.3201446533203125
F-1.920117696126302
tp11547
sS'import time\ntime.sleep(0.1)'
p11548
(F-1.3340965617786755
F-1.9454445838928223
tp11549
sS'import time\nwhile True:\n    pass'
p11550
(F-1.475675900777181
F-1.9684220949808757
tp11551
sS'time.sleep(time.localtime(time.time())[5])'
p11552
(F-1.702244186401367
F-1.836428960164388
tp11553
ssI82831
(dp11554
S"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p11555
(F-1.6895126714939024
F-1.3954749474158654
tp11556
sS"print os.path.isfile('/etc')"
p11557
(F-1.8729308735240588
F-1.3815508622389574
tp11558
sS"my_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p11559
(F-2.1391322796161356
F-1.4732528099646935
tp11560
sS"print os.path.exists('/etc/password.txt')"
p11561
(F-1.7019065510142932
F-1.406995333158053
tp11562
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11563
(F-1.711379641578311
F-1.4275518564077525
tp11564
sS'import os.path'
p11565
(F-3.2519092559814453
F-1.4164519676795373
tp11566
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p11567
(F-1.8792924426850819
F-1.3868924654447115
tp11568
sS'import os.path\nos.path.exists(file_path)'
p11569
(F-1.7166486627915327
F-1.390982407789964
tp11570
sS'pass'
p11571
(F-3.1729246775309243
F-1.8031627948467548
tp11572
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p11573
(F-1.71383543937437
F-1.402769528902494
tp11574
sS"from pathlib import Path\nmy_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p11575
(F-2.1704576553836947
F-1.4588248913104718
tp11576
sS"print os.path.isfile('/does/not/exist')"
p11577
(F-1.8729308735240588
F-1.3815508622389574
tp11578
sS"from pathlib import Path\nmy_file = Path('/path/to/file')"
p11579
(F-2.7553736368815103
F-1.4682913560133715
tp11580
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11581
(F-1.6401246233684261
F-1.4095831650954027
tp11582
sS'from pathlib import Path'
p11583
(F-3.1075127919514975
F-1.6124229431152344
tp11584
sS'os.path.isfile(fname)'
p11585
(F-1.7674571990966796
F-1.3818949185884917
tp11586
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11587
(F-1.5995900771197151
F-1.4137906294602613
tp11588
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')"
p11589
(F-1.8792924426850819
F-1.3868926121638372
tp11590
sS"print os.path.exists('/etc')"
p11591
(F-1.7019065510142932
F-1.406995333158053
tp11592
sS"my_file = Path('/path/to/file')"
p11593
(F-2.718394660949707
F-1.491308358999399
tp11594
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p11595
(F-1.7662106468563987
F-1.4126500349778395
tp11596
sS'if my_file.is_file():\n    pass'
p11597
(F-2.0472636503331803
F-1.5224139873798077
tp11598
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11599
(F-1.6447714528729838
F-1.4202999701866736
tp11600
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11601
(F-1.6085369971490675
F-1.4332976708045373
tp11602
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11603
(F-1.607332323418289
F-1.4061825092022235
tp11604
sS"print os.path.exists('/does/not/exist')"
p11605
(F-1.7019065510142932
F-1.4069951864389272
tp11606
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p11607
(F-1.7936752073226436
F-1.3839847858135517
tp11608
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11609
(F-1.5885246090772676
F-1.4246165935809796
tp11610
sS'import os.path\nos.path.isfile(fname)'
p11611
(F-1.9684153238932292
F-1.383730228130634
tp11612
sS"print os.path.isfile('/etc/password.txt')"
p11613
(F-1.8729308735240588
F-1.3815508622389574
tp11614
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11615
(F-1.6384881711473651
F-1.4018892141488881
tp11616
sS'os.path.exists(file_path)'
p11617
(F-1.496002197265625
F-1.3971939086914062
tp11618
sS"print os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11619
(F-1.711379641578311
F-1.4275518564077525
tp11620
ssI510357
(dp11621
S'def _find_getch():\n    pass'
p11622
(F-2.3293749002309947
F-3.0221357345581055
tp11623
sS'return ch\nreturn _getch\ngetch = _find_getch()'
p11624
(F-6.57303466796875
F-2.8897092819213865
tp11625
sS'fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11626
(F-2.3543739318847656
F-3.0973419189453124
tp11627
sS'def __init__(self):\n    pass'
p11628
(F-1.2306853703090124
F-3.2109329223632814
tp11629
sS'return self.impl()'
p11630
(F-3.349247694015503
F-3.668723297119141
tp11631
sS'def _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11632
(F-2.541455841064453
F-3.083039474487305
tp11633
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p11634
(F-1.7029315845386401
F-3.086947441101074
tp11635
sS'return ch\nreturn _getch'
p11636
(F-7.382086617606027
F-2.702891159057617
tp11637
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'"
p11638
(F-3.8434549967447915
F-2.7147308349609376
tp11639
sS'return _getch'
p11640
(F-7.4897966384887695
F-3.048061180114746
tp11641
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p11642
(F-2.252428967019786
F-2.937631607055664
tp11643
sS'tty.setraw(fd)'
p11644
(F-2.9705591201782227
F-3.175672149658203
tp11645
sS'tty.setraw(sys.stdin.fileno())'
p11646
(F-1.9054896490914481
F-2.775542449951172
tp11647
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p11648
(F-2.236461812799627
F-2.7304134368896484
tp11649
sS'def __call__(self):\n    pass'
p11650
(F-1.3733813422066825
F-3.288077163696289
tp11651
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p11652
(F-2.044778924239309
F-3.043523406982422
tp11653
sS'termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)'
p11654
(F-2.768486499786377
F-3.189841079711914
tp11655
sS'ch = sys.stdin.read(1)'
p11656
(F-2.5168657302856445
F-3.024768829345703
tp11657
sS'old_settings = termios.tcgetattr(fd)'
p11658
(F-3.1796251932779946
F-3.0446786880493164
tp11659
sS'def __call__(self):\n    import sys, tty, termios'
p11660
(F-2.5749435424804688
F-2.997344207763672
tp11661
sS'def _getch():\n    fd = sys.stdin.fileno()'
p11662
(F-2.257045545076069
F-3.1389617919921875
tp11663
sS'def __init__(self):\n    import tty, sys'
p11664
(F-2.195582670323989
F-2.8697017669677733
tp11665
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11666
(F-2.178590510441707
F-2.808968353271484
tp11667
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p11668
(F-2.258042907714844
F-2.980122375488281
tp11669
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p11670
(F-2.128787570529514
F-3.0567852020263673
tp11671
sS'def __init__(self):\n    import msvcrt'
p11672
(F-2.109544881184896
F-3.092342758178711
tp11673
sS'getch = _find_getch()'
p11674
(F-4.7719006008572045
F-3.0219161987304686
tp11675
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p11676
(F-2.72177859715053
F-2.762014389038086
tp11677
sS'return _getch\ngetch = _find_getch()'
p11678
(F-6.1178239186604815
F-3.0729799270629883
tp11679
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p11680
(F-2.028099536895752
F-3.041478157043457
tp11681
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11682
(F-3.265459758479421
F-2.9068180084228517
tp11683
sS'return msvcrt.getch'
p11684
(F-7.357458750406901
F-3.0878543853759766
tp11685
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        pass'
p11686
(F-1.6663909185500372
F-3.2550479888916017
tp11687
sS'import sys, tty\n\ndef _getch():\n    pass'
p11688
(F-2.3162442375631893
F-2.848887825012207
tp11689
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p11690
(F-1.753915248773037
F-2.7635520935058593
tp11691
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p11692
(F-2.2108595106336804
F-2.832924652099609
tp11693
sS'class _GetchWindows:\n\n    def __init__(self):\n        pass'
p11694
(F-1.708392403342507
F-3.0100177764892577
tp11695
sS'import termios'
p11696
(F-6.1766510009765625
F-3.361551284790039
tp11697
sS'return msvcrt.getch()'
p11698
(F-3.2259652614593506
F-3.16269474029541
tp11699
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p11700
(F-2.4031941223144533
F-2.9284032821655273
tp11701
sS'return ch\n\n\nclass _GetchWindows:\n    pass'
p11702
(F-3.721410624186198
F-2.830287551879883
tp11703
sS'getch = _Getch()'
p11704
(F-4.990645817347935
F-2.849516487121582
tp11705
sS'class _GetchUnix:\n\n    def __init__(self):\n        pass'
p11706
(F-1.689097144386985
F-2.8142839431762696
tp11707
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p11708
(F-3.2916477748325894
F-3.1161270141601562
tp11709
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11710
(F-2.0370411592371322
F-3.028552436828613
tp11711
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11712
(F-2.239568519592285
F-3.074993896484375
tp11713
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p11714
(F-1.6910233578439486
F-3.1289716720581056
tp11715
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p11716
(F-2.2905999755859376
F-2.827606964111328
tp11717
sS'fd = sys.stdin.fileno()'
p11718
(F-2.330821297385476
F-3.151061248779297
tp11719
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p11720
(F-2.589181937423407
F-3.0285337448120115
tp11721
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    pass'
p11722
(F-3.859363555908203
F-2.8707565307617187
tp11723
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p11724
(F-2.391785377679869
F-2.892298698425293
tp11725
sS'return ch'
p11726
(F-5.093133449554443
F-2.6585527420043946
tp11727
sS'self.impl = _GetchUnix()'
p11728
(F-3.3884986877441405
F-3.37294921875
tp11729
sS'def __call__(self):\n    return self.impl()'
p11730
(F-1.5636134900544818
F-3.531974029541016
tp11731
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p11732
(F-2.336742532664332
F-3.1080804824829102
tp11733
sS'return msvcrt.getch\nimport sys, tty'
p11734
(F-7.007222955877131
F-2.8227607727050783
tp11735
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p11736
(F-3.3930369059244794
F-2.916960525512695
tp11737
sS'self.impl = _GetchWindows()'
p11738
(F-3.51402587890625
F-3.7119800567626955
tp11739
sS'import tty, sys'
p11740
(F-6.037902196248372
F-2.7812808990478515
tp11741
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p11742
(F-2.4240122708407315
F-3.1751855850219726
tp11743
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p11744
(F-2.1058950878324962
F-2.929570198059082
tp11745
sS'class _GetchUnix:\n    pass'
p11746
(F-3.152303695678711
F-2.9168985366821287
tp11747
sS"'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p11748
(F-4.478065808614095
F-2.7283252716064452
tp11749
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p11750
(F-1.9820916069878471
F-3.1714786529541015
tp11751
sS'sys.stdin.read(1)'
p11752
(F-1.9108688354492187
F-3.154876136779785
tp11753
sS'class _GetchWindows:\n    pass'
p11754
(F-3.1706077575683596
F-3.1666534423828123
tp11755
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11756
(F-2.456387413872613
F-2.9298355102539064
tp11757
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p11758
(F-2.037819321091111
F-3.034462547302246
tp11759
sS'class _Getch:\n    pass'
p11760
(F-2.7579595777723522
F-2.7309650421142577
tp11761
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p11762
(F-3.8434549967447915
F-2.7147308349609376
tp11763
sS'import msvcrt'
p11764
(F-5.965415954589844
F-3.0566829681396483
tp11765
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'\n\ndef __init__(self):\n    pass"
p11766
(F-1.9590246781058933
F-2.771302032470703
tp11767
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'\n\ndef __init__(self):\n    pass"
p11768
(F-1.9590246781058933
F-2.771302032470703
tp11769
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        pass'
p11770
(F-2.296190473768446
F-2.8071285247802735
tp11771
sS'def __call__(self):\n    import msvcrt'
p11772
(F-2.347275797526042
F-3.2305835723876952
tp11773
sS'def _getch():\n    pass'
p11774
(F-1.8857095891779119
F-3.179270362854004
tp11775
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n    pass'
p11776
(F-2.0709940592447915
F-3.33673095703125
tp11777
sS'return msvcrt.getch()\ngetch = _Getch()'
p11778
(F-4.764502389090402
F-2.9375810623168945
tp11779
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p11780
(F-2.788665771484375
F-2.9114994049072265
tp11781
sS"'Gets a single character from standard input.  Does not echo to the screen.'"
p11782
(F-4.478065808614095
F-2.7283252716064452
tp11783
sS'import sys, tty'
p11784
(F-5.241628646850586
F-2.782581329345703
tp11785
sS'import sys, tty, termios'
p11786
(F-4.916141986846924
F-2.75372314453125
tp11787
ssI1450393
(dp11788
S'for line in fileinput.input():\n    pass'
p11789
(F-1.615512212117513
F-2.0138416290283203
tp11790
sS'import sys'
p11791
(F-4.422447204589844
F-2.2913279099897905
tp11792
sS'print line'
p11793
(F-4.0315141677856445
F-1.9924361489035867
tp11794
sS'for line in sys.stdin:\n    pass'
p11795
(F-1.5833634596604567
F-1.873918359929865
tp11796
sS'import fileinput\nfor line in fileinput.input():\n    pass'
p11797
(F-1.7820447285970051
F-1.965913252397017
tp11798
sS'import fileinput'
p11799
(F-5.577964782714844
F-1.9339127974076704
tp11800
sS'pass'
p11801
(F-3.383138656616211
F-2.507130362770774
tp11802
sS'import sys\nfor line in sys.stdin:\n    pass'
p11803
(F-1.406446933746338
F-1.8869639309969815
tp11804
ssI15411107
(dp11805
S'for key in keys_to_remove:\n    pass'
p11806
(F-2.3785692850748696
F-3.350414276123047
tp11807
sS'new_dict = {k: mydict[k] for k in keys_to_keep}'
p11808
(F-2.7066749225963247
F-3.328866195678711
tp11809
sS'try:\n    del mydict[key]\nexcept KeyError:\n    pass'
p11810
(F-1.4823704674130393
F-3.3161762237548826
tp11811
sS'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p11812
(F-2.671934647993608
F-3.271742248535156
tp11813
sS'for key in keys_to_remove:\n    del mydict[key]'
p11814
(F-2.319297188206723
F-3.3025180816650392
tp11815
sS'pass'
p11816
(F-2.8990770975748696
F-4.414750289916992
tp11817
sS'new_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p11818
(F-2.4872760194720644
F-3.3018638610839846
tp11819
sS'keys_to_keep = (set(mydict.keys()) - set(keys))'
p11820
(F-2.81292492410411
F-3.27166862487793
tp11821
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    pass'
p11822
(F-2.3760908026444283
F-3.2881107330322266
tp11823
sS'del mydict[key]'
p11824
(F-2.8799315861293246
F-3.2561058044433593
tp11825
sS'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: mydict[k] for k in keys_to_keep}'
p11826
(F-2.8898930983109907
F-3.275299072265625
tp11827
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))'
p11828
(F-2.387769858042399
F-3.294774627685547
tp11829
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    del mydict[key]'
p11830
(F-2.3453683399018788
F-3.268621063232422
tp11831
sS"mydict.pop('key', None)"
p11832
(F-2.3617431640625
F-3.342021942138672
tp11833
ssI466345
(dp11834
S"dt = parser.parse('Aug 28 1999 12:00AM')"
p11835
(F-2.3398975372314452
F-2.21535587310791
tp11836
sS'from dateutil import parser'
p11837
(F-4.50203005472819
F-2.111003875732422
tp11838
sS'from datetime import datetime'
p11839
(F-2.431782086690267
F-2.132864157358805
tp11840
sS"from datetime import datetime\ndate_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p11841
(F-1.314309270758378
F-2.069250742594401
tp11842
sS"date_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p11843
(F-1.3720041002546037
F-2.159341812133789
tp11844
sS"from dateutil import parser\ndt = parser.parse('Aug 28 1999 12:00AM')"
p11845
(F-2.608573404947917
F-2.006150245666504
tp11846
ssI8177079
(dp11847
S'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p11848
(F-2.4396549024079976
F-2.1077630519866943
tp11849
sS'c.extend(a)'
p11850
(F-2.143876552581787
F-1.9322209358215332
tp11851
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11852
(F-1.6567440032958984
F-1.9152992963790894
tp11853
sS'a = range(5)'
p11854
(F-3.1254544258117676
F-2.259714126586914
tp11855
sS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p11856
(F-3.6266839504241943
F-1.855056643486023
tp11857
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p11858
(F-2.5856281403572328
F-2.0496063232421875
tp11859
sS'pass'
p11860
(F-2.9842961629231772
F-2.7168428897857666
tp11861
sS'for logs in mydir:\n    for line in mylog:\n        list1.append(line)'
p11862
(F-2.712561289469401
F-1.9273113012313843
tp11863
sS'list1.append(line)'
p11864
(F-2.037755250930786
F-1.8569568395614624
tp11865
sS'c.extend(a)\nc'
p11866
(F-3.889778900146484
F-1.9565531015396118
tp11867
sS'b\nc.extend(a)'
p11868
(F-4.475161361694336
F-1.934847354888916
tp11869
sS"import itertools\np = ['a', 'b', 'c']"
p11870
(F-2.3748681204659596
F-2.0273373126983643
tp11871
sS'for logs in mydir:\n    pass'
p11872
(F-3.273501656272195
F-2.015880823135376
tp11873
sS'b.append(a)\nb'
p11874
(F-3.5647628784179686
F-1.9914964437484741
tp11875
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p11876
(F-1.5402017408801663
F-2.0725419521331787
tp11877
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)'
p11878
(F-2.049382571516366
F-2.207216501235962
tp11879
sS'for line in mylog:\n    pass'
p11880
(F-2.6658606095747515
F-2.0019800662994385
tp11881
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)'
p11882
(F-2.7355753580729165
F-2.0011792182922363
tp11883
sS'b.append(a)\nb\nc.extend(a)'
p11884
(F-3.029148774988511
F-1.9249329566955566
tp11885
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p11886
(F-3.330184056208684
F-2.001591205596924
tp11887
sS'for x in itertools.chain(p, q, r):\n    pass'
p11888
(F-2.100206184387207
F-1.9093941450119019
tp11889
sS"r = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11890
(F-1.8411801656087239
F-1.9007034301757812
tp11891
sS'c = range(2)\nb.append(a)'
p11892
(F-2.110242462158203
F-2.073498487472534
tp11893
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    pass"
p11894
(F-3.17110524279006
F-1.9154711961746216
tp11895
sS'a = range(5)\nb = range(3)'
p11896
(F-2.7420832316080728
F-2.3307855129241943
tp11897
sS"p = ['a', 'b', 'c']"
p11898
(F-2.3744477358731357
F-2.13010311126709
tp11899
sS'list1.extend(mylog)'
p11900
(F-3.579888105392456
F-1.9752914905548096
tp11901
sS'for line in mylog:\n    list1.append(line)'
p11902
(F-2.209547281265259
F-1.9153244495391846
tp11903
sS'b.append(a)\nb\nc.extend(a)\nc'
p11904
(F-3.8123980070415295
F-1.935403823852539
tp11905
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p11906
(F-2.835827445983887
F-2.1033339500427246
tp11907
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb'
p11908
(F-2.545718285345262
F-2.209360361099243
tp11909
sS'list2.extend(list1)'
p11910
(F-2.651362895965576
F-1.893402099609375
tp11911
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11912
(F-1.5596420000184257
F-1.9223287105560303
tp11913
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11914
(F-1.5386924743652344
F-1.9206633567810059
tp11915
sS'for logs in mydir:\n    for line in mylog:\n        pass'
p11916
(F-3.1047746758711967
F-1.96998131275177
tp11917
sS'list2.append(list1)'
p11918
(F-2.3383960723876953
F-1.8840340375900269
tp11919
sS'c = range(2)\nb.append(a)\nb'
p11920
(F-3.053759630988626
F-2.07820463180542
tp11921
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p11922
(F-3.3289453679865058
F-1.9006696939468384
tp11923
sS'b = range(3)\nc = range(2)\nb.append(a)\nb'
p11924
(F-2.7751941680908203
F-2.1303961277008057
tp11925
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p11926
(F-3.2016977163461537
F-1.9101982116699219
tp11927
sS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p11928
(F-3.41485622011382
F-1.8649282455444336
tp11929
sS'b.append(a)'
p11930
(F-1.7731730937957764
F-1.9819748401641846
tp11931
sS'import itertools'
p11932
(F-4.726873397827148
F-2.0304014682769775
tp11933
sS"if any((True for line in list1 if ('string' in line))):\n    pass"
p11934
(F-3.4169114430745444
F-1.885497808456421
tp11935
sS"r = ['g', 'h', 'i']"
p11936
(F-2.3202382867986504
F-2.1321170330047607
tp11937
sS'c'
p11938
(F-9.533734639485678
F-2.3173229694366455
tp11939
sS'b'
p11940
(F-9.782062530517578
F-2.2717125415802
tp11941
sS'b = range(3)'
p11942
(F-3.233287811279297
F-2.2546095848083496
tp11943
sS'c = range(2)'
p11944
(F-3.092241048812866
F-2.2765021324157715
tp11945
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p11946
(F-1.8360125223795574
F-2.030139446258545
tp11947
sS'b = range(3)\nc = range(2)\nb.append(a)'
p11948
(F-2.1242299513383345
F-2.1247458457946777
tp11949
sS'b = range(3)\nc = range(2)'
p11950
(F-2.803246561686198
F-2.2794134616851807
tp11951
sS'b\nc.extend(a)\nc'
p11952
(F-5.3238983154296875
F-1.9541248083114624
tp11953
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p11954
(F-1.760804675874256
F-2.0843868255615234
tp11955
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p11956
(F-1.7781034197126115
F-2.0971052646636963
tp11957
sS"q = ['d', 'e', 'f']"
p11958
(F-2.397169980135831
F-2.144195795059204
tp11959
sS'a = range(5)\nb = range(3)\nc = range(2)'
p11960
(F-2.5153926502574575
F-2.3308982849121094
tp11961
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p11962
(F-1.6006353041704964
F-2.022183895111084
tp11963
sS'del list1'
p11964
(F-6.50795841217041
F-1.892764687538147
tp11965
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p11966
(F-3.0561592795632104
F-2.0467817783355713
tp11967
ssI455612
(dp11968
S"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p11969
(F-4.3142006613991475
F-4.740139007568359
tp11970
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng"
p11971
(F-4.1867254348028276
F-4.774868965148926
tp11972
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))'
p11973
(F-4.035235450381324
F-5.261049270629883
tp11974
sS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p11975
(F-2.2994618007114958
F-4.774357318878174
tp11976
sS'a = 13.946\nprint a'
p11977
(F-3.0852952003479004
F-5.291328430175781
tp11978
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p11979
(F-2.7092347321686923
F-4.8331146240234375
tp11980
sS'(234042163 / (2 ** 24))\na = 13.946\nprint a'
p11981
(F-3.8746125962999134
F-4.990187644958496
tp11982
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946'
p11983
(F-4.328722534179687
F-5.254968643188477
tp11984
sS"('%.2f' % 3.14159)\n('%.2f' % 13.9499999)"
p11985
(F-4.726437495304988
F-4.9794440269470215
tp11986
sS"print '{0:.2f}'.format(round(a, 2))"
p11987
(F-2.3349530356270924
F-4.771991729736328
tp11988
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p11989
(F-3.5415753965024597
F-4.900520324707031
tp11990
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p11991
(F-3.188800987830529
F-4.842536449432373
tp11992
sS'(234042163 / (2 ** 24))\na = 13.946'
p11993
(F-4.455717976888021
F-4.985077857971191
tp11994
sS'h'
p11995
(F-9.75286865234375
F-5.406493186950684
tp11996
sS'h\n(x == h)'
p11997
(F-6.194628397623698
F-5.0686750411987305
tp11998
sS'x'
p11999
(F-8.762770970662435
F-5.24100399017334
tp12000
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))"
p12001
(F-3.2632976331208883
F-4.746660232543945
tp12002
sS"g = float('{0:.2f}'.format(x))\ng"
p12003
(F-3.7142934163411456
F-4.771123886108398
tp12004
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12005
(F-3.8687924702962238
F-4.737774848937988
tp12006
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12007
(F-2.7321321759905133
F-4.827088356018066
tp12008
sS'(x == g)\nh = round(x, 2)'
p12009
(F-4.441827297210693
F-4.767077445983887
tp12010
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12011
(F-2.8138846657492897
F-4.846136569976807
tp12012
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12013
(F-4.266487121582031
F-4.740816116333008
tp12014
sS"a = 13.946\nprint a\nprint ('%.2f' % a)"
p12015
(F-3.137015533447266
F-5.109654426574707
tp12016
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12017
(F-2.865144729614258
F-4.8139801025390625
tp12018
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)"
p12019
(F-3.8956638881138392
F-5.153818130493164
tp12020
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12021
(F-4.614062140969669
F-4.7394514083862305
tp12022
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p12023
(F-2.934598586138557
F-4.882017135620117
tp12024
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12025
(F-2.962069647652762
F-4.830863952636719
tp12026
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12027
(F-3.242880040949041
F-4.855395317077637
tp12028
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12029
(F-2.677820924852715
F-4.799056529998779
tp12030
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12031
(F-2.6950597763061523
F-4.809388160705566
tp12032
sS"print '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12033
(F-2.508045620388455
F-4.744235992431641
tp12034
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p12035
(F-3.112351735432943
F-4.862356185913086
tp12036
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12037
(F-4.075950905128762
F-4.741781234741211
tp12038
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12039
(F-2.8603550980730756
F-4.812897682189941
tp12040
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12041
(F-3.3064539982722354
F-4.857382297515869
tp12042
sS'h = round(x, 2)\nh\n(x == h)'
p12043
(F-4.337938944498698
F-4.791778564453125
tp12044
sS"print a\nprint ('%.2f' % a)\nround(a, 2)"
p12045
(F-3.526187049018012
F-4.8616557121276855
tp12046
sS'g\n(x == g)'
p12047
(F-6.047275543212891
F-5.121254920959473
tp12048
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12049
(F-4.4239959716796875
F-4.738046169281006
tp12050
sS'x = 13.95'
p12051
(F-4.2184192657470705
F-5.254024505615234
tp12052
sS'g\n(x == g)\nh = round(x, 2)\nh\n(x == h)'
p12053
(F-5.103362450232873
F-4.785953521728516
tp12054
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12055
(F-2.902572813488188
F-4.874238014221191
tp12056
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p12057
(F-3.1630443226207388
F-4.880287170410156
tp12058
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12059
(F-4.103637271457249
F-4.7344560623168945
tp12060
sS"print ('%.2f' % round(a, 2))"
p12061
(F-2.3967502300555887
F-4.804264545440674
tp12062
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12063
(F-2.926669251685049
F-4.829135894775391
tp12064
sS'(125650429603636838 / (2 ** 53))'
p12065
(F-4.137276042591441
F-5.463547706604004
tp12066
sS"print '{0:.15f}'.format(round(a, 2))"
p12067
(F-2.3349530356270924
F-4.771991729736328
tp12068
sS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12069
(F-2.678676968529111
F-4.813326835632324
tp12070
sS"x\ng = float('{0:.2f}'.format(x))\ng"
p12071
(F-4.498299991383272
F-4.762650489807129
tp12072
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12073
(F-3.1121722490359573
F-4.82841682434082
tp12074
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12075
(F-3.733822777157738
F-4.744256973266602
tp12076
sS"print a\nprint ('%.2f' % a)"
p12077
(F-3.60415337302468
F-5.19852876663208
tp12078
sS'(x == h)'
p12079
(F-4.996337345668247
F-5.006950378417969
tp12080
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))"
p12081
(F-3.011811447143555
F-4.838082313537598
tp12082
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p12083
(F-4.468349838256836
F-4.742588996887207
tp12084
sS"x\ng = float('{0:.2f}'.format(x))"
p12085
(F-3.360939534505208
F-4.739484786987305
tp12086
sS"float('{0:.2f}'.format(13.95))"
p12087
(F-2.2799354900013316
F-4.77766227722168
tp12088
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p12089
(F-3.8104811168852306
F-4.922787666320801
tp12090
sS"g = float('{0:.2f}'.format(x))"
p12091
(F-2.1301903357872596
F-4.739189147949219
tp12092
sS'(x == g)\nh = round(x, 2)\nh'
p12093
(F-5.075723012288411
F-4.7730607986450195
tp12094
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12095
(F-4.268536567687988
F-4.7368879318237305
tp12096
sS'g'
p12097
(F-9.243115743001303
F-5.495299339294434
tp12098
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p12099
(F-4.171022917094984
F-4.743646621704102
tp12100
sS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12101
(F-2.642298978917739
F-4.779743671417236
tp12102
sS'g\n(x == g)\nh = round(x, 2)\nh'
p12103
(F-5.548845672607422
F-4.785348892211914
tp12104
sS"print ('%.2f' % a)"
p12105
(F-2.105900526046753
F-5.066640853881836
tp12106
sS"print ('%.2f' % a)\nround(a, 2)"
p12107
(F-2.90532964070638
F-4.816022872924805
tp12108
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)"
p12109
(F-3.7846578979492187
F-4.932877540588379
tp12110
sS'a = 13.946'
p12111
(F-4.388692092895508
F-5.225684642791748
tp12112
sS"('%.2f' % 13.9499999)"
p12113
(F-4.942526681082589
F-5.022424697875977
tp12114
sS'g\n(x == g)\nh = round(x, 2)'
p12115
(F-5.042449527316624
F-4.775350093841553
tp12116
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p12117
(F-3.3914722095836294
F-4.851184368133545
tp12118
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12119
(F-3.4520081550844255
F-4.903128623962402
tp12120
sS'print a'
p12121
(F-4.583100318908691
F-5.641678810119629
tp12122
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12123
(F-4.302367500636889
F-4.736246109008789
tp12124
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12125
(F-2.8051760638201677
F-4.802737712860107
tp12126
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12127
(F-3.329503580729167
F-4.8743791580200195
tp12128
sS'x = 13.95\nx'
p12129
(F-5.361902509416852
F-5.250268936157227
tp12130
sS'h = round(x, 2)'
p12131
(F-3.339300537109375
F-4.788232326507568
tp12132
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12133
(F-3.046303397730777
F-4.854355335235596
tp12134
sS'(234042163 / (2 ** 24))'
p12135
(F-3.8395125649192114
F-4.954171180725098
tp12136
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p12137
(F-3.6978647708892822
F-4.817352771759033
tp12138
sS"'{0:.2f}'.format(13.95)"
p12139
(F-3.0661261081695557
F-4.947971820831299
tp12140
sS'(x == g)\nh = round(x, 2)\nh\n(x == h)'
p12141
(F-4.715930620829265
F-4.7779107093811035
tp12142
sS'(x == g)'
p12143
(F-5.059618268694196
F-4.999041557312012
tp12144
sS'round(a, 2)'
p12145
(F-2.93465518951416
F-4.814300060272217
tp12146
sS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12147
(F-2.1738591627641157
F-4.819726943969727
tp12148
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12149
(F-2.7745038200827206
F-4.828054428100586
tp12150
sS"print '{0:.2f}'.format(a)"
p12151
(F-1.8105843861897786
F-4.978174686431885
tp12152
sS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12153
(F-2.625932896390874
F-4.767272472381592
tp12154
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a'
p12155
(F-3.9706036703927174
F-5.254440784454346
tp12156
sS'h = round(x, 2)\nh'
p12157
(F-4.595247268676758
F-4.786086082458496
tp12158
sS"('%.2f' % 3.14159)"
p12159
(F-4.942526681082589
F-5.022424697875977
tp12160
ssI73663
(dp12161
S'sys.exit()'
p12162
(F-1.2462215423583984
F-2.424946943918864
tp12163
sS'if (this == that):\n    pass'
p12164
(F-4.0965567368727465
F-3.2354981104532876
tp12165
sS'import sys'
p12166
(F-4.270438194274902
F-2.487346967061361
tp12167
sS'if (this == that):\n    quit()'
p12168
(F-3.796448008219401
F-2.8615798950195312
tp12169
sS'import sys\nsys.exit()'
p12170
(F-0.9101922988891602
F-2.3818092346191406
tp12171
sS'quit()'
p12172
(F-2.0775142669677735
F-2.4539238611857095
tp12173
sS'raise SystemExit'
p12174
(F-4.136482238769531
F-2.5548531214396157
tp12175
ssI1476
(dp12176
S"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))"
p12177
(F-2.8850603103637695
F-3.0335526899857954
tp12178
sS"int('010101', 2)"
p12179
(F-2.8338918685913086
F-3.0116521661931817
tp12180
sS'21'
p12181
(F-8.017759958902994
F-3.248551455411044
tp12182
sS"int('10101', 0)\nint('0b10101', 0)"
p12183
(F-3.3575124104817706
F-3.0074813149192114
tp12184
sS'bin(21)'
p12185
(F-4.000843683878581
F-3.0969602411443535
tp12186
sS'47'
p12187
(F-8.898511250813803
F-3.2996368408203125
tp12188
sS"int('0b10101', 0)"
p12189
(F-2.7838056087493896
F-3.0167583118785513
tp12190
sS"print int('01010101111', 2)"
p12191
(F-2.935749053955078
F-2.9982317144220527
tp12192
sS"int('0b0010101010', 2)"
p12193
(F-2.8338918685913086
F-3.0116521661931817
tp12194
sS"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))\nformat(int('010101', 2), '010b')"
p12195
(F-3.12160407172309
F-3.026071721857244
tp12196
sS'170\n21'
p12197
(F-6.818707275390625
F-3.1811592795632104
tp12198
sS'bin(173)'
p12199
(F-3.0086568196614585
F-3.0811614990234375
tp12200
sS"int('10101', 0)"
p12201
(F-2.7838056087493896
F-3.0167583118785513
tp12202
sS"format(int('010101', 2), '010b')"
p12203
(F-2.9042992225060096
F-2.9816228693181817
tp12204
sS"bin(int('010101', 2))"
p12205
(F-2.8415437178178267
F-2.965057373046875
tp12206
sS"print int('01010101111', 2)\nprint int('11111111', 2)"
p12207
(F-3.0217751895680145
F-3.02611645785245
tp12208
sS"print int('11111111', 2)"
p12209
(F-2.935749053955078
F-2.9982317144220527
tp12210
sS'170'
p12211
(F-8.283506393432617
F-3.2229000438343394
tp12212
ssI761804
(dp12213
S"'          Hello        '.strip()"
p12214
(F-2.103894369942801
F-1.4598925454275948
tp12215
sS"strip_one_space('   Hello ')"
p12216
(F-3.6039642333984374
F-1.6937836238316126
tp12217
sS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12218
(F-2.9831304931640625
F-1.5061325345720564
tp12219
sS"' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12220
(F-2.907046870181435
F-1.498103414263044
tp12221
sS"title = title.strip(',.-')"
p12222
(F-2.928541564941406
F-1.538987295968192
tp12223
sS"' Hello'.strip()"
p12224
(F-2.103894369942801
F-1.4598925454275948
tp12225
sS'myString.strip()'
p12226
(F-2.1254754066467285
F-1.5254483904157365
tp12227
sS"'Bob has a cat'.strip()"
p12228
(F-2.103894369942801
F-1.4598925454275948
tp12229
sS"'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12230
(F-2.768124507023738
F-1.483210836138044
tp12231
sS"' Hello '.strip()\n' Hello'.strip()"
p12232
(F-2.768124507023738
F-1.483210836138044
tp12233
sS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()"
p12234
(F-2.907046870181435
F-1.498103414263044
tp12235
sS"' Hello'.strip()\n'Bob has a cat'.strip()"
p12236
(F-2.768124507023738
F-1.483210836138044
tp12237
sS"' Hello '.strip()"
p12238
(F-2.103894369942801
F-1.4598925454275948
tp12239
sS"'  Hello\\n'.strip(' ')"
p12240
(F-2.39180850982666
F-1.4716448102678572
tp12241
ssI4476373
(dp12242
S"payload = {'key1': 'value1', 'key2': 'value2', }"
p12243
(F-2.1385034833635603
F-3.5467208862304687
tp12244
sS'return urllib2.Request(url, data=urllib.urlencode(params))'
p12245
(F-1.7572082943386502
F-3.5278095245361327
tp12246
sS'r = requests.post(url, data=payload)\nimport json'
p12247
(F-2.344249725341797
F-3.555515670776367
tp12248
sS'resp'
p12249
(F-9.687751770019531
F-4.0629020690917965
tp12250
sS"return urllib2.Request(((url + '?') + urllib.urlencode(params)))"
p12251
(F-2.9027950980446557
F-3.533232879638672
tp12252
sS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12253
(F-3.4804149809337797
F-3.9477447509765624
tp12254
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12255
(F-1.4512914021809895
F-3.552323913574219
tp12256
sS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        return urllib2.Request(url, data=urllib.urlencode(params))"
p12257
(F-1.9707019112326882
F-3.6014305114746095
tp12258
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12259
(F-1.9451475877028246
F-3.5346401214599608
tp12260
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p12261
(F-1.5845491458208134
F-3.5787990570068358
tp12262
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12263
(F-1.8308490571521578
F-3.5678146362304686
tp12264
sS"if (method == 'POST'):\n    return urllib2.Request(url, data=urllib.urlencode(params))"
p12265
(F-1.9517582484654017
F-3.571435546875
tp12266
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12267
(F-1.615334211077009
F-3.534345245361328
tp12268
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12269
(F-1.595616068158831
F-3.587479019165039
tp12270
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p12271
(F-1.7846246446881975
F-3.4895835876464845
tp12272
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12273
(F-1.3402175903320312
F-3.554796600341797
tp12274
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12275
(F-1.4986329078674316
F-3.5577251434326174
tp12276
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12277
(F-1.6586473905123198
F-3.56555290222168
tp12278
sS'from httplib2 import Http\nfrom urllib import urlencode\nh = Http()'
p12279
(F-4.5121316348805145
F-3.7986663818359374
tp12280
sS'import requests'
p12281
(F-3.9632906913757324
F-3.5830154418945312
tp12282
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12283
(F-1.5357929811639301
F-3.5636898040771485
tp12284
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12285
(F-1.8659036673751532
F-3.5839004516601562
tp12286
sS"import requests\nurl = 'https://...'"
p12287
(F-2.2198338508605957
F-3.571643829345703
tp12288
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12289
(F-1.4642392839704241
F-3.557963562011719
tp12290
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12291
(F-2.301861572265625
F-3.5309024810791017
tp12292
sS"url = 'https://...'"
p12293
(F-1.8938846588134766
F-3.64566650390625
tp12294
sS'r.status_code'
p12295
(F-2.954984664916992
F-3.8503189086914062
tp12296
sS'from httplib2 import Http'
p12297
(F-5.414098739624023
F-4.049100112915039
tp12298
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p12299
(F-1.4051505194769964
F-3.588958740234375
tp12300
sS'r = requests.get(url, params=payload)'
p12301
(F-1.4623898097446986
F-3.5719219207763673
tp12302
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12303
(F-1.3663114151864681
F-3.5948795318603515
tp12304
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12305
(F-1.4042896270751952
F-3.5780635833740235
tp12306
sS'r = requests.post(url, data=payload)'
p12307
(F-1.542152268545968
F-3.5726081848144533
tp12308
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12309
(F-2.9767937554253474
F-3.6996692657470702
tp12310
sS"def URLRequest(url, params, method='GET'):\n    pass"
p12311
(F-2.5048621328253495
F-3.6454742431640623
tp12312
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12313
(F-1.671225008757218
F-3.522447204589844
tp12314
sS'from urllib import urlencode\nh = Http()'
p12315
(F-3.7720467249552407
F-3.631420135498047
tp12316
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12317
(F-2.9249920654296875
F-3.611555480957031
tp12318
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12319
(F-3.7364974248976934
F-4.0261585235595705
tp12320
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12321
(F-2.5792431831359863
F-3.4855201721191404
tp12322
sS'r = requests.get(url)\nr = requests.get(url, params=payload)'
p12323
(F-1.1887089273203975
F-3.581978607177734
tp12324
sS"post_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12325
(F-2.0412013462611607
F-3.649995040893555
tp12326
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12327
(F-1.4243455835290857
F-3.578014373779297
tp12328
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12329
(F-3.316468505859375
F-3.7280487060546874
tp12330
sS'r.text\nr.status_code'
p12331
(F-3.5511939308860083
F-3.7987693786621093
tp12332
sS"post_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12333
(F-1.8998689651489258
F-3.6930789947509766
tp12334
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12335
(F-1.5959622742699795
F-3.559977340698242
tp12336
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p12337
(F-2.0871195793151855
F-3.5400291442871095
tp12338
sS"post_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12339
(F-2.28507137298584
F-3.6742427825927733
tp12340
sS'r = requests.post(url, data=json.dumps(payload))\nr.text'
p12341
(F-2.157319110372792
F-3.5235214233398438
tp12342
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12343
(F-1.907413401502244
F-3.5107452392578127
tp12344
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p12345
(F-1.6923841857910156
F-3.6365074157714843
tp12346
sS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12347
(F-2.8205416062298942
F-3.765544891357422
tp12348
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12349
(F-1.5967881944444444
F-3.5545860290527345
tp12350
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12351
(F-1.7543860215407152
F-3.556719970703125
tp12352
sS'r.text'
p12353
(F-2.8573749542236326
F-3.796152877807617
tp12354
sS"import requests\nget_response = requests.get(url='http://google.com')"
p12355
(F-1.685085184433881
F-3.5773441314697267
tp12356
sS'from httplib2 import Http\nfrom urllib import urlencode'
p12357
(F-4.67833848433061
F-3.806621551513672
tp12358
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12359
(F-2.050647077889278
F-3.5517822265625
tp12360
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12361
(F-1.4111500954141423
F-3.573541259765625
tp12362
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12363
(F-3.236370849609375
F-4.0232421875
tp12364
sS'import json\nr = requests.post(url, data=json.dumps(payload))'
p12365
(F-1.6034941239790483
F-3.4800125122070313
tp12366
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12367
(F-1.3735350571669542
F-3.5559024810791016
tp12368
sS'r = requests.post(url, data=json.dumps(payload))'
p12369
(F-1.431774942498458
F-3.522696685791016
tp12370
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12371
(F-1.8806060791015624
F-3.55057373046875
tp12372
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12373
(F-1.870541017446945
F-3.554871368408203
tp12374
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12375
(F-2.1416517404409556
F-3.490092468261719
tp12376
sS"if (method == 'POST'):\n    pass"
p12377
(F-2.062922844519982
F-3.823200225830078
tp12378
sS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12379
(F-3.4280353122287326
F-3.773976516723633
tp12380
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p12381
(F-1.228478855556912
F-3.588548278808594
tp12382
sS'import json'
p12383
(F-4.495895862579346
F-3.526450347900391
tp12384
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12385
(F-3.491075642903646
F-3.7497440338134767
tp12386
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12387
(F-1.9971750577290852
F-3.645189666748047
tp12388
sS'r = requests.get(url)'
p12389
(F-1.2939579010009765
F-3.578419494628906
tp12390
sS"get_response = requests.get(url='http://google.com')"
p12391
(F-1.8467426300048828
F-3.6553485870361326
tp12392
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12393
(F-1.488788096110026
F-3.537382888793945
tp12394
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12395
(F-1.6457770064070418
F-3.5554107666015624
tp12396
sS"post_data = {'username': 'joeb', 'password': 'foobar', }"
p12397
(F-2.4928877353668213
F-3.6488418579101562
tp12398
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12399
(F-3.334586334228516
F-4.163156890869141
tp12400
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12401
(F-1.3185326712472099
F-3.5710475921630858
tp12402
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12403
(F-1.5971113351675181
F-3.5738265991210936
tp12404
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12405
(F-1.3700960393537556
F-3.5611328125
tp12406
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p12407
(F-2.2875660863415948
F-3.6178104400634767
tp12408
sS'h = Http()'
p12409
(F-5.171835763113839
F-4.21344223022461
tp12410
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12411
(F-3.7002862783578725
F-3.730112075805664
tp12412
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p12413
(F-1.8476446242559523
F-3.497671127319336
tp12414
sS'from urllib import urlencode'
p12415
(F-3.1253560384114585
F-3.583771514892578
tp12416
sS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        pass"
p12417
(F-2.248957666857489
F-3.6485267639160157
tp12418
sS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12419
(F-4.427105115807575
F-3.9465282440185545
tp12420
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12421
(F-1.543296343014564
F-3.5537906646728517
tp12422
sS"data = dict(name='Joe', comment='A test comment')"
p12423
(F-2.2951818193708147
F-3.747296905517578
tp12424
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12425
(F-3.4252767359956784
F-3.704154205322266
tp12426
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p12427
(F-1.9913338555230036
F-3.534892272949219
tp12428
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12429
(F-1.7701135394216954
F-3.548484039306641
tp12430
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12431
(F-1.9370784759521484
F-3.632524871826172
tp12432
sS'r = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12433
(F-2.5909144960600754
F-3.5150928497314453
tp12434
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p12435
(F-1.8517982482910156
F-3.5769065856933593
tp12436
ssI247770
(dp12437
S'import inspect\ninspect.getfile(os)'
p12438
(F-2.920349814675071
F-3.9039529164632163
tp12439
sS'os.path.dirname(inspect.getfile(inspect))'
p12440
(F-1.9353949228922527
F-3.927872975667318
tp12441
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p12442
(F-3.036441379123264
F-3.952163060506185
tp12443
sS'print os.getcwd()'
p12444
(F-1.5876027345657349
F-4.054760932922363
tp12445
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p12446
(F-2.7943631126767112
F-3.851825714111328
tp12447
sS'inspect.getfile(os)\ninspect.getfile(inspect)'
p12448
(F-3.3104532877604167
F-4.223021825154622
tp12449
sS'inspect.getfile(os)'
p12450
(F-3.336376667022705
F-4.239176432291667
tp12451
sS'import inspect'
p12452
(F-4.21796178817749
F-3.8192615509033203
tp12453
sS'print __file__'
p12454
(F-2.7099609375
F-4.285490036010742
tp12455
sS'print bar.__file__'
p12456
(F-2.8886139392852783
F-4.233084996541341
tp12457
sS'import bar\nprint bar.__file__'
p12458
(F-3.2785873413085938
F-4.119247118631999
tp12459
sS'path = os.path.abspath(amodule.__file__)'
p12460
(F-1.8845956325531006
F-3.9746901194254556
tp12461
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12462
(F-2.7572238445281982
F-3.9238735834757485
tp12463
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12464
(F-2.5968614850725444
F-3.866633097330729
tp12465
sS'import bar'
p12466
(F-4.106856346130371
F-4.033699671427409
tp12467
sS'path = os.path.dirname(amodule.__file__)'
p12468
(F-1.9416563510894775
F-3.981469472249349
tp12469
sS'import a_module'
p12470
(F-4.036252657572429
F-3.833102544148763
tp12471
sS'import os'
p12472
(F-3.0756425857543945
F-3.969355583190918
tp12473
sS'import os\nimport inspect'
p12474
(F-3.259915215628488
F-3.78985595703125
tp12475
sS'inspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12476
(F-2.887560410933061
F-3.99639097849528
tp12477
sS'import a_module\nprint a_module.__file__'
p12478
(F-2.903575134277344
F-3.813942273457845
tp12479
sS'import os\nprint os.getcwd()\nprint __file__'
p12480
(F-1.70530104637146
F-4.0606333414713545
tp12481
sS'print a_module.__file__'
p12482
(F-3.0545726776123048
F-3.903538703918457
tp12483
sS'import os\npath = os.path.dirname(amodule.__file__)'
p12484
(F-1.777840062191612
F-3.9169928232828775
tp12485
sS'import os\nprint os.getcwd()'
p12486
(F-0.9461014487526633
F-4.003012339274089
tp12487
sS'inspect.getfile(inspect)'
p12488
(F-3.183192729949951
F-4.217008908589681
tp12489
sS'import os\nimport inspect\ninspect.getfile(os)'
p12490
(F-2.6658009120396207
F-3.8101879755655923
tp12491
sS'inspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12492
(F-2.941691957671067
F-4.039257049560547
tp12493
sS'print os.getcwd()\nprint __file__'
p12494
(F-2.2537523416372447
F-4.133260091145833
tp12495
ssI4906977
(dp12496
S'print os.environ'
p12497
(F-3.512085278828939
F-2.751021248953683
tp12498
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')\nprint os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p12499
(F-2.4840927124023438
F-2.874010903494699
tp12500
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')"
p12501
(F-1.5967778292569248
F-2.86892454964774
tp12502
sS'import sys'
p12503
(F-4.18581485748291
F-2.7752176012311662
tp12504
sS'import os\nprint os.environ'
p12505
(F-2.1570506625705295
F-2.7220976693289622
tp12506
sS"('HOME' in os.environ)"
p12507
(F-4.726238250732422
F-2.876194817679269
tp12508
sS'print sys.prefix'
p12509
(F-3.4466368357340493
F-2.7462735857282365
tp12510
sS"import os\nprint os.environ['HOME']"
p12511
(F-1.1357285181681316
F-2.7335853576660156
tp12512
sS'os.environ'
p12513
(F-2.9389148712158204
F-2.80496461050851
tp12514
sS"os.environ.has_key('HOME')"
p12515
(F-1.8684619267781575
F-2.947913578578404
tp12516
sS'import os'
p12517
(F-4.203298091888428
F-2.773169926234654
tp12518
sS"print os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p12519
(F-3.0927951519305887
F-2.919018881661551
tp12520
sS"print os.environ.get('HOME', '/home/username/')"
p12521
(F-1.8882100031926081
F-2.886077335902623
tp12522
sS"print os.environ['HOME']"
p12523
(F-1.629291746351454
F-2.8021812438964844
tp12524
sS'import sys\nprint sys.prefix'
p12525
(F-2.045822355482313
F-2.6962762560163225
tp12526
ssI4641765
(dp12527
S'things_to_add = [0, 1, 1, 0]'
p12528
(F-3.0598992740406707
F-2.570235013961792
tp12529
sS'fooList.append(3)\nfooList.append(2734)\nprint fooList'
p12530
(F-3.325699215843564
F-2.6899147033691406
tp12531
sS'print fooList'
p12532
(F-5.769677734375
F-2.743712902069092
tp12533
sS'foo.append(4)\nfoo.append([8, 7])\nprint foo'
p12534
(F-2.9476869756525215
F-2.562277317047119
tp12535
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p12536
(F-3.5403299746306045
F-2.683079481124878
tp12537
sS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12538
(F-4.3489574563914335
F-2.5925323963165283
tp12539
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p12540
(F-2.446859696332146
F-2.799802303314209
tp12541
sS'foo[3] = (foo[3] + 4)\nprint foo'
p12542
(F-3.309658898247613
F-2.5521111488342285
tp12543
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)\nprint fooList'
p12544
(F-2.9609832763671875
F-2.545548439025879
tp12545
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p12546
(F-2.746940196644176
F-2.587050437927246
tp12547
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])'
p12548
(F-1.9545725042169744
F-2.5359082221984863
tp12549
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p12550
(F-3.1574895104696585
F-2.5904781818389893
tp12551
sS'foo.append([8, 7])\nprint foo'
p12552
(F-2.9757733662923176
F-2.5400805473327637
tp12553
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)'
p12554
(F-3.090542879971591
F-2.5377137660980225
tp12555
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)'
p12556
(F-2.8895352681477866
F-2.5557665824890137
tp12557
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p12558
(F-2.613848549979074
F-2.8426473140716553
tp12559
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p12560
(F-2.7970231708727384
F-2.527994155883789
tp12561
sS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p12562
(F-3.7638877586082176
F-2.564960479736328
tp12563
sS'print foo'
p12564
(F-5.796825885772705
F-2.9570672512054443
tp12565
sS'foo.append(4)'
p12566
(F-2.773958921432495
F-2.6811604499816895
tp12567
sS'foo = [1, 2, 3, 4, 5]'
p12568
(F-2.0465030670166016
F-2.4995810985565186
tp12569
sS'print x'
p12570
(F-4.641050338745117
F-3.179539680480957
tp12571
sS'fooList = [1, 3, 348, 2]'
p12572
(F-3.7240698678152904
F-2.5253634452819824
tp12573
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12574
(F-3.550059339735243
F-2.6156816482543945
tp12575
sS'fooList.append(3)'
p12576
(F-3.5592659844292536
F-2.672506093978882
tp12577
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)'
p12578
(F-1.9541743885387073
F-2.518826484680176
tp12579
sS'things_to_add = [(1, 1), (2, 1)]'
p12580
(F-2.415878114246187
F-2.599228858947754
tp12581
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])\nprint foo'
p12582
(F-2.0751175350613065
F-2.521679401397705
tp12583
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12584
(F-2.7082785470145088
F-2.84555721282959
tp12585
sS'L[idx] += amount'
p12586
(F-4.284070014953613
F-2.531017780303955
tp12587
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]'
p12588
(F-2.3701950599407327
F-2.528714895248413
tp12589
sS'fooList.append(2734)\nprint fooList'
p12590
(F-3.5931883591871996
F-2.658541202545166
tp12591
sS'L'
p12592
(F-9.91012191772461
F-2.526052951812744
tp12593
sS'foo.append(4)\nfoo.append([8, 7])'
p12594
(F-2.7447632237484583
F-2.5386438369750977
tp12595
sS'for (idx, amount) in things_to_add:\n    L[idx] += amount'
p12596
(F-3.851836840311686
F-2.5195469856262207
tp12597
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12598
(F-3.0702664559347586
F-2.6152613162994385
tp12599
sS'x = [2, 5, 10]\nx.insert(2, 77)'
p12600
(F-2.5478805541992187
F-2.5630006790161133
tp12601
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount'
p12602
(F-3.1270505731756035
F-2.660104513168335
tp12603
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p12604
(F-2.5085031609786186
F-2.6680002212524414
tp12605
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p12606
(F-2.6624759407930596
F-2.5815505981445312
tp12607
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12608
(F-3.449982234409877
F-2.897886276245117
tp12609
sS'L[:] = [sum(i) for i in zip(L, things_to_add)]'
p12610
(F-2.9163568936861477
F-2.7190394401550293
tp12611
sS'x.insert(2, 77)\nprint x'
p12612
(F-3.193407498873197
F-2.958272933959961
tp12613
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p12614
(F-2.779449462890625
F-2.698441982269287
tp12615
sS'for (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p12616
(F-4.533799684964693
F-2.5402889251708984
tp12617
sS'fooList.append(3)\nfooList.append(2734)'
p12618
(F-3.243442984188304
F-2.6854822635650635
tp12619
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)\nprint foo'
p12620
(F-2.3612914085388184
F-2.541358232498169
tp12621
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']"
p12622
(F-2.691223437969501
F-2.8346924781799316
tp12623
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12624
(F-2.944324098784348
F-2.885542392730713
tp12625
sS'for item in things_to_add:\n    pass'
p12626
(F-2.8723665873209634
F-2.5450568199157715
tp12627
sS"L[item['idx']] += item['amount']"
p12628
(F-3.047804151262556
F-2.830810308456421
tp12629
sS'x = [2, 5, 10]'
p12630
(F-2.6426176591352983
F-2.5228166580200195
tp12631
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)'
p12632
(F-2.1801653894884834
F-2.5509390830993652
tp12633
sS'foo.append([8, 7])'
p12634
(F-2.4768702189127603
F-2.5226523876190186
tp12635
sS'foo[3] = (foo[3] + 4)'
p12636
(F-2.8861292521158854
F-2.5530765056610107
tp12637
sS'x.insert(2, 77)'
p12638
(F-3.051043701171875
F-2.982663154602051
tp12639
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    pass'
p12640
(F-2.786670391376202
F-2.6142873764038086
tp12641
sS'L = [0, 0, 0, 0]'
p12642
(F-2.114952380840595
F-2.523216724395752
tp12643
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p12644
(F-3.1251914731917845
F-2.6881797313690186
tp12645
sS'x = [2, 5, 10]\nx.insert(2, 77)\nprint x'
p12646
(F-2.3580954178519873
F-2.556364059448242
tp12647
sS'fooList.append(2734)'
p12648
(F-3.24782477484809
F-2.696503162384033
tp12649
sS'for (idx, amount) in enumerate(things_to_add):\n    pass'
p12650
(F-3.226888483220881
F-2.5045642852783203
tp12651
sS'for (idx, amount) in things_to_add:\n    pass'
p12652
(F-3.631679334138569
F-2.582399368286133
tp12653
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p12654
(F-2.453749237060547
F-2.532630205154419
tp12655
ssI2407398
(dp12656
S'zip(list_a, list_b)'
p12657
(F-2.4607133865356445
F-1.4551496505737305
tp12658
sS'list_b = [5, 6, 7, 8]'
p12659
(F-2.765558878580729
F-1.4940354483468192
tp12660
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]'
p12661
(F-2.077417307886584
F-1.466984476361956
tp12662
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p12663
(F-2.021705436706543
F-1.422936303274972
tp12664
sS'list_a = [1, 2, 3, 4]'
p12665
(F-2.306848398844401
F-1.5018697466169084
tp12666
sS'list_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p12667
(F-2.413198471069336
F-1.4172638484409876
tp12668
ssI19602931
(dp12669
S'testfile = urllib.URLopener()'
p12670
(F-4.73498306274414
F-3.974076197697566
tp12671
sS'file_name = wget.download(file_url)'
p12672
(F-3.0342889513288225
F-3.8499092688927283
tp12673
sS'import urllib\ntestfile = urllib.URLopener()'
p12674
(F-4.193153674785908
F-4.00768808218149
tp12675
sS"testfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p12676
(F-3.907952961168791
F-3.9894784780649037
tp12677
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p12678
(F-2.739119156547215
F-3.894511002760667
tp12679
sS"urllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p12680
(F-1.4128188133239745
F-3.928131103515625
tp12681
sS"file_url = 'http://johndoe.com/download.zip'"
p12682
(F-2.6371917724609375
F-3.8159684401292067
tp12683
sS'import wget'
p12684
(F-3.5841989517211914
F-4.151507450984075
tp12685
sS"testfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p12686
(F-3.4620681762695313
F-3.9623330923227162
tp12687
sS"file_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p12688
(F-2.7190620422363283
F-3.8322340158315806
tp12689
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'"
p12690
(F-3.0640130996704102
F-3.904857928936298
tp12691
sS'import urllib'
p12692
(F-4.293709754943848
F-3.977246798001803
tp12693
sS"import urllib\nurllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p12694
(F-1.0827046907865083
F-3.970210442176232
tp12695
sS"import urllib\ntestfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p12696
(F-3.592190829190341
F-4.008365044227014
tp12697
ssI4588628
(dp12698
S'(a == 0)'
p12699
(F-4.05016953604562
F-3.9884277979532876
tp12700
sS'numpy.where((x == 0))[0]'
p12701
(F-2.0252202351888022
F-3.22135066986084
tp12702
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\nnumpy.where((x == 0))[0]'
p12703
(F-1.711757991624915
F-3.202625592549642
tp12704
sS'a = np.asarray([0, 1, 2, 3, 4])\n(a == 0)'
p12705
(F-2.176709395188552
F-3.25922425587972
tp12706
sS'(x == 0)\nnumpy.nonzero((x == 0))[0]'
p12707
(F-3.2027675083705356
F-3.2674194971720376
tp12708
sS'numpy.nonzero((x == 0))[0]'
p12709
(F-2.432067362467448
F-3.2086092631022134
tp12710
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)\nnumpy.nonzero((x == 0))[0]'
p12711
(F-2.134852776160607
F-3.196298599243164
tp12712
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])'
p12713
(F-1.6144471168518066
F-3.222696304321289
tp12714
sS'(x == 0)'
p12715
(F-3.839996337890625
F-4.020109176635742
tp12716
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)'
p12717
(F-1.9614727622584294
F-3.2231264114379883
tp12718
sS'a = np.asarray([0, 1, 2, 3, 4])'
p12719
(F-1.6454973220825195
F-3.257486661275228
tp12720
ss.