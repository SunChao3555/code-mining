(dp0
I379906
(dp1
S'def num(s):\n    pass'
p2
(F-1.3468012809753418
F-3.767681360244751
tp3
sS'return False'
p4
(F-4.191181659698486
F-4.426782131195068
tp5
sS'return float(s)'
p6
(F-2.5477188655308316
F-3.2068443298339844
tp7
sS"a = '545.2222'"
p8
(F-3.2109344482421873
F-3.896353244781494
tp9
sS'float(value)'
p10
(F-2.4384635289510093
F-3.2685904502868652
tp11
sS"a = '545.2222'\nfloat(a)\nint(float(a))"
p12
(F-2.4764378865559897
F-3.1172070503234863
tp13
sS'return True'
p14
(F-4.191181659698486
F-4.426782131195068
tp15
sS'float(a)\nint(float(a))'
p16
(F-2.5584613255092075
F-3.1545987129211426
tp17
sS'float(a)'
p18
(F-2.3351357777913413
F-3.315460205078125
tp19
sS"a = '545.2222'\nfloat(a)"
p20
(F-2.17859001159668
F-3.2826666831970215
tp21
sS'return int(s)'
p22
(F-2.3305846623011996
F-3.1595096588134766
tp23
sS'int(float(a))'
p24
(F-2.1509617699517145
F-3.15287446975708
tp25
sS'def isfloat(value):\n    pass'
p26
(F-1.541251500447591
F-3.916980504989624
tp27
ssI3437059
(dp28
S's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p29
(F-1.7435760498046875
F-3.9050556529651987
tp30
sS"if (s.find('is') == (-1)):\n    pass"
p31
(F-2.4427871704101562
F-3.8831443786621094
tp32
sS"if ('blah' not in somestring):\n    continue"
p33
(F-2.450289045061384
F-3.9152700250799004
tp34
sS's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p35
(F-1.915301583030007
F-3.9080366654829546
tp36
sS"if ('blah' not in somestring):\n    pass"
p37
(F-2.2826648439679826
F-3.9012440768155185
tp38
sS'print "No \'is\' here!"'
p39
(F-3.2193336486816406
F-3.8828471790660513
tp40
sS'continue'
p41
(F-5.250542640686035
F-4.028431979092685
tp42
sS"s = 'This be a string'\nif (s.find('is') == (-1)):\n    pass"
p43
(F-2.1963824462890624
F-3.886217637495561
tp44
sS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p45
(F-1.8365468343098958
F-3.899991122159091
tp46
sS"s = 'This be a string'"
p47
(F-2.3475872039794923
F-3.817472978071733
tp48
sS'print "Found \'is\' in the string."'
p49
(F-3.2193336486816406
F-3.8828471790660513
tp50
sS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p51
(F-2.0428310262745826
F-3.90292705189098
tp52
ssI4265988
(dp53
S'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob'
p54
(F-2.4159560092659884
F-3.9647274017333984
tp55
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p56
(F-2.770412669462316
F-4.2973372141520185
tp57
sS'numpy.random.choice(numpy.arange(1, 7), p=[0.1, 0.05, 0.05, 0.2, 0.4, 0.2])'
p58
(F-1.4569629322398792
F-4.019184748331706
tp59
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p60
(F-2.9695244991418086
F-4.497877756754558
tp61
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p62
(F-3.1444469105113635
F-4.157174428304036
tp63
sS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p64
(F-4.705754048115498
F-4.054915428161621
tp65
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p66
(F-2.5779036182468222
F-4.017497380574544
tp67
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]'
p68
(F-1.2870548527415206
F-4.3778731028238935
tp69
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p70
(F-2.9407880628431164
F-4.303493499755859
tp71
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    pass'
p72
(F-2.287708561594893
F-3.966052691141764
tp73
sS'return item'
p74
(F-5.239335536956787
F-4.8171586990356445
tp75
sS's = 0\nfor (item, prob) in l:\n    pass'
p76
(F-2.659732417056435
F-4.317859013875325
tp77
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p78
(F-2.881262642996652
F-4.273003896077474
tp79
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p80
(F-2.6074597588900863
F-4.50013001759847
tp81
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p82
(F-2.5494747161865234
F-4.006118138631185
tp83
sS's = 0\nfor (item, prob) in l:\n    s += prob'
p84
(F-2.889274233863467
F-4.301940282185872
tp85
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p86
(F-2.755182393391927
F-4.497242609659831
tp87
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0'
p88
(F-2.4884570086443865
F-3.955983797709147
tp89
sS'if (s >= r):\n    return item'
p90
(F-3.0310606275285994
F-4.500162124633789
tp91
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p92
(F-2.6521759033203125
F-4.294959386189778
tp93
sS's += prob'
p94
(F-3.9992237091064453
F-4.509085019429524
tp95
sS'if (s >= r):\n    return item\nreturn item'
p96
(F-3.282190210678998
F-4.516978581746419
tp97
sS'R = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p98
(F-3.655154957490809
F-4.064492861429851
tp99
sS'for (item, prob) in l:\n    pass'
p100
(F-2.414195760091146
F-4.574917157491048
tp101
sS'r = random.uniform(0, 1)'
p102
(F-2.293851693471273
F-3.905613581339518
tp103
sS'def random_distr(l):\n    pass'
p104
(F-1.7407003130231584
F-4.182681083679199
tp105
sS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p106
(F-4.297518048967634
F-4.0071665445963545
tp107
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p108
(F-2.45982666015625
F-4.0042724609375
tp109
sS'for (item, prob) in l:\n    s += prob'
p110
(F-2.861712736241958
F-4.516490936279297
tp111
sS's = 0'
p112
(F-4.778410720825195
F-4.464498202006022
tp113
sS'sorted((max((i for r in [random.random()] for (i, c) in cdf if (c <= r))) for _ in range(1000)))'
p114
(F-3.896690900935683
F-4.212682723999023
tp115
sS'def random_distr(l):\n    r = random.uniform(0, 1)'
p116
(F-1.7779927461043648
F-3.9277064005533853
tp117
sS'if (s >= r):\n    pass'
p118
(F-2.5206788870004506
F-4.525585492451985
tp119
ssI843277
(dp120
S'my_variable = None'
p121
(F-3.2664271763392856
F-1.7187097722833806
tp122
sS'def InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p123
(F-2.6066869099934897
F-1.6859494989568538
tp124
sS'my_variable = None\n\ndef InitMyVariable():\n    pass'
p125
(F-1.83795166015625
F-1.6932184045965022
tp126
sS'def InitMyVariable():\n    global my_variable'
p127
(F-2.1050469875335693
F-1.7007685574618252
tp128
sS'try:\n    myVar\nexcept NameError:\n    myVar = None'
p129
(F-1.4947996593656994
F-1.7294571616432883
tp130
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable'
p131
(F-2.1498091324515967
F-1.6898304332386365
tp132
sS"if ('myVar' in globals()):\n    pass"
p133
(F-2.0874366760253906
F-1.6931313601407139
tp134
sS'myVar = None'
p135
(F-2.782012621561686
F-1.7770600752397017
tp136
sS'if (my_variable is None):\n    pass'
p137
(F-2.6669642130533853
F-1.6795446222478694
tp138
sS'try:\n    myVar\nexcept NameError:\n    pass'
p139
(F-1.365769280327691
F-1.7072587446732954
tp140
sS'global my_variable'
p141
(F-3.406991958618164
F-1.680784745649858
tp142
sS'def InitMyVariable():\n    pass'
p143
(F-1.5505018967848558
F-1.7095527648925781
tp144
sS'myVar'
p145
(F-5.773022174835205
F-1.7597586891867898
tp146
sS"if ('myVar' in locals()):\n    pass"
p147
(F-2.1699396769205728
F-1.7201517278497869
tp148
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p149
(F-2.5236410192541174
F-1.6809544996781782
tp150
sS'pass'
p151
(F-3.187892278035482
F-1.7528376145796343
tp152
sS"if hasattr(obj, 'attr_name'):\n    pass"
p153
(F-1.3469510759626115
F-1.6953374689275569
tp154
ssI546321
(dp155
S'import datetime'
p156
(F-4.127140522003174
F-2.8341468811035155
tp157
sS'from datetime import date'
p158
(F-3.193740208943685
F-2.739913749694824
tp159
sS'six_months = (date.today() + relativedelta(months=(+ 6)))'
p160
(F-3.407587134319803
F-2.8278881072998048
tp161
sS'print (datetime.date.today() + datetime.timedelta(((6 * 365) / 12))).isoformat()'
p162
(F-2.3986710579164567
F-2.679515266418457
tp163
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta'
p164
(F-1.8577261704664965
F-2.7166061401367188
tp165
sS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))'
p166
(F-3.749701066450639
F-2.8289112091064452
tp167
sS'(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p168
(F-3.8231097134676846
F-2.83988037109375
tp169
sS'(day, month, year) = (day, ((month + 6) % 12), (year + ((month + 6) / 12)))'
p170
(F-3.757796828811233
F-2.9641582489013674
tp171
sS'from dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p172
(F-2.9060991923014323
F-2.899730110168457
tp173
sS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))\n(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p174
(F-3.8880097145257992
F-2.862840461730957
tp175
sS'from dateutil.relativedelta import relativedelta'
p176
(F-2.0299599170684814
F-3.1361522674560547
tp177
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p178
(F-2.661224801199777
F-2.691066932678223
tp179
sS'import datetime\nprint (datetime.date.today() + datetime.timedelta(((6 * 365) / 12))).isoformat()'
p180
(F-2.223237205954159
F-2.6742681503295898
tp181
sS'date += datetime.timedelta((6 * 30))'
p182
(F-2.8906863076346263
F-2.706969451904297
tp183
ssI237079
(dp184
S'def modification_date(filename):\n    pass'
p185
(F-2.063606398446219
F-3.9563507080078124
tp186
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p187
(F-1.722693634033203
F-3.971746317545573
tp188
sS"if (platform.system() == 'Windows'):\n    pass"
p189
(F-2.7166631362017464
F-4.16504872639974
tp190
sS"print ('last modified: %s' % time.ctime(os.path.getmtime(file)))"
p191
(F-1.7030305862426758
F-4.054757944742838
tp192
sS'import datetime'
p193
(F-4.056822776794434
F-3.9399398803710937
tp194
sS"(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint ('last modified: %s' % time.ctime(mtime))"
p195
(F-2.2131932576497397
F-3.9898953755696613
tp196
sS'return datetime.datetime.fromtimestamp(t)'
p197
(F-1.9536202170632102
F-3.972572835286458
tp198
sS"import os.path, time\nprint ('last modified: %s' % time.ctime(os.path.getmtime(file)))"
p199
(F-2.000934459544994
F-4.089914957682292
tp200
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p201
(F-2.3765974224738353
F-4.126912689208984
tp202
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p203
(F-2.8202395719640396
F-4.021878051757812
tp204
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p205
(F-1.70718476578996
F-3.918316650390625
tp206
sS'"\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p207
(F-4.912575085957845
F-3.9062268575032553
tp208
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    pass'
p209
(F-2.64893798828125
F-4.0753229777018225
tp210
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p211
(F-2.567485656738281
F-4.062401072184245
tp212
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p213
(F-2.1206586360931396
F-4.087226104736328
tp214
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p215
(F-1.590805180867513
F-4.0708368937174475
tp216
sS'import os, time'
p217
(F-3.9558178583780923
F-4.081026204427084
tp218
sS'stat = os.stat(path_to_file)'
p219
(F-2.414215632847377
F-4.045621744791666
tp220
sS"import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint ('last modified: %s' % time.ctime(mtime))"
p221
(F-2.04376723918509
F-4.030855305989584
tp222
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p223
(F-1.6648118760850694
F-3.9735013326009114
tp224
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p225
(F-2.2514704654091284
F-4.090100860595703
tp226
sS'import platform\n\ndef creation_date(path_to_file):\n    pass'
p227
(F-2.745628010142933
F-3.9726689656575522
tp228
sS'import datetime\n\ndef modification_date(filename):\n    pass'
p229
(F-1.7240496741400824
F-3.9318511962890623
tp230
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p231
(F-2.4185164078422217
F-4.08144048055013
tp232
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p233
(F-1.4363987662575461
F-3.9777297973632812
tp234
sS'import os\nimport datetime'
p235
(F-3.5865208762032643
F-4.029763031005859
tp236
sS"print ('last modified: %s' % time.ctime(mtime))"
p237
(F-1.6980763948880708
F-3.974139404296875
tp238
sS'return stat.st_mtime'
p239
(F-2.870927572250366
F-4.000331878662109
tp240
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)'
p241
(F-1.7494211611540422
F-3.991565450032552
tp242
sS'(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p243
(F-2.275141398111979
F-4.020468393961589
tp244
sS'import os.path, time'
p245
(F-3.8937058448791504
F-4.108827209472656
tp246
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p247
(F-2.154492546530331
F-4.091674296061198
tp248
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p249
(F-1.5609824569137007
F-3.9751597086588544
tp250
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p251
(F-2.0155661190257352
F-4.075298817952474
tp252
sS'def creation_date(path_to_file):\n    pass'
p253
(F-2.7600074344211154
F-3.9548019409179687
tp254
sS'print d'
p255
(F-5.422414779663086
F-3.991898600260417
tp256
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p257
(F-2.650789048936632
F-3.965281677246094
tp258
sS'return os.path.getctime(path_to_file)'
p259
(F-2.14853515625
F-4.067961120605469
tp260
sS"import os.path, time\nprint ('last modified: %s' % time.ctime(os.path.getmtime(file)))\nprint ('created: %s' % time.ctime(os.path.getctime(file)))"
p261
(F-1.8762702941894531
F-4.0859629313151045
tp262
sS"print ('created: %s' % time.ctime(os.path.getctime(file)))"
p263
(F-1.7030305862426758
F-4.054757944742838
tp264
sS'import os'
p265
(F-4.171813011169434
F-4.116834004720052
tp266
sS'print repr(d)'
p267
(F-2.9411869049072266
F-4.026643880208334
tp268
sS"d = modification_date('/var/log/syslog')\nprint d\nprint repr(d)"
p269
(F-3.2401315789473686
F-4.012709045410157
tp270
sS'import platform'
p271
(F-6.5128326416015625
F-4.1585637410481775
tp272
sS"d = modification_date('/var/log/syslog')"
p273
(F-3.571772003173828
F-4.0663096110026045
tp274
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p275
(F-2.4311872863769532
F-4.089900207519531
tp276
sS't = os.path.getmtime(filename)'
p277
(F-1.4448680877685547
F-4.096482849121093
tp278
sS'return stat.st_birthtime'
p279
(F-2.870927572250366
F-4.000331878662109
tp280
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p281
(F-2.2244553476009727
F-4.084293619791667
tp282
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)"
p283
(F-2.5158423062028556
F-4.136569976806641
tp284
sS'print d\nprint repr(d)'
p285
(F-3.7206607818603517
F-4.048576354980469
tp286
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    pass'
p287
(F-1.7911602201915922
F-4.001425170898438
tp288
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)"
p289
(F-2.2073218163023602
F-4.129199473063151
tp290
sS'import os\nimport platform'
p291
(F-4.423151016235352
F-4.206780242919922
tp292
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass"
p293
(F-2.0533112918629364
F-4.113779449462891
tp294
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p295
(F-2.6670988256281074
F-3.964061737060547
tp296
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime"
p297
(F-2.0966025574566567
F-4.1000007629394535
tp298
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p299
(F-2.0264782463152384
F-4.093293253580729
tp300
sS"d = modification_date('/var/log/syslog')\nprint d"
p301
(F-3.3774449275090146
F-4.0019274393717446
tp302
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p303
(F-2.0425352308485243
F-4.063019307454427
tp304
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p305
(F-2.0692347650942593
F-4.102689361572265
tp306
sS'import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p307
(F-2.128027125767299
F-4.065860239664714
tp308
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p309
(F-2.1395424856266505
F-4.119340006510416
tp310
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p311
(F-2.067032889033971
F-4.0787297566731775
tp312
sS"print ('last modified: %s' % time.ctime(os.path.getmtime(file)))\nprint ('created: %s' % time.ctime(os.path.getctime(file)))"
p313
(F-1.7592098529522235
F-4.069083404541016
tp314
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p315
(F-2.2394254048665365
F-4.123037465413412
tp316
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass"
p317
(F-2.23777707417806
F-4.139394124348958
tp318
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p319
(F-1.8587886925899622
F-3.916632588704427
tp320
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p321
(F-2.7250217344702743
F-4.114474487304688
tp322
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p323
(F-2.7953378777754936
F-4.060520172119141
tp324
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p325
(F-2.042058417137633
F-4.068966674804687
tp326
ssI6159900
(dp327
S"f.write(('hi there' + os.linesep))\nf.close()"
p328
(F-1.6043121337890625
F-2.5109676014293325
tp329
sS"f.write(('hi there' + os.linesep))"
p330
(F-1.9963434764317103
F-2.502039822665128
tp331
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
p332
(F-0.4935573494952658
F-2.430114052512429
tp333
sS"with open('somefile.txt', 'a') as the_file:\n    pass"
p334
(F-1.2708431879679363
F-2.446217970414595
tp335
sS'f.close()'
p336
(F-0.8020268167768206
F-2.5393187782981177
tp337
sS"the_file.write('Hello\\n')"
p338
(F-1.6917325973510742
F-2.4575878490101206
tp339
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p340
(F-1.3729999683521412
F-2.495282606645064
tp341
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p342
(F-1.315386708577474
F-2.437231410633434
tp343
sS'os.linesep'
p344
(F-2.462739372253418
F-2.7318475896661933
tp345
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p346
(F-1.4438026064918155
F-2.452098673040217
tp347
sS"f = open('myfile', 'w')"
p348
(F-0.8971956253051758
F-2.4031850641424004
tp349
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p350
(F-1.3459302325581395
F-2.5069502050226387
tp351
sS"f = open('myfile', 'w')\nf.write('hi there\\n')"
p352
(F-0.7616136214312386
F-2.4162538701837715
tp353
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p354
(F-1.6482869316549862
F-2.4621042771772905
tp355
sS"with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
p356
(F-1.0700534057617188
F-2.429533698342063
tp357
sS"open('myfile', 'rb').read()"
p358
(F-0.980490525563558
F-2.383010517467152
tp359
sS"os.linesep\nf = open('myfile', 'w')"
p360
(F-1.8385681424822127
F-2.4622410860928623
tp361
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p362
(F-1.4918707211812336
F-2.516182465986772
tp363
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p364
(F-1.6198144861169763
F-2.508568850430575
tp365
sS"import os\nos.linesep\nf = open('myfile', 'w')"
p366
(F-1.8333575304816752
F-2.548683513294567
tp367
sS"f.close()\nopen('myfile', 'rb').read()"
p368
(F-1.237571080525716
F-2.421834945678711
tp369
sS"from __future__ import print_function\nprint('hi there', file=f)"
p370
(F-1.6032893532200863
F-2.7181696458296343
tp371
sS'import os'
p372
(F-4.431488990783691
F-2.7987566861239346
tp373
sS"f.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p374
(F-1.5862493207377772
F-2.4544923955743965
tp375
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p376
(F-1.047700458102756
F-2.445572939786044
tp377
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p378
(F-1.4043815010472347
F-2.456550944935192
tp379
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p380
(F-1.3352382801197193
F-2.4795601584694604
tp381
sS"f.write('hi there\\n')\nf.close()"
p382
(F-0.711979866027832
F-2.47524018721147
tp383
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p384
(F-1.1254615783691406
F-2.43031137639826
tp385
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p386
(F-1.3686246871948242
F-2.466499675403942
tp387
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p388
(F-1.6948928833007812
F-2.4887157786976206
tp389
sS'from __future__ import print_function'
p390
(F-1.6641071319580079
F-2.8522200150923296
tp391
sS"f.write('hi there\\n')"
p392
(F-1.1739740371704102
F-2.454579093239524
tp393
sS'import os\nos.linesep'
p394
(F-2.6627674102783203
F-2.785055333917791
tp395
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p396
(F-1.3639346852022058
F-2.4463930996981533
tp397
ssI899103
(dp398
S"for item in thelist:\n    thefile.write(('%s\\n' % item))"
p399
(F-1.754326057434082
F-1.516675853729248
tp400
sS'pickle.dump(itemlist, outfile)'
p401
(F-1.2391059875488282
F-1.763343048095703
tp402
sS'print  >> thefile, item'
p403
(F-2.7799088614327565
F-1.6427753448486329
tp404
sS'itemlist = pickle.load(infile)'
p405
(F-2.010396385192871
F-1.662765884399414
tp406
sS'for item in thelist:\n    pass'
p407
(F-1.420633229342374
F-1.7230451583862305
tp408
sS'import pickle'
p409
(F-6.113895416259766
F-1.9087711334228517
tp410
sS"outfile.write('\\n'.join(itemlist))"
p411
(F-1.0436819516695464
F-1.5428351402282714
tp412
sS"thefile.write(('%s\\n' % item))"
p413
(F-2.213374932607015
F-1.554581069946289
tp414
sS'import pickle\npickle.dump(itemlist, outfile)'
p415
(F-1.6514097360464244
F-1.7167774200439454
tp416
ssI3939361
(dp417
S"string = 'ab1cd1ef'"
p418
(F-2.825220489501953
F-1.4756648063659668
tp419
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p420
(F-1.777741955172631
F-1.4063196182250977
tp421
sS"line = 'abc#@!?efg12;:?'"
p422
(F-3.6423580169677736
F-1.7090751647949218
tp423
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p424
(F-1.652996335710798
F-1.4075477600097657
tp425
sS"string.replace('1', '')"
p426
(F-0.9955123901367188
F-1.3996747970581054
tp427
sS"b = '!@#$'"
p428
(F-3.3761959075927734
F-1.7324836730957032
tp429
sS"a = 'a!b@c#d$'"
p430
(F-3.3055099487304687
F-1.7178367614746093
tp431
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)"
p432
(F-2.887788069875617
F-2.0904119491577147
tp433
sS"''.join((c for c in line if (c not in '?:!/;')))"
p434
(F-3.0757279168991816
F-1.5178642272949219
tp435
sS"b = '!@#$'\nfor char in b:\n    pass"
p436
(F-1.8472066243489584
F-1.4042020797729493
tp437
sS"import string\nline = line.translate(string.maketrans('', ''), '!@#$')"
p438
(F-2.5978077975186435
F-1.4075883865356444
tp439
sS"for char in b:\n    a = a.replace(char, '')\nprint a"
p440
(F-2.130522686502208
F-1.4835840225219727
tp441
sS'import re'
p442
(F-4.729394912719727
F-1.433929443359375
tp443
sS"line = line.translate(string.maketrans('', ''), '!@#$')"
p444
(F-2.60453957005551
F-1.421941089630127
tp445
sS"import re\nline = re.sub('[!@#$]', '', line)"
p446
(F-1.0488207199994255
F-1.397233009338379
tp447
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    pass"
p448
(F-1.6462860107421875
F-1.3997861862182617
tp449
sS'print a'
p450
(F-4.612841606140137
F-1.6712249755859374
tp451
sS"string = 'ab1cd1ef'\nstring.replace('1', '')"
p452
(F-1.2338593346732003
F-1.3936108589172362
tp453
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p454
(F-1.8134177525838215
F-1.4155736923217774
tp455
sS'import string'
p456
(F-5.59693717956543
F-1.4888019561767578
tp457
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)\nunicode_line = unicode_line.translate(translation_table)"
p458
(F-3.345507229075712
F-1.5379812240600585
tp459
sS'for char in b:\n    pass'
p460
(F-1.9795384840531782
F-1.527468204498291
tp461
sS"line = 'abc#@!?efg12;:?'\n''.join((c for c in line if (c not in '?:!/;')))"
p462
(F-3.165491943359375
F-1.5158140182495117
tp463
sS"line = re.sub('[!@#$]', '', line)"
p464
(F-0.8979789188929966
F-1.4009729385375977
tp465
sS"for char in b:\n    a = a.replace(char, '')"
p466
(F-1.9357778549194335
F-1.4952122688293457
tp467
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p468
(F-1.95109134250217
F-1.4128097534179687
tp469
sS"unicode_line = unicode_line.translate({ord(c): None for c in '!@#$'})"
p470
(F-3.645690612792969
F-1.4043451309204102
tp471
sS'unicode_line = unicode_line.translate(translation_table)'
p472
(F-3.9652178287506104
F-1.4479846000671386
tp473
sS"a = 'a!b@c#d$'\nb = '!@#$'"
p474
(F-2.682650883992513
F-1.68123779296875
tp475
sS"a = a.replace(char, '')"
p476
(F-2.2427314122517905
F-1.4275768280029297
tp477
sS"line = line.translate(None, '!@#$')"
p478
(F-1.8624898592631023
F-1.446591567993164
tp479
ssI9001509
(dp480
S'od[1]\nod[3]\nfor (k, v) in od.iteritems():\n    pass'
p481
(F-1.9901993850181843
F-2.481003154407848
tp482
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p483
(F-2.1891309298001804
F-1.8680579445578835
tp484
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p485
(F-2.1046500572791467
F-1.933414806019176
tp486
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p487
(F-1.9204579762050085
F-2.0943228981711646
tp488
sS'print k, v'
p489
(F-3.340237299601237
F-2.476234262639826
tp490
sS'keylist.sort()\nfor key in keylist:\n    pass'
p491
(F-1.7735303990981157
F-1.9711747602982954
tp492
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p493
(F-2.1962082233834774
F-1.9388653148304333
tp494
sS'for key in sorted(mydict):\n    pass'
p495
(F-1.5086908340454102
F-2.031640139493075
tp496
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p497
(F-2.543807636607777
F-2.243046673861417
tp498
sS'od[1]\nod[3]'
p499
(F-2.5514659881591797
F-2.424209941517223
tp500
sS'print (k, v)'
p501
(F-2.00919246673584
F-2.4385414123535156
tp502
sS'for key in keylist:\n    pass'
p503
(F-1.3836071707985618
F-2.406436226584695
tp504
sS'keylist.sort()'
p505
(F-1.5242572511945451
F-1.9901927601207385
tp506
sS'keylist = mydict.keys()\nkeylist.sort()'
p507
(F-1.4084218343098958
F-2.044901067560369
tp508
sS"print ('%s: %s' % (key, mydict[key]))"
p509
(F-1.6181678771972656
F-2.1845040754838423
tp510
sS'od = collections.OrderedDict(sorted(d.items()))\nod'
p511
(F-2.47750301361084
F-1.9058000391179866
tp512
sS'keylist = mydict.keys()'
p513
(F-1.4060582054985895
F-2.4939811012961646
tp514
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p515
(F-2.4230278862847223
F-1.8131615031849255
tp516
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p517
(F-2.421693632874308
F-1.8155087557705967
tp518
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p519
(F-2.126237233479818
F-1.9794939214533025
tp520
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p521
(F-2.439460196146151
F-1.940344897183505
tp522
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p523
(F-2.2580230712890623
F-1.875749414617365
tp524
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p525
(F-2.232542249891493
F-1.8884993466463955
tp526
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }"
p527
(F-2.0663346377286045
F-2.4449927590110083
tp528
sS'OrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p529
(F-2.405035610856681
F-1.8232073350386186
tp530
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))'
p531
(F-2.5540313720703125
F-1.8268519314852627
tp532
sS'for (k, v) in od.items():\n    pass'
p533
(F-1.550593325966283
F-2.226355119185014
tp534
sS'keylist = mydict.keys()\nkeylist.sort()\nfor key in keylist:\n    pass'
p535
(F-1.3987196350097657
F-2.006855010986328
tp536
sS'import collections'
p537
(F-5.377760887145996
F-2.2155066403475674
tp538
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p539
(F-2.161558763036188
F-1.9121530706232244
tp540
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }\nfor key in sorted(mydict):\n    pass"
p541
(F-1.7926268441336495
F-2.0672766945578833
tp542
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p543
(F-2.4554507685642615
F-1.8114187067205256
tp544
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p545
(F-2.208888071887898
F-1.8511744412508877
tp546
sS'od[3]\nfor (k, v) in od.iteritems():\n    pass'
p547
(F-2.011664072672526
F-2.4790977131236684
tp548
sS'od[3]'
p549
(F-3.086961110432943
F-2.4856584722345527
tp550
sS'from collections import OrderedDict'
p551
(F-2.4768714904785156
F-2.1201509995894
tp552
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p553
(F-2.5377235412597656
F-1.824386943470348
tp554
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p555
(F-1.8081613020463423
F-2.337172421542081
tp556
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p557
(F-2.4207923195578833
F-1.9845071272416548
tp558
sS'od'
p559
(F-7.119038899739583
F-2.755006269975142
tp560
sS'od[1]'
p561
(F-2.7904014587402344
F-2.5205365961248223
tp562
sS'for (k, v) in od.iteritems():\n    pass'
p563
(F-1.6008816769248562
F-2.445147080854936
tp564
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p565
(F-2.553630676269531
F-2.133819580078125
tp566
sS'od = collections.OrderedDict(sorted(d.items()))'
p567
(F-1.717661009894477
F-1.8830595883456143
tp568
ssI2990121
(dp569
S'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p570
(F-2.432076194069602
F-1.7635763608492339
tp571
sS'for i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p572
(F-1.8387150483972885
F-1.6973307682917669
tp573
sS'pass'
p574
(F-4.390549023946126
F-1.9110895303579478
tp575
sS'return izip_longest(fillvalue=fillvalue, *args)'
p576
(F-2.7311673845563615
F-1.757898477407602
tp577
sS'"grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p578
(F-4.454003016153972
F-1.9338814662053034
tp579
sS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p580
(F-2.377894247731855
F-1.7966041564941406
tp581
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'
p582
(F-1.5591505432128907
F-1.7896484961876502
tp583
sS'print i,'
p584
(F-5.695820617675781
F-1.8376372410700872
tp585
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p586
(F-1.8545039250300481
F-1.6668445880596454
tp587
sS'print i'
p588
(F-4.380778789520264
F-1.8516653501070464
tp589
sS'for i in xrange(0, 10, 2):\n    pass'
p590
(F-1.5138352711995442
F-1.7841177720289965
tp591
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    pass'
p592
(F-1.5135137557983398
F-1.7462884462796724
tp593
sS'for i in mylist[1::2]:\n    pass'
p594
(F-1.6410523582907284
F-1.7109837165245643
tp595
sS'def grouper(n, iterable, fillvalue=None):\n    pass'
p596
(F-1.4526388380262587
F-1.814557589017428
tp597
sS'for i in mylist[::2]:\n    pass'
p598
(F-1.8090012073516846
F-1.6999146388127253
tp599
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p600
(F-2.4259263552152195
F-1.691590822660006
tp601
sS'args = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p602
(F-3.1331354777018228
F-1.7241712716909556
tp603
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p604
(F-1.625263477193898
F-1.7266828096829927
tp605
sS'from itertools import izip_longest'
p606
(F-3.2340502738952637
F-1.6733404306265025
tp607
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    pass'
p608
(F-1.8143017108623798
F-1.6628676194411058
tp609
sS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p610
(F-1.5482459598117404
F-1.8010683793288012
tp611
sS'args = ([iter(iterable)] * n)'
p612
(F-3.337677001953125
F-1.7666419102595403
tp613
sS'for (item1, item2) in grouper(2, l):\n    pass'
p614
(F-2.3819900512695313
F-1.7369038508488581
tp615
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p616
(F-2.3874814938276243
F-1.6757962153508112
tp617
sS'for i in range(0, 10, 2):\n    pass'
p618
(F-1.3658534155951605
F-1.7768763028658354
tp619
ssI26443308
(dp620
S"'abcd}def}'.rfind('}')"
p621
(F-2.1510400772094727
F-3.0328847885131838
tp622
ssI4174941
(dp623
S'l.sort(key=(lambda x: x[2]))'
p624
(F-2.0853684743245444
F-1.6962155236138239
tp625
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nl.sort(key=(lambda x: x[2]))"
p626
(F-2.137083136517069
F-1.7172078026665583
tp627
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p628
(F-2.002687779868521
F-1.7430301242404513
tp629
sS'sorted(l, key=(lambda x: x[2]))'
p630
(F-1.9837907155354817
F-1.6930753919813368
tp631
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p632
(F-2.4237207873114226
F-1.8026991950141058
tp633
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p634
(F-2.240724002613741
F-1.8342967563205295
tp635
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p636
(F-1.9163650844408118
F-1.740961816575792
tp637
sS'sorted_list = sorted(list_to_sort, key=itemgetter(2, 0, 1))'
p638
(F-2.413987121582031
F-1.7002441618177626
tp639
sS'from operator import itemgetter'
p640
(F-3.746640205383301
F-2.155607435438368
tp641
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p642
(F-2.3242258532293913
F-1.8611840142144098
tp643
sS'sorted(L, key=itemgetter(2))'
p644
(F-1.881593997661884
F-1.7476023568047419
tp645
ssI3207219
(dp646
S"os.listdir('somedirectory')"
p647
(F-0.9091253280639648
F-1.9878225326538086
tp648
sS'onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p649
(F-1.6255585352579753
F-2.358705520629883
tp650
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)\nq'
p651
(F-3.5141818138860885
F-2.586281140645345
tp652
sS"print glob.glob('/home/adam/*.txt')"
p653
(F-1.4307368596394856
F-1.9589343070983887
tp654
sS'w = [4, 5, 6]\nq = (q + w)\nq'
p655
(F-4.3715533301943825
F-2.5077692667643228
tp656
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p657
(F-2.057264556884766
F-2.225445588429769
tp658
sS'q = (q + w)\nq'
p659
(F-5.946787053888494
F-2.50032107035319
tp660
sS'from os.path import isfile, join'
p661
(F-3.376975250244141
F-2.029794692993164
tp662
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p663
(F-2.023941658638619
F-1.8678139050801594
tp664
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p665
(F-2.240051507949829
F-2.1092074712117515
tp666
sS'from os import walk\nf = []'
p667
(F-2.440520546653054
F-1.987888018290202
tp668
sS'w = [4, 5, 6]'
p669
(F-3.7315500432794746
F-2.5577452977498374
tp670
sS'from os import walk'
p671
(F-3.705664952596029
F-2.022123177846273
tp672
sS'q = (q + w)'
p673
(F-4.361651950412327
F-2.554935932159424
tp674
sS"import glob\nprint glob.glob('/home/adam/*.txt')"
p675
(F-1.20652969678243
F-1.9172697067260742
tp676
sS'from os import listdir\nfrom os.path import isfile, join'
p677
(F-2.359002939860026
F-1.9921716054280598
tp678
sS"import os\nos.listdir('somedirectory')"
p679
(F-0.9829993681474165
F-1.9833183288574219
tp680
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p681
(F-1.9597686767578124
F-2.1654990514119468
tp682
sS'q = [1, 2, 3]\nw = [4, 5, 6]'
p683
(F-2.877129327683222
F-2.5997130076090493
tp684
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p685
(F-2.1353907775878906
F-1.976272741953532
tp686
sS'break'
p687
(F-3.6148045857747397
F-2.4298434257507324
tp688
sS'import os'
p689
(F-3.846780776977539
F-2.1059726079305015
tp690
sS'f = []'
p691
(F-3.1578216552734375
F-2.3039544423421225
tp692
sS'from os import listdir'
p693
(F-2.952613194783529
F-2.031134923299154
tp694
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p695
(F-2.47623528374566
F-1.939759890238444
tp696
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p697
(F-1.8711228688557944
F-1.8955542246500652
tp698
sS'from os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p699
(F-1.615121038336503
F-1.8373387654622395
tp700
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)'
p701
(F-2.8706323031721444
F-2.6038411458333335
tp702
sS'f.extend(filenames)'
p703
(F-2.3820419311523438
F-2.050830841064453
tp704
sS'q'
p705
(F-9.57311757405599
F-2.456655820210775
tp706
sS'from os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p707
(F-1.7652838735869436
F-1.8886950810750325
tp708
sS'w = [4, 5, 6]\nq = (q + w)'
p709
(F-3.4518456710012337
F-2.5407740275065103
tp710
sS'q = [1, 2, 3]'
p711
(F-3.192369981245561
F-2.595484415690104
tp712
sS'import glob'
p713
(F-4.891596794128418
F-1.9405269622802734
tp714
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p715
(F-1.7645339965820312
F-1.8765366872151692
tp716
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p717
(F-2.2783931732177733
F-2.0104336738586426
tp718
ssI2972212
(dp719
sI53513
(dp720
S"print 'List is empty'"
p721
(F-3.949894428253174
F-2.068287415937944
tp722
sS"print 'the list is empty'"
p723
(F-3.949894428253174
F-2.068287415937944
tp724
sS'if (len(li) == 0):\n    pass'
p725
(F-1.6294690370559692
F-1.7622035633433948
tp726
sS'if (not a):\n    pass'
p727
(F-2.4240519205729165
F-1.7578665993430398
tp728
ssI1514553
(dp729
S'f = []\nfor i in range(30):\n    pass'
p730
(F-1.2649422695762234
F-1.5103009223937989
tp731
sS'for i in range(30):\n    f.append(0)'
p732
(F-1.3671738473992598
F-1.5711750984191895
tp733
sS'for i in range(30):\n    pass'
p734
(F-1.434849739074707
F-1.5838065147399902
tp735
sS"intarray = array('i')"
p736
(F-2.869417190551758
F-1.5753767013549804
tp737
sS'f = []\nfor i in range(30):\n    f.append(0)'
p738
(F-1.1991130510965984
F-1.49589204788208
tp739
sS'f = []'
p740
(F-2.6614596048990884
F-1.6236284255981446
tp741
sS'from array import array'
p742
(F-4.90220832824707
F-1.4927884101867677
tp743
sS"from array import array\nintarray = array('i')"
p744
(F-3.020390437199519
F-1.4889303207397462
tp745
sS'variable = []'
p746
(F-3.953023910522461
F-1.6985908508300782
tp747
sS'f.append(0)'
p748
(F-1.838970422744751
F-1.651846694946289
tp749
ssI2612802
(dp750
S"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p751
(F-2.52935791015625
F-3.1977798461914064
tp752
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p753
(F-2.5815881693138265
F-3.2102794647216797
tp754
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p755
(F-2.838050590766655
F-3.1914749145507812
tp756
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p757
(F-2.5817439944245093
F-3.201546859741211
tp758
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p759
(F-2.4740205358286373
F-3.262923812866211
tp760
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p761
(F-2.4487357939649748
F-3.2381820678710938
tp762
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p763
(F-2.5077108883990924
F-3.228768539428711
tp764
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p765
(F-2.2665530840555825
F-3.272936248779297
tp766
sS"a = ['foo', foo]"
p767
(F-2.477201885647244
F-3.205896759033203
tp768
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p769
(F-2.2133282470703124
F-3.34495849609375
tp770
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p771
(F-2.659314190899884
F-3.197999954223633
tp772
sS't = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p773
(F-2.2694298528855845
F-3.3035610198974608
tp774
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p775
(F-2.58907943122131
F-3.188477325439453
tp776
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p777
(F-2.67596435546875
F-3.2132389068603517
tp778
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p779
(F-2.636229119906768
F-3.2318572998046875
tp780
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p781
(F-2.6026211442618536
F-3.201947784423828
tp782
sS'from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        pass'
p783
(F-1.9916776021321614
F-3.2017784118652344
tp784
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p785
(F-2.548180948893229
F-3.205409622192383
tp786
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p787
(F-2.6635909337720434
F-3.197998809814453
tp788
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p789
(F-2.632045130575857
F-3.218061065673828
tp790
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p791
(F-2.596995363953293
F-3.2252750396728516
tp792
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p793
(F-2.520923868815104
F-3.2023887634277344
tp794
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p795
(F-2.5999039227689678
F-3.2201812744140623
tp796
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p797
(F-2.4882834614187046
F-3.234105682373047
tp798
sS'if (t == tuple):\n    pass'
p799
(F-2.4591756967397838
F-3.1914337158203123
tp800
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p801
(F-2.679189733556799
F-3.2015625
tp802
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p803
(F-2.5061370849609377
F-3.2175697326660155
tp804
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p805
(F-2.5429578316875916
F-3.207009506225586
tp806
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p807
(F-2.7762777577275815
F-3.197513198852539
tp808
sS'if (t == tuple):\n    is_tuple = True'
p809
(F-2.643397162942325
F-3.1940729141235353
tp810
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p811
(F-2.569897286965558
F-3.229462814331055
tp812
sS"print 'Custom Copy:', (time() - t)\nt = time()"
p813
(F-3.5582737392849393
F-3.2141300201416017
tp814
sS'L[:]'
p815
(F-2.930194854736328
F-3.301542282104492
tp816
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p817
(F-2.470079155378444
F-3.2049327850341798
tp818
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p819
(F-3.223645430344802
F-3.256052780151367
tp820
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p821
(F-1.5025242672690862
F-3.1836790084838866
tp822
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p823
(F-2.6239678681786383
F-3.2195926666259767
tp824
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p825
(F-2.9784704137731484
F-3.2389896392822264
tp826
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p827
(F-2.5376715566597734
F-3.2076484680175783
tp828
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p829
(F-2.42534917195638
F-3.2272384643554686
tp830
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p831
(F-2.5621772420749744
F-3.2280765533447267
tp832
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p833
(F-2.6594391635913945
F-3.196092224121094
tp834
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p835
(F-2.5429105122884113
F-3.2193153381347654
tp836
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p837
(F-2.3789906655588458
F-3.2485988616943358
tp838
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p839
(F-2.811917259579613
F-3.251137924194336
tp840
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p841
(F-2.5443877121497844
F-3.2045925140380858
tp842
sS'class old_class:\n\n    def __init__(self):\n        pass'
p843
(F-1.8339127250339673
F-3.2210948944091795
tp844
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p845
(F-2.574643275863945
F-3.1893266677856444
tp846
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p847
(F-2.5746009029559236
F-3.2312648773193358
tp848
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p849
(F-2.668057528409091
F-3.1770084381103514
tp850
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p851
(F-2.525958469935826
F-3.2142444610595704
tp852
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p853
(F-2.361480955093626
F-3.284786605834961
tp854
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p855
(F-2.5414319917154455
F-3.204217529296875
tp856
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p857
(F-2.9234237670898438
F-3.2207763671875
tp858
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p859
(F-2.267450083856997
F-3.2356239318847657
tp860
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p861
(F-2.645471636033216
F-3.1993890762329102
tp862
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p863
(F-2.6450958251953125
F-3.218902587890625
tp864
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p865
(F-2.6752477334746234
F-3.195748710632324
tp866
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p867
(F-2.584427244427261
F-3.1904586791992187
tp868
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p869
(F-2.9248224073840725
F-3.3122554779052735
tp870
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p871
(F-2.4150052538105085
F-3.1899560928344726
tp872
sS"print 'list append:', (time() - t)\nt = time()"
p873
(F-3.5582737392849393
F-3.2141300201416017
tp874
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p875
(F-2.618324542867726
F-3.2039154052734373
tp876
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p877
(F-2.5013169214540256
F-3.2059581756591795
tp878
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p879
(F-2.7324851989746093
F-3.2234745025634766
tp880
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p881
(F-2.7268276872306036
F-3.229483795166016
tp882
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p883
(F-2.884173270983574
F-3.211500549316406
tp884
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p885
(F-2.5667205053912707
F-3.2113914489746094
tp886
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p887
(F-2.5794731775919595
F-3.2187267303466798
tp888
sS"a.append('baz')\nfoo.val = 5"
p889
(F-2.422820499965123
F-3.2068466186523437
tp890
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p891
(F-2.5017095379818595
F-3.196187210083008
tp892
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p893
(F-2.602434575162976
F-3.22064094543457
tp894
sS'pass'
p895
(F-3.737807591756185
F-3.3533538818359374
tp896
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p897
(F-2.5033233794406873
F-3.2229568481445314
tp898
sS'copy.copy(L)'
p899
(F-2.4925990104675293
F-3.179312515258789
tp900
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p901
(F-2.5790347909568845
F-3.2027374267578126
tp902
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p903
(F-2.5855282611728456
F-3.212532806396484
tp904
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p905
(F-2.7141444126022196
F-3.2370105743408204
tp906
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p907
(F-2.540425917681526
F-3.2077171325683596
tp908
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p909
(F-2.5523976236979165
F-3.200421905517578
tp910
sS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p911
(F-2.547637110171111
F-3.168563652038574
tp912
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p913
(F-3.096724033355713
F-3.2569259643554687
tp914
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p915
(F-2.8249333699544272
F-3.239241027832031
tp916
sS'if is_tuple:\n    pass'
p917
(F-1.999459526755593
F-3.1757373809814453
tp918
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p919
(F-2.414974478788154
F-3.2187461853027344
tp920
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p921
(F-2.743270593186829
F-3.1933238983154295
tp922
sS"return obj\nif (__name__ == '__main__'):\n    import copy"
p923
(F-3.390634637129934
F-3.1957687377929687
tp924
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p925
(F-2.504003736707899
F-3.2210811614990233
tp926
sS"return obj\nif (__name__ == '__main__'):\n    pass"
p927
(F-2.774397956000434
F-3.202848434448242
tp928
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p929
(F-2.611773681640625
F-3.2082801818847657
tp930
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p931
(F-2.5587220010878164
F-3.2066009521484373
tp932
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p933
(F-2.7034388412663968
F-3.189254570007324
tp934
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p935
(F-2.411062801585478
F-3.200818634033203
tp936
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p937
(F-2.5191022785308084
F-3.207598114013672
tp938
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p939
(F-2.7405987175143496
F-3.2544322967529298
tp940
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p941
(F-2.5245746234515765
F-3.1932010650634766
tp942
sS'for i in xrange(num_times):\n    [i for i in L]'
p943
(F-2.3759883533824575
F-3.2616519927978516
tp944
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p945
(F-2.825490449604235
F-3.2400192260742187
tp946
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p947
(F-2.8213836669921877
F-3.2016838073730467
tp948
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p949
(F-2.6361756575734994
F-3.192060661315918
tp950
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p951
(F-2.5527997906698565
F-3.2036380767822266
tp952
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p953
(F-2.622191382236168
F-3.198515701293945
tp954
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p955
(F-2.4992365106806025
F-3.2144092559814452
tp956
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p957
(F-2.7990050620221076
F-3.180043029785156
tp958
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p959
(F-2.9514522552490234
F-3.2317020416259767
tp960
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p961
(F-2.8325363470583547
F-3.1896541595458983
tp962
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p963
(F-2.635382317877435
F-3.1988048553466797
tp964
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p965
(F-2.7634110124143834
F-3.244654083251953
tp966
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p967
(F-2.5879918379749327
F-3.2051605224609374
tp968
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p969
(F-2.649878978729248
F-3.1952857971191406
tp970
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p971
(F-0.5947009404500325
F-3.2271881103515625
tp972
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p973
(F-3.3713313975232713
F-3.33006591796875
tp974
sS"print 'list expression(L):', (time() - t)\nt = time()"
p975
(F-3.5582737392849393
F-3.2141300201416017
tp976
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p977
(F-2.5641938989812676
F-3.2049484252929688
tp978
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p979
(F-2.4328296620358705
F-3.208306884765625
tp980
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p981
(F-2.9663229221250953
F-3.2774124145507812
tp982
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p983
(F-2.5682916352243135
F-3.184712600708008
tp984
sS't = time()\nfor i in xrange(num_times):\n    L[:]'
p985
(F-2.842979736328125
F-3.2258220672607423
tp986
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p987
(F-2.403355077369926
F-3.232634735107422
tp988
sS'for i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p989
(F-2.2727293968200684
F-3.2761489868164064
tp990
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass'
p991
(F-2.8461317905159884
F-3.209151840209961
tp992
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p993
(F-2.6566887095494924
F-3.227843475341797
tp994
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p995
(F-2.550518798828125
F-3.2070289611816407
tp996
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p997
(F-2.709141860773534
F-3.199748992919922
tp998
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p999
(F-2.5935098643065126
F-3.2256359100341796
tp1000
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1001
(F-2.626647109285407
F-3.2098899841308595
tp1002
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1003
(F-2.5545856439032355
F-3.1971412658691407
tp1004
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1005
(F-2.660128054411515
F-3.219143295288086
tp1006
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1007
(F-2.240637378157856
F-3.2181812286376954
tp1008
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1009
(F-2.925295651614011
F-3.1864696502685548
tp1010
sS'def __init__(self, val):\n    pass'
p1011
(F-1.2241138219833374
F-3.258147048950195
tp1012
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1013
(F-2.6142016249012863
F-3.1969390869140626
tp1014
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1015
(F-2.665679317192743
F-3.1865303039550783
tp1016
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        pass'
p1017
(F-1.1902864517704133
F-3.253273773193359
tp1018
sS"print 'list(L):', (time() - t)"
p1019
(F-3.126575469970703
F-3.213360595703125
tp1020
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1021
(F-2.508581653439621
F-3.2203372955322265
tp1022
sS'Copy(L, use_deepcopy=False)'
p1023
(F-2.031958262125651
F-3.548923110961914
tp1024
sS'obj[k] = Copy(obj[k], use_deepcopy)'
p1025
(F-3.0818684895833335
F-3.332814407348633
tp1026
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1027
(F-2.6835557021103895
F-3.2281185150146485
tp1028
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1029
(F-2.666063000730347
F-3.221274566650391
tp1030
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1031
(F-2.7651468912760415
F-3.2014331817626953
tp1032
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1033
(F-2.7022007533482144
F-3.2163421630859377
tp1034
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1035
(F-2.556087003209284
F-3.192988967895508
tp1036
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1037
(F-1.80544257886482
F-3.199083137512207
tp1038
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1039
(F-2.5231696515043907
F-3.2180145263671873
tp1040
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1041
(F-2.7664900885687933
F-3.184575843811035
tp1042
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1043
(F-2.478883309199892
F-3.230145263671875
tp1044
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1045
(F-2.5720283477660644
F-3.202907943725586
tp1046
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p1047
(F-2.4727457682291667
F-3.2271278381347654
tp1048
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1049
(F-2.149148370801788
F-3.261840057373047
tp1050
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1051
(F-2.5128923135806915
F-3.2111270904541014
tp1052
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1053
(F-2.5685191352246544
F-3.233916091918945
tp1054
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1055
(F-2.576560080588401
F-3.1972787857055662
tp1056
sS'b = a[:]\nc = list(a)'
p1057
(F-2.342381795247396
F-3.2658790588378905
tp1058
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1059
(F-2.4673422108525815
F-3.2290771484375
tp1060
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1061
(F-2.600194977550972
F-3.2173118591308594
tp1062
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1063
(F-2.64347043435924
F-3.22198600769043
tp1064
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1065
(F-2.46654040608185
F-3.222998046875
tp1066
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1067
(F-2.652829086571409
F-3.1917280197143554
tp1068
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1069
(F-2.560322086985518
F-3.1906009674072267
tp1070
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1071
(F-2.284149169921875
F-3.2245193481445313
tp1072
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1073
(F-2.555116842721255
F-3.2025436401367187
tp1074
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1075
(F-2.5018653679842973
F-3.2178112030029298
tp1076
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1077
(F-2.6515204024641483
F-3.1980121612548826
tp1078
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1079
(F-2.433712641398112
F-3.2176540374755858
tp1080
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1081
(F-2.5877643660003065
F-3.188023567199707
tp1082
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1083
(F-2.512327729985955
F-3.3308605194091796
tp1084
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p1085
(F-1.86594194354433
F-3.2807483673095703
tp1086
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1087
(F-2.568604413200827
F-3.1788394927978514
tp1088
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1089
(F-2.282623799641927
F-3.2148082733154295
tp1090
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1091
(F-2.6173388250942886
F-3.2270381927490233
tp1092
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1093
(F-2.5515883531027694
F-3.2002548217773437
tp1094
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p1095
(F-2.3944203252377716
F-3.3417984008789063
tp1096
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1097
(F-3.2443888594464556
F-3.352793884277344
tp1098
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1099
(F-2.5679787345554517
F-3.1894025802612305
tp1100
sS'return obj'
p1101
(F-5.013859748840332
F-3.389476013183594
tp1102
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1103
(F-2.593613088947453
F-3.1964481353759764
tp1104
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1105
(F-2.558007982042101
F-3.2586265563964845
tp1106
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1107
(F-2.546214367094494
F-3.1908584594726563
tp1108
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1109
(F-2.564186366442439
F-3.1911083221435548
tp1110
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1111
(F-2.55990827844498
F-3.2096836090087892
tp1112
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1113
(F-2.554797064638284
F-3.1974794387817385
tp1114
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1115
(F-2.5298631456163196
F-3.2040641784667967
tp1116
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1117
(F-2.6595301649305556
F-3.2072582244873047
tp1118
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1119
(F-2.533879330283717
F-3.1876457214355467
tp1120
sS'def __repr__(self):\n    pass'
p1121
(F-1.5447993959699358
F-3.246224212646484
tp1122
sS'class old_class:\n    pass'
p1123
(F-3.2534346147017046
F-3.2500743865966797
tp1124
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1125
(F-2.5474264210668105
F-3.216501235961914
tp1126
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p1127
(F-2.7173233852591565
F-3.2211257934570314
tp1128
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1129
(F-2.543285927076018
F-3.1919342041015626
tp1130
sS't = time()\nfor i in xrange(num_times):\n    a = []'
p1131
(F-2.3908871459960936
F-3.2070526123046874
tp1132
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1133
(F-2.5283165341331846
F-3.209551239013672
tp1134
sS'b = a[:]'
p1135
(F-2.7900476455688477
F-3.233196258544922
tp1136
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1137
(F-2.627393813360305
F-3.1949848175048827
tp1138
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1139
(F-2.6301827225030636
F-3.19000244140625
tp1140
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1141
(F-2.5941829451595444
F-3.2113422393798827
tp1142
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1143
(F-2.6245706888069784
F-3.205889892578125
tp1144
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1145
(F-2.510623508029514
F-3.2212287902832033
tp1146
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1147
(F-2.502979147023168
F-3.194463920593262
tp1148
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1149
(F-2.4529464523513598
F-3.2120040893554687
tp1150
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1151
(F-2.5274578472515485
F-3.2065074920654295
tp1152
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1153
(F-2.415337562561035
F-3.2049659729003905
tp1154
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1155
(F-2.497849794191735
F-3.223986053466797
tp1156
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p1157
(F-2.4531448014819897
F-3.2219348907470704
tp1158
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1159
(F-2.5027476884087045
F-3.207016372680664
tp1160
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1161
(F-2.607262533219134
F-3.191031837463379
tp1162
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p1163
(F-1.5242961247762044
F-3.188407135009766
tp1164
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1165
(F-2.7098645772019476
F-3.188488578796387
tp1166
sS"print 'list append:', (time() - t)"
p1167
(F-3.126575469970703
F-3.213360595703125
tp1168
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1169
(F-2.535688495270594
F-3.20892333984375
tp1170
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1171
(F-2.650836540670956
F-3.227680969238281
tp1172
sS'class new_class(object):\n\n    def __init__(self):\n        pass'
p1173
(F-1.5333218207726111
F-3.2631103515625
tp1174
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1175
(F-2.5610782020970393
F-3.2273681640625
tp1176
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1177
(F-2.8278484922466856
F-3.2114639282226562
tp1178
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1179
(F-2.3736993540888247
F-3.2217937469482423
tp1180
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1181
(F-2.549921544845418
F-3.208013153076172
tp1182
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1183
(F-2.8882753584120007
F-3.183106231689453
tp1184
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1185
(F-2.3778485681256676
F-3.221538543701172
tp1186
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1187
(F-2.6285721770430035
F-3.2056930541992186
tp1188
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1189
(F-2.530145961216518
F-3.2148292541503904
tp1190
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1191
(F-2.5737425789000494
F-3.2152484893798827
tp1192
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1193
(F-2.5508073629792203
F-3.2117198944091796
tp1194
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1195
(F-2.548029916729042
F-3.206243133544922
tp1196
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1197
(F-2.622120147055768
F-3.19867000579834
tp1198
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1199
(F-2.5319087357954544
F-3.202919769287109
tp1200
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1201
(F-2.8067483447846913
F-3.196084976196289
tp1202
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1203
(F-2.6196991806730217
F-3.1921051025390623
tp1204
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1205
(F-2.6151791134396114
F-3.208600616455078
tp1206
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1207
(F-2.5367289698401163
F-3.219725799560547
tp1208
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1209
(F-2.444723412298387
F-3.227629852294922
tp1210
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p1211
(F-2.39186396743312
F-3.304835891723633
tp1212
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1213
(F-2.328467166785038
F-3.2433708190917967
tp1214
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1215
(F-2.7126024383859537
F-3.2682865142822264
tp1216
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1217
(F-2.663149939643012
F-3.2518043518066406
tp1218
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1219
(F-2.456579543252028
F-3.2271587371826174
tp1220
sS't = time()\nfor i in xrange(num_times):\n    Copy(L)'
p1221
(F-2.0227761840820313
F-3.2059070587158205
tp1222
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1223
(F-2.6001402452256945
F-3.199112319946289
tp1224
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1225
(F-2.4105147104414684
F-3.218609619140625
tp1226
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1227
(F-3.112315138725385
F-3.1793210983276365
tp1228
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1229
(F-2.4047707744028375
F-3.2257465362548827
tp1230
sS'e = copy.deepcopy(a)'
p1231
(F-2.366813087463379
F-3.1594112396240233
tp1232
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1233
(F-2.5847550870266423
F-3.190936470031738
tp1234
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1235
(F-2.6420187161663384
F-3.2163238525390625
tp1236
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1237
(F-2.7620547547632333
F-3.1995805740356444
tp1238
sS"print 'copy.copy:', (time() - t)"
p1239
(F-3.126575469970703
F-3.213360595703125
tp1240
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1241
(F-2.5180456398506843
F-3.2290115356445312
tp1242
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1243
(F-2.342501481374105
F-3.194204330444336
tp1244
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1245
(F-2.5124494491084928
F-3.2105644226074217
tp1246
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1247
(F-2.581665868344514
F-3.216358184814453
tp1248
sS'for i in xrange(num_times):\n    copy.deepcopy(L)'
p1249
(F-1.9093653361002605
F-3.300775146484375
tp1250
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1251
(F-2.878501144109988
F-3.2758949279785154
tp1252
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1253
(F-2.272663080124628
F-3.2234451293945314
tp1254
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1255
(F-2.548791078785759
F-3.213710403442383
tp1256
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1257
(F-2.555962785225083
F-3.2124046325683593
tp1258
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1259
(F-2.522159303007679
F-3.2141510009765626
tp1260
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1261
(F-1.33402099609375
F-3.257603073120117
tp1262
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1263
(F-2.6043418394316227
F-3.21179313659668
tp1264
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1265
(F-2.537959394783809
F-3.2122074127197267
tp1266
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1267
(F-2.475510416666667
F-3.2069488525390626
tp1268
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1269
(F-2.572614284377024
F-3.2283866882324217
tp1270
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1271
(F-2.6004586014093136
F-3.2024730682373046
tp1272
sS'def __init__(self, val):\n    self.val = val'
p1273
(F-0.8858488082885743
F-3.2527671813964845
tp1274
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1275
(F-2.569191741943359
F-3.1913883209228517
tp1276
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1277
(F-2.5992743309507977
F-3.2069164276123048
tp1278
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1279
(F-2.433218515047463
F-3.2390010833740233
tp1280
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p1281
(F-2.136341388408954
F-3.268412780761719
tp1282
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1283
(F-2.819235395091449
F-3.255393218994141
tp1284
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p1285
(F-2.4308846921336893
F-3.250836944580078
tp1286
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1287
(F-2.501805623372396
F-3.223448944091797
tp1288
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1289
(F-2.5462146437311746
F-3.2224632263183595
tp1290
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1291
(F-2.708373378699934
F-3.1941293716430663
tp1292
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1293
(F-2.5216529107862904
F-3.19736385345459
tp1294
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1295
(F-2.5616012794384058
F-3.2153247833251952
tp1296
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1297
(F-2.6128648798516454
F-3.1883636474609376
tp1298
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1299
(F-2.5602453760353914
F-3.211408996582031
tp1300
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1301
(F-2.9298398871170845
F-3.1957609176635744
tp1302
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1303
(F-2.578152550591363
F-3.1720129013061524
tp1304
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1305
(F-2.504101092998798
F-3.210707092285156
tp1306
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1307
(F-2.5531377899512817
F-3.2045936584472656
tp1308
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1309
(F-2.523543915191254
F-3.1899547576904297
tp1310
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1311
(F-2.60006797096946
F-3.198004722595215
tp1312
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1313
(F-2.524462313265414
F-3.2086517333984377
tp1314
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1315
(F-2.5347053713914827
F-3.1866817474365234
tp1316
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1317
(F-2.7165614536830356
F-3.2234428405761717
tp1318
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1319
(F-2.7142203194754466
F-3.2746952056884764
tp1320
sS'a.extend(L)'
p1321
(F-1.8458563089370728
F-3.213285446166992
tp1322
sS'for y in L:\n    a.append(y)'
p1323
(F-1.512595295906067
F-3.2503013610839844
tp1324
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1325
(F-2.642045739578874
F-3.2016666412353514
tp1326
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1327
(F-2.410010201590402
F-3.2062206268310547
tp1328
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1329
(F-2.7125167846679688
F-3.2172901153564455
tp1330
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1331
(F-3.4754776864681602
F-3.316679763793945
tp1332
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1333
(F-2.545637995559977
F-3.20208854675293
tp1334
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1335
(F-2.6199382828314777
F-3.208955764770508
tp1336
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1337
(F-2.555460004664179
F-3.223399353027344
tp1338
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1339
(F-2.667467244466146
F-3.209777069091797
tp1340
sS'if (type(obj[x]) in dignore):\n    pass'
p1341
(F-2.4635067989951684
F-3.199105644226074
tp1342
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1343
(F-2.5926959520623427
F-3.2262916564941406
tp1344
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1345
(F-2.562228410603614
F-3.219870758056641
tp1346
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p1347
(F-1.3732651741273942
F-3.209217071533203
tp1348
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1349
(F-2.6026603435647897
F-3.2338890075683593
tp1350
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1351
(F-2.5398590642755683
F-3.198080825805664
tp1352
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1353
(F-2.662124864982836
F-3.181107521057129
tp1354
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1355
(F-2.7076547622680662
F-3.2404029846191404
tp1356
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1357
(F-2.693684572895999
F-3.1890302658081056
tp1358
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1359
(F-2.606085156637525
F-3.209869384765625
tp1360
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1361
(F-2.5620333839008826
F-3.2289581298828125
tp1362
sS"print 'Custom Copy:', (time() - t)"
p1363
(F-3.126575469970703
F-3.213360595703125
tp1364
sS'c = list(a)'
p1365
(F-2.242138624191284
F-3.2097152709960937
tp1366
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1367
(F-2.493011474609375
F-3.2123672485351564
tp1368
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1369
(F-2.559652109615138
F-3.207022857666016
tp1370
sS'import copy\n\n\nclass Foo(object):\n    pass'
p1371
(F-1.6492025711957146
F-3.250538635253906
tp1372
sS"foo = Foo(1)\na = ['foo', foo]"
p1373
(F-2.742079257965088
F-3.198367881774902
tp1374
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1375
(F-2.71130423710264
F-3.2109958648681642
tp1376
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1377
(F-2.7524079258002123
F-3.269460678100586
tp1378
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1379
(F-2.641881014652179
F-3.208530807495117
tp1380
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1381
(F-2.4586272063078702
F-3.2464195251464845
tp1382
sS'for i in xrange(num_times):\n    L[:]'
p1383
(F-2.7012517828690377
F-3.2671241760253906
tp1384
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1385
(F-2.2086257934570312
F-3.3191226959228515
tp1386
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1387
(F-2.5291173365209008
F-3.355413818359375
tp1388
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1389
(F-2.3435577045787466
F-3.2379985809326173
tp1390
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1391
(F-2.638276226752627
F-3.1901876449584963
tp1392
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1393
(F-2.632140548140914
F-3.2250141143798827
tp1394
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1395
(F-2.61613134765625
F-3.2121417999267576
tp1396
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1397
(F-2.475046396255493
F-3.1926607131958007
tp1398
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1399
(F-2.6983544326410063
F-3.195761871337891
tp1400
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1401
(F-2.579726230951003
F-3.2118534088134765
tp1402
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1403
(F-3.0474203670726103
F-3.2862491607666016
tp1404
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1405
(F-2.5599476405552455
F-3.2235877990722654
tp1406
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1407
(F-2.9959238225763496
F-3.270905685424805
tp1408
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1409
(F-2.6240123625724547
F-3.208179473876953
tp1410
sS'from time import time\nnum_times = 100000'
p1411
(F-3.3586037953694663
F-3.3077743530273436
tp1412
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1413
(F-3.1203945529076362
F-3.25164794921875
tp1414
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)'
p1415
(F-2.399686654408773
F-3.3207836151123047
tp1416
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1417
(F-2.5428901639619097
F-3.2114273071289063
tp1418
sS'if is_tuple:\n    obj = tuple(obj)'
p1419
(F-2.4354567527770996
F-3.282826614379883
tp1420
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1421
(F-2.5490570771529377
F-3.191542053222656
tp1422
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1423
(F-2.623577146601856
F-3.2082725524902345
tp1424
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1425
(F-2.4985041831856343
F-3.2115447998046873
tp1426
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1427
(F-2.5837129865373885
F-3.237662506103516
tp1428
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1429
(F-2.60103636749031
F-3.221004104614258
tp1430
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1431
(F-2.5559750027126737
F-3.2260673522949217
tp1432
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1433
(F-2.633055187406994
F-3.225696563720703
tp1434
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1435
(F-2.6079956690470376
F-3.21085205078125
tp1436
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1437
(F-2.6195047312769395
F-3.191326904296875
tp1438
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1439
(F-2.5374025385430516
F-3.207475280761719
tp1440
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1441
(F-2.4488046169281006
F-3.239786911010742
tp1442
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1443
(F-2.662124864982836
F-3.181107521057129
tp1444
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1445
(F-2.922730067990861
F-3.1786100387573244
tp1446
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1447
(F-2.515469152950546
F-3.1915069580078126
tp1448
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1449
(F-2.514503678726276
F-3.214579772949219
tp1450
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1451
(F-2.4836975828616206
F-3.2133663177490233
tp1452
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1453
(F-2.5358838067538496
F-3.1918432235717775
tp1454
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1455
(F-2.5324166317114094
F-3.2216644287109375
tp1456
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1457
(F-2.649261474609375
F-3.222267913818359
tp1458
sS'c = list(a)\nd = copy.copy(a)'
p1459
(F-2.2759637271656707
F-3.2810302734375
tp1460
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1461
(F-2.7467206954956054
F-3.191684341430664
tp1462
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1463
(F-2.5558095394986347
F-3.216225433349609
tp1464
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1465
(F-2.6775947630874755
F-3.198313522338867
tp1466
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1467
(F-2.601224626813616
F-3.1910608291625975
tp1468
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1469
(F-2.5950924057558358
F-3.2148345947265624
tp1470
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1471
(F-2.6712109601056135
F-3.2028667449951174
tp1472
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1473
(F-2.593509983372044
F-3.1885353088378907
tp1474
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1475
(F-2.6354211628107733
F-3.1971277236938476
tp1476
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1477
(F-2.4608695136176215
F-3.2107624053955077
tp1478
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1479
(F-2.5606933101530998
F-3.190748596191406
tp1480
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1481
(F-2.5483239017315764
F-3.203295135498047
tp1482
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1483
(F-2.508865261670225
F-3.205379867553711
tp1484
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1485
(F-2.5912081561511076
F-3.2072105407714844
tp1486
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1487
(F-2.6014880893812973
F-3.214741897583008
tp1488
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1489
(F-2.538008020279255
F-3.193578910827637
tp1490
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1491
(F-2.2094456481933595
F-3.2197406768798826
tp1492
sS'import copy\nnew_list = copy.deepcopy(old_list)'
p1493
(F-2.267932891845703
F-3.186362075805664
tp1494
sS'class Foo(object):\n    pass'
p1495
(F-1.1709038416544597
F-3.257436752319336
tp1496
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1497
(F-2.6244314870526715
F-3.189553070068359
tp1498
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1499
(F-2.4594488656649025
F-3.2198673248291017
tp1500
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1501
(F-2.6767396746941334
F-3.266325759887695
tp1502
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1503
(F-2.5706300030788176
F-3.2141613006591796
tp1504
sS't = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)'
p1505
(F-2.1627526459870516
F-3.2569900512695313
tp1506
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1507
(F-2.5853587063876065
F-3.225716400146484
tp1508
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1509
(F-2.510128574516937
F-3.2224800109863283
tp1510
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1511
(F-2.308104538336033
F-3.254827880859375
tp1512
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1513
(F-2.468669387529481
F-3.235385513305664
tp1514
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1515
(F-2.706120948268943
F-3.2149379730224608
tp1516
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1517
(F-2.6329345703125
F-3.2403404235839846
tp1518
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1519
(F-2.6373162950788225
F-3.211131286621094
tp1520
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1521
(F-2.6643052782331194
F-3.2451522827148436
tp1522
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p1523
(F-2.387335205078125
F-3.359745407104492
tp1524
sS'num_times = 100000'
p1525
(F-4.267362594604492
F-3.5335159301757812
tp1526
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1527
(F-2.49744873046875
F-3.2048824310302733
tp1528
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1529
(F-2.5681094763413914
F-3.199411392211914
tp1530
sS'a.append(y)'
p1531
(F-2.076645851135254
F-3.1938858032226562
tp1532
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1533
(F-2.7664900885687933
F-3.184575843811035
tp1534
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1535
(F-2.6126427120632596
F-3.2197681427001954
tp1536
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1537
(F-2.569910701788986
F-3.2054683685302736
tp1538
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1539
(F-2.590242146142845
F-3.20518798828125
tp1540
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1541
(F-2.6239755991342903
F-3.188398742675781
tp1542
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1543
(F-2.5499762131762598
F-3.2099647521972656
tp1544
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1545
(F-2.5079179243607954
F-3.2233654022216798
tp1546
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1547
(F-2.5685094045307824
F-3.2001441955566405
tp1548
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1549
(F-3.084008353097098
F-3.192372131347656
tp1550
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1551
(F-2.5609464726896367
F-3.2326290130615236
tp1552
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1553
(F-2.6595681680215373
F-3.1935392379760743
tp1554
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1555
(F-2.458488608306309
F-3.1976118087768555
tp1556
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1557
(F-2.7269087897406683
F-3.193670654296875
tp1558
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1559
(F-2.5277804522447185
F-3.215056228637695
tp1560
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1561
(F-2.622290826612903
F-3.23388671875
tp1562
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1563
(F-2.5815076606218206
F-3.2063220977783202
tp1564
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1565
(F-2.7903322630290743
F-3.213755416870117
tp1566
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1567
(F-2.523079820858535
F-3.211505126953125
tp1568
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1569
(F-2.458436867042824
F-3.2381412506103517
tp1570
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1571
(F-2.58165087890625
F-3.2123332977294923
tp1572
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1573
(F-2.3599120022957787
F-3.210297393798828
tp1574
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1575
(F-3.0085104864996834
F-3.266779327392578
tp1576
sS'for i in xrange(num_times):\n    a = []\na.extend(L)'
p1577
(F-2.1753368377685547
F-3.2593719482421877
tp1578
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1579
(F-2.5829312102963224
F-3.206509017944336
tp1580
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1581
(F-2.5867703412030196
F-3.2022979736328123
tp1582
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1583
(F-2.5920412531158803
F-3.193259429931641
tp1584
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1585
(F-2.5471104213169644
F-3.205130767822266
tp1586
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)"
p1587
(F-2.064869092858356
F-3.2493831634521486
tp1588
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1589
(F-2.5601897063078702
F-3.2072528839111327
tp1590
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1591
(F-2.540272549059264
F-3.2224979400634766
tp1592
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1593
(F-2.5098800659179688
F-3.2223079681396483
tp1594
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1595
(F-2.5352171077284704
F-3.2154052734375
tp1596
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1597
(F-2.4502298396869295
F-3.2209217071533205
tp1598
sS"if (__name__ == '__main__'):\n    pass"
p1599
(F-1.808441162109375
F-3.197747230529785
tp1600
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1601
(F-2.5305316631610575
F-3.2133644104003904
tp1602
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1603
(F-2.58384912109375
F-3.2141822814941405
tp1604
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1605
(F-2.725716127168148
F-3.2022953033447266
tp1606
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1607
(F-2.4801983642578125
F-3.2132236480712892
tp1608
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1609
(F-2.8564172861527424
F-3.1829044342041017
tp1610
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1611
(F-2.6704285208102876
F-3.211200714111328
tp1612
sS"print 'copy.copy:', (time() - t)\nt = time()"
p1613
(F-3.558274163140191
F-3.2141300201416017
tp1614
sS'import copy\nnew_list = copy.copy(old_list)'
p1615
(F-2.472835091983571
F-3.206478500366211
tp1616
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1617
(F-3.193391305428964
F-3.2276416778564454
tp1618
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1619
(F-2.5229022146641524
F-3.197977638244629
tp1620
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1621
(F-2.603046875
F-3.189419746398926
tp1622
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1623
(F-2.6399219654224537
F-3.2060298919677734
tp1624
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1625
(F-2.5705169349588375
F-3.2114830017089844
tp1626
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1627
(F-2.8006729618195565
F-3.225331497192383
tp1628
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1629
(F-2.559858684298358
F-3.2277393341064453
tp1630
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1631
(F-2.5794288334453404
F-3.1896907806396486
tp1632
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1633
(F-3.2358499145507813
F-3.1756752014160154
tp1634
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1635
(F-2.5977522629957934
F-3.196100616455078
tp1636
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1637
(F-2.533020221634416
F-3.2296371459960938
tp1638
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1639
(F-2.7630120982294497
F-3.200975036621094
tp1640
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1641
(F-2.6664467745049056
F-3.19246826171875
tp1642
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1643
(F-2.4617708764895045
F-3.2299293518066405
tp1644
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p1645
(F-2.507042038608605
F-3.2404220581054686
tp1646
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1647
(F-2.546010788838575
F-3.1918912887573243
tp1648
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1649
(F-2.5287247899931424
F-3.2141590118408203
tp1650
sS"a = ['foo', foo]\nb = a[:]"
p1651
(F-2.303182363510132
F-3.2169708251953124
tp1652
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1653
(F-1.7418634588068183
F-3.1860122680664062
tp1654
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1655
(F-2.5991504245334203
F-3.2196449279785155
tp1656
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1657
(F-2.3282432984770014
F-3.2202552795410155
tp1658
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1659
(F-2.6246369735054347
F-3.2047657012939452
tp1660
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1661
(F-2.5600983992866846
F-3.188975524902344
tp1662
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1663
(F-2.0866099390490302
F-3.2514064788818358
tp1664
sS"def __init__(self):\n    self.blah = 'blah'"
p1665
(F-1.1579110887315538
F-3.248553466796875
tp1666
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1667
(F-2.52320019166861
F-3.1888940811157225
tp1668
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1669
(F-2.5043876861857477
F-3.2256191253662108
tp1670
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1671
(F-2.489775205369241
F-3.213072967529297
tp1672
sS't = type(obj)'
p1673
(F-3.094931125640869
F-3.236507797241211
tp1674
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1675
(F-2.615549325942993
F-3.2272361755371093
tp1676
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1677
(F-2.4452559621710526
F-3.222028350830078
tp1678
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1679
(F-2.6199474044257616
F-3.202569580078125
tp1680
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1681
(F-2.498981700224035
F-3.2232398986816406
tp1682
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1683
(F-2.5267018404873935
F-3.2022541046142576
tp1684
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1685
(F-2.9530986439098013
F-3.1903450012207033
tp1686
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1687
(F-2.7192027240718177
F-3.1987985610961913
tp1688
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1689
(F-2.596277090219351
F-3.229852294921875
tp1690
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p1691
(F-2.44646762816374
F-3.2170783996582033
tp1692
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1693
(F-2.5464412531203773
F-3.190364646911621
tp1694
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1695
(F-2.6094199470851733
F-3.222654342651367
tp1696
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1697
(F-2.492279892667718
F-3.2297122955322264
tp1698
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1699
(F-2.5573535597467996
F-3.2212665557861326
tp1700
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1701
(F-2.5023499555811037
F-3.2070037841796877
tp1702
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1703
(F-2.5609713267131022
F-3.2187210083007813
tp1704
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1705
(F-2.5782066692005503
F-3.188888168334961
tp1706
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1707
(F-3.126575469970703
F-3.213360595703125
tp1708
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1709
(F-2.7553048384817025
F-3.1877168655395507
tp1710
sS"self.blah = 'blah'"
p1711
(F-2.7494700295584544
F-3.2771347045898436
tp1712
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1713
(F-1.7668111464556526
F-3.1983245849609374
tp1714
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p1715
(F-1.0404000022194602
F-3.2179779052734374
tp1716
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1717
(F-2.672376184655516
F-3.2529640197753906
tp1718
sS'for i in xrange(num_times):\n    copy.copy(L)'
p1719
(F-2.1099664597284224
F-3.214783477783203
tp1720
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1721
(F-2.6640254720052083
F-3.2016021728515627
tp1722
sS'from copy import deepcopy\n\n\nclass old_class:\n    pass'
p1723
(F-2.8771625094943576
F-3.2021366119384767
tp1724
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1725
(F-2.273092169510691
F-3.242115783691406
tp1726
sS'for x in xrange(len(obj)):\n    pass'
p1727
(F-1.5763130187988281
F-3.2179550170898437
tp1728
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1729
(F-2.5495698614771585
F-3.2228904724121095
tp1730
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1731
(F-2.6418499027917144
F-3.200567626953125
tp1732
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1733
(F-2.9940484364827475
F-3.1939929962158202
tp1734
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1735
(F-2.5663974132602063
F-3.210125732421875
tp1736
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1737
(F-2.681436503763164
F-3.2202457427978515
tp1738
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1739
(F-2.662124864982836
F-3.181107521057129
tp1740
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1741
(F-2.915674163074028
F-3.2772350311279297
tp1742
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1743
(F-2.7379120761908373
F-3.2094676971435545
tp1744
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1745
(F-2.6745514672649793
F-3.1915449142456054
tp1746
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1747
(F-2.5605217519432606
F-3.2209957122802733
tp1748
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1749
(F-2.556466416181144
F-3.2127010345458986
tp1750
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1751
(F-2.402922787873641
F-3.3475059509277343
tp1752
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1753
(F-1.7418441072516484
F-3.17935848236084
tp1754
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1755
(F-2.643788157643138
F-3.240892791748047
tp1756
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1757
(F-2.5824554001075635
F-3.189195251464844
tp1758
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1759
(F-2.6366124933416195
F-3.2121925354003906
tp1760
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1761
(F-2.587024450302124
F-3.1966070175170898
tp1762
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1763
(F-2.6491815573395696
F-3.2091670989990235
tp1764
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1765
(F-2.538916390701379
F-3.2083511352539062
tp1766
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p1767
(F-1.9762545215840241
F-3.2325408935546873
tp1768
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1769
(F-2.5731981793186693
F-3.201508331298828
tp1770
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1771
(F-2.5287341442736953
F-3.202487564086914
tp1772
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1773
(F-2.5228611427017404
F-3.2023551940917967
tp1774
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1775
(F-2.611754519440407
F-3.1896780014038084
tp1776
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1777
(F-2.51699759213979
F-3.211736297607422
tp1778
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1779
(F-2.538144787254236
F-3.193147659301758
tp1780
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1781
(F-2.3570490127954726
F-3.2843372344970705
tp1782
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1783
(F-2.4506663154153263
F-3.2333789825439454
tp1784
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1785
(F-2.8130042336203833
F-3.1939903259277345
tp1786
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1787
(F-2.9997218205378604
F-3.2753746032714846
tp1788
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1789
(F-2.5074316332043125
F-3.2116519927978517
tp1790
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1791
(F-2.4059769479851973
F-3.2332294464111326
tp1792
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1793
(F-2.5158499127867593
F-3.2388160705566404
tp1794
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1795
(F-2.7588179078820634
F-3.1995534896850586
tp1796
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1797
(F-2.6200919681125217
F-3.2124732971191405
tp1798
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1799
(F-2.5826321072048612
F-3.189696502685547
tp1800
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1801
(F-2.4916738628987387
F-3.2025833129882812
tp1802
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1803
(F-2.597601754324777
F-3.200399398803711
tp1804
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1805
(F-2.5877375570575842
F-3.2314529418945312
tp1806
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1807
(F-2.722382236534441
F-3.190703201293945
tp1808
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1809
(F-2.5243601305731413
F-3.232727813720703
tp1810
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1811
(F-2.5539345642343103
F-3.189340591430664
tp1812
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1813
(F-2.572698096706443
F-3.2367454528808595
tp1814
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1815
(F-3.076771206325955
F-3.193359375
tp1816
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1817
(F-2.686249305462015
F-3.224930191040039
tp1818
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1819
(F-2.518050993331755
F-3.2065170288085936
tp1820
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1821
(F-2.5388015587570774
F-3.202370452880859
tp1822
sS'foo = Foo(1)'
p1823
(F-2.841013193130493
F-3.2072410583496094
tp1824
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1825
(F-2.6898824432749806
F-3.2099666595458984
tp1826
sS"print 'copy.deepcopy:', (time() - t)\nt = time()"
p1827
(F-3.5582737392849393
F-3.2141300201416017
tp1828
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1829
(F-2.657571892989309
F-3.213398742675781
tp1830
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1831
(F-2.7501672708763265
F-3.262894058227539
tp1832
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1833
(F-2.44032711452908
F-3.20706787109375
tp1834
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1835
(F-2.8604897787404613
F-3.201952362060547
tp1836
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1837
(F-2.8426199153978
F-3.1999538421630858
tp1838
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1839
(F-2.7460088018161146
F-3.2317996978759767
tp1840
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1841
(F-2.880128960860403
F-3.2832408905029298
tp1842
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1843
(F-2.806771810952719
F-3.189068412780762
tp1844
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1845
(F-2.656688327404539
F-3.2093215942382813
tp1846
sS'new_list = old_list[:]'
p1847
(F-2.4870999654134116
F-3.2116744995117186
tp1848
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1849
(F-2.5267757586578825
F-3.2141109466552735
tp1850
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1851
(F-3.23042819374486
F-3.275388717651367
tp1852
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1853
(F-2.502268450135251
F-3.214239501953125
tp1854
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1855
(F-2.8154785721390336
F-3.1812305450439453
tp1856
sS'obj[x] = Copy(obj[x], use_deepcopy)'
p1857
(F-3.010339101155599
F-3.2535839080810547
tp1858
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1859
(F-2.5214145366962137
F-3.2306282043457033
tp1860
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1861
(F-2.738144035626175
F-3.1977165222167967
tp1862
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1863
(F-2.7211334705352783
F-3.220746612548828
tp1864
sS'class new_class(object):\n    pass'
p1865
(F-2.380110331944057
F-3.306100082397461
tp1866
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1867
(F-2.6004562377929688
F-3.1830780029296877
tp1868
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1869
(F-2.5103659258631175
F-3.209377670288086
tp1870
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p1871
(F-2.244854624678449
F-3.2745956420898437
tp1872
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1873
(F-2.586456005389874
F-3.2099124908447267
tp1874
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1875
(F-2.754028871834996
F-3.2357833862304686
tp1876
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1877
(F-2.6319745173219773
F-3.2028762817382814
tp1878
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1879
(F-2.757112959740867
F-3.193765068054199
tp1880
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1881
(F-2.569770060794454
F-3.2170108795166015
tp1882
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p1883
(F-3.46475830078125
F-3.2202510833740234
tp1884
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1885
(F-2.6205662907780827
F-3.215850830078125
tp1886
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1887
(F-2.602828859344242
F-3.2131534576416017
tp1888
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1889
(F-2.52200248889495
F-3.192780876159668
tp1890
sS'from time import time'
p1891
(F-4.548229853312175
F-3.3148639678955076
tp1892
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1893
(F-2.553628576807229
F-3.2131248474121095
tp1894
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1895
(F-2.8151334436928352
F-3.187312889099121
tp1896
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1897
(F-2.5889720210322626
F-3.2277183532714844
tp1898
sS'import copy'
p1899
(F-6.205132007598877
F-3.2446662902832033
tp1900
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1901
(F-2.213918113708496
F-3.2381587982177735
tp1902
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1903
(F-2.5987359541880934
F-3.204611587524414
tp1904
sS'if (t in (list, tuple)):\n    pass'
p1905
(F-3.6568634930778954
F-3.2286022186279295
tp1906
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1907
(F-3.1242337908063615
F-3.1921049118041993
tp1908
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1909
(F-2.5995238920601693
F-3.2109294891357423
tp1910
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1911
(F-2.6246248965231787
F-3.209961700439453
tp1912
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1913
(F-2.5229650503946246
F-3.204328155517578
tp1914
sS'self.val = val'
p1915
(F-2.2254461560930525
F-3.300690460205078
tp1916
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1917
(F-2.525077169255693
F-3.2007652282714845
tp1918
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1919
(F-2.6223191910138413
F-3.207769775390625
tp1920
sS'list(L)'
p1921
(F-1.6951653162638347
F-3.1821470260620117
tp1922
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1923
(F-2.708586091448547
F-3.202886962890625
tp1924
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1925
(F-2.766261691138858
F-3.1713207244873045
tp1926
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1927
(F-2.578578435724432
F-3.2097660064697267
tp1928
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1929
(F-2.6592448706765777
F-3.1861738204956054
tp1930
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1931
(F-2.499113174741059
F-3.2069549560546875
tp1932
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1933
(F-2.5106105638586955
F-3.2109611511230467
tp1934
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1935
(F-2.505827326439695
F-3.2094982147216795
tp1936
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1937
(F-2.5808540852864583
F-3.2238792419433593
tp1938
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1939
(F-2.5598281639209692
F-3.203668975830078
tp1940
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1941
(F-2.79220731758777
F-3.216871643066406
tp1942
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1943
(F-2.4973293624761452
F-3.219140625
tp1944
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1945
(F-2.8044344927813554
F-3.2025436401367187
tp1946
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1947
(F-2.5678207483668785
F-3.2059471130371096
tp1948
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1949
(F-1.478382373678273
F-3.243150329589844
tp1950
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1951
(F-2.682813517252604
F-3.219135284423828
tp1952
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1953
(F-2.8771158854166665
F-3.1953540802001954
tp1954
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1955
(F-2.538719369583771
F-3.205011749267578
tp1956
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p1957
(F-2.415387725830078
F-3.308711624145508
tp1958
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1959
(F-2.3588575758375563
F-3.2367786407470702
tp1960
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1961
(F-2.2933432595771657
F-3.1851211547851563
tp1962
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1963
(F-2.6706936858421146
F-3.1858636856079103
tp1964
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1965
(F-1.6025050127947773
F-3.222283935546875
tp1966
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1967
(F-2.675264766298491
F-3.208150863647461
tp1968
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1969
(F-2.5504685203627786
F-3.2109859466552733
tp1970
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1971
(F-3.098831501412899
F-3.1862030029296875
tp1972
sS'[i for i in L]'
p1973
(F-2.288354237874349
F-3.255331039428711
tp1974
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1975
(F-2.8338734460255455
F-3.194790840148926
tp1976
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p1977
(F-1.5927638099307107
F-3.1809974670410157
tp1978
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1979
(F-2.662124864982836
F-3.181107521057129
tp1980
sS't = time()'
p1981
(F-3.385046822684152
F-3.2343521118164062
tp1982
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1983
(F-2.59436864939341
F-3.190250778198242
tp1984
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1985
(F-2.5892797950806656
F-3.1823020935058595
tp1986
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1987
(F-2.589251708984375
F-3.2128501892089845
tp1988
sS't = time()\nfor i in xrange(num_times):\n    [i for i in L]'
p1989
(F-2.593439374651228
F-3.2342754364013673
tp1990
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1991
(F-2.569551142939815
F-3.195566940307617
tp1992
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1993
(F-2.6415353548728815
F-3.1917322158813475
tp1994
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1995
(F-2.5402659754599295
F-3.219309616088867
tp1996
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1997
(F-2.751903564453125
F-3.191941833496094
tp1998
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p1999
(F-2.7853262382641173
F-3.243243408203125
tp2000
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p2001
(F-2.1159024360852365
F-3.255618667602539
tp2002
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2003
(F-1.7344548842486214
F-3.1806703567504884
tp2004
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2005
(F-2.5937514395084023
F-3.210546112060547
tp2006
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2007
(F-2.423609503384294
F-3.2151157379150392
tp2008
sS'is_tuple = True'
p2009
(F-3.430753435407366
F-3.2123157501220705
tp2010
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2011
(F-2.4501164583551804
F-3.2285911560058596
tp2012
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2013
(F-2.813739717923678
F-3.3221969604492188
tp2014
sS'copy.deepcopy(L)'
p2015
(F-2.278021812438965
F-3.2398990631103515
tp2016
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2017
(F-2.6092953401453354
F-3.202398681640625
tp2018
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2019
(F-2.5404194839128103
F-3.2144775390625
tp2020
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2021
(F-3.2524600558810763
F-3.210562896728516
tp2022
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2023
(F-2.3656974582497132
F-3.3657325744628905
tp2024
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2025
(F-2.4325728743043666
F-3.229470062255859
tp2026
sS'd = copy.copy(a)\ne = copy.deepcopy(a)'
p2027
(F-2.7002386795847038
F-3.233301544189453
tp2028
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2029
(F-1.8565423628863167
F-3.253680419921875
tp2030
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2031
(F-2.539726553037185
F-3.2070640563964843
tp2032
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2033
(F-2.73087639208661
F-3.2123668670654295
tp2034
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2035
(F-2.476656442665192
F-3.3167865753173826
tp2036
sS'from copy import deepcopy'
p2037
(F-4.060742060343425
F-3.197218894958496
tp2038
sS"e = copy.deepcopy(a)\na.append('baz')"
p2039
(F-2.3466913559857536
F-3.164667510986328
tp2040
sS'class Foo(object):\n\n    def __init__(self, val):\n        pass'
p2041
(F-0.8741457278911884
F-3.2443851470947265
tp2042
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2043
(F-2.6558742011643917
F-3.18987922668457
tp2044
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2045
(F-2.7100987927667024
F-3.2041114807128905
tp2046
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2047
(F-2.7927238650438264
F-3.2467491149902346
tp2048
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2049
(F-2.742538949717646
F-3.1929235458374023
tp2050
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2051
(F-2.5044435041224062
F-3.2168888092041015
tp2052
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2053
(F-2.59397976554959
F-3.1980247497558594
tp2054
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2055
(F-2.76938182902786
F-3.2021141052246094
tp2056
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2057
(F-2.6478181177256057
F-3.207422637939453
tp2058
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2059
(F-2.6663052388374378
F-3.2041370391845705
tp2060
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2061
(F-2.5203688231156898
F-3.2072208404541014
tp2062
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2063
(F-2.8371926165641623
F-3.190108299255371
tp2064
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2065
(F-2.501082989348083
F-3.1908926010131835
tp2066
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2067
(F-2.5178822749803045
F-3.204598617553711
tp2068
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2069
(F-2.573303699493408
F-3.2137771606445313
tp2070
sS'for i in xrange(num_times):\n    pass'
p2071
(F-1.8844561576843262
F-3.196487617492676
tp2072
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2073
(F-2.38437206340286
F-3.230405807495117
tp2074
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2075
(F-2.5317457332167517
F-3.2141536712646483
tp2076
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2077
(F-2.5533941359747026
F-3.2198036193847654
tp2078
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2079
(F-2.571020762125651
F-3.208389663696289
tp2080
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2081
(F-2.5336151123046875
F-3.234845733642578
tp2082
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2083
(F-2.372569065467984
F-3.1905838012695313
tp2084
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2085
(F-2.6003204345703126
F-3.2037872314453124
tp2086
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2087
(F-2.499969970703125
F-3.2305252075195314
tp2088
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2089
(F-2.662124864982836
F-3.181107521057129
tp2090
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2091
(F-2.529066061671776
F-3.198738861083984
tp2092
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2093
(F-2.663663591657366
F-3.214579772949219
tp2094
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2095
(F-2.5536637652183556
F-3.2145824432373047
tp2096
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p2097
(F-2.2451299584430195
F-3.2650577545166017
tp2098
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2099
(F-2.5492742365056817
F-3.2205036163330076
tp2100
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2101
(F-2.532257167022792
F-3.2105789184570312
tp2102
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2103
(F-2.687901547080592
F-3.2008731842041014
tp2104
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2105
(F-2.676920140043218
F-3.2131816864013674
tp2106
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2107
(F-2.4351364380535596
F-3.215637969970703
tp2108
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2109
(F-2.4033075968424478
F-3.1958003997802735
tp2110
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2111
(F-2.556504508940246
F-3.2093849182128906
tp2112
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2113
(F-2.5646910691624365
F-3.1902851104736327
tp2114
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2115
(F-2.5540936323848085
F-3.2178016662597657
tp2116
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2117
(F-2.678986493278952
F-3.1894454956054688
tp2118
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2119
(F-2.5492075327280403
F-3.2080413818359377
tp2120
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2121
(F-2.3585115485235093
F-3.360251617431641
tp2122
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2123
(F-2.595928770123106
F-3.2069717407226563
tp2124
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2125
(F-2.5689298189603367
F-3.1967437744140623
tp2126
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2127
(F-2.544808127663352
F-3.2248748779296874
tp2128
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }'
p2129
(F-3.3903814697265626
F-3.237416458129883
tp2130
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2131
(F-2.561906448518387
F-3.2336963653564452
tp2132
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2133
(F-2.6603064598975243
F-3.321303939819336
tp2134
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2135
(F-2.5529670536238265
F-3.2082393646240233
tp2136
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2137
(F-2.750271797180176
F-3.2364803314208985
tp2138
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2139
(F-2.77790428610409
F-3.185693359375
tp2140
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2141
(F-3.5582737392849393
F-3.2141300201416017
tp2142
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2143
(F-2.5657820830474027
F-3.199398422241211
tp2144
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2145
(F-2.5739410735748627
F-3.228711700439453
tp2146
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2147
(F-2.588449578536184
F-3.2185779571533204
tp2148
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2149
(F-2.0946537562779017
F-3.2419544219970704
tp2150
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2151
(F-2.5456967933155665
F-3.190006637573242
tp2152
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2153
(F-2.6546925511853448
F-3.2021434783935545
tp2154
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2155
(F-2.585651419016236
F-3.2045352935791014
tp2156
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2157
(F-2.8467056065389555
F-3.229514312744141
tp2158
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2159
(F-2.5973843944316006
F-3.2088497161865233
tp2160
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2161
(F-2.4963077910958904
F-3.194574737548828
tp2162
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2163
(F-2.5481718459931932
F-3.190044975280762
tp2164
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2165
(F-2.4222992736023743
F-3.346216583251953
tp2166
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2167
(F-2.655496775880735
F-3.2215145111083983
tp2168
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2169
(F-2.424409981233528
F-3.225265884399414
tp2170
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2171
(F-2.9476387023925783
F-3.180685806274414
tp2172
sS't = time()\nfor i in xrange(num_times):\n    copy.copy(L)'
p2173
(F-2.3172820762351707
F-3.1962377548217775
tp2174
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2175
(F-2.486888655697007
F-3.2150745391845703
tp2176
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2177
(F-2.5784618086197053
F-3.1987224578857423
tp2178
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2179
(F-2.5424814826230273
F-3.2057926177978517
tp2180
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2181
(F-2.6334593652630134
F-3.2098846435546875
tp2182
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p2183
(F-2.4310321229876894
F-3.2881187438964843
tp2184
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2185
(F-3.300505989476254
F-3.189156723022461
tp2186
sS'new_list = copy.copy(old_list)'
p2187
(F-2.2802538190569197
F-3.244533157348633
tp2188
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2189
(F-2.4959056957347974
F-3.203863525390625
tp2190
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2191
(F-2.5141519480738146
F-3.207569885253906
tp2192
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2193
(F-2.4909052309782607
F-3.217474365234375
tp2194
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2195
(F-2.6979970210740545
F-3.1928022384643553
tp2196
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2197
(F-2.614062368387803
F-3.225171661376953
tp2198
sS'if (type(obj[k]) in dignore):\n    pass'
p2199
(F-2.4240564045153166
F-3.222685623168945
tp2200
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2201
(F-2.3880372224030673
F-3.2701976776123045
tp2202
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2203
(F-1.4342296893780049
F-3.194468307495117
tp2204
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2205
(F-2.5466390790092226
F-3.191439628601074
tp2206
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2207
(F-2.5849666800550235
F-3.2044036865234373
tp2208
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2209
(F-2.584663159919508
F-3.216930389404297
tp2210
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2211
(F-2.7664900885687933
F-3.184575843811035
tp2212
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2213
(F-2.5384756234975963
F-3.191216468811035
tp2214
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2215
(F-3.4320763121259974
F-3.3401565551757812
tp2216
sS'obj = tuple(obj)'
p2217
(F-2.6869819164276123
F-3.302834320068359
tp2218
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2219
(F-2.439175021263861
F-3.212062454223633
tp2220
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2221
(F-2.5728707299874642
F-3.187738227844238
tp2222
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2223
(F-2.662124864982836
F-3.181107521057129
tp2224
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2225
(F-2.521217693813699
F-3.1936691284179686
tp2226
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2227
(F-2.6639552646213107
F-3.185883903503418
tp2228
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2229
(F-2.626768085318552
F-3.1908470153808595
tp2230
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2231
(F-2.5215597031991694
F-3.2120410919189455
tp2232
sS'd = copy.copy(a)'
p2233
(F-2.9232624053955076
F-3.2699039459228514
tp2234
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2235
(F-2.6080996426669034
F-3.1901527404785157
tp2236
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2237
(F-2.5379504788306453
F-3.2008216857910154
tp2238
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2239
(F-2.552291457717483
F-3.2063453674316404
tp2240
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2241
(F-2.7829821268717447
F-3.19610710144043
tp2242
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2243
(F-2.5862562136542526
F-3.1981832504272463
tp2244
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2245
(F-2.4827108747972164
F-3.210894012451172
tp2246
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2247
(F-2.5141615867614746
F-3.2210205078125
tp2248
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2249
(F-2.5482181816994145
F-3.208133316040039
tp2250
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2251
(F-2.7020032159213363
F-3.2098278045654296
tp2252
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2253
(F-2.6428360686285335
F-3.1967239379882812
tp2254
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2255
(F-2.582202860058156
F-3.191640853881836
tp2256
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2257
(F-2.6095157877604165
F-3.193114471435547
tp2258
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2259
(F-2.5283305719707085
F-3.200022506713867
tp2260
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2261
(F-2.614169887729458
F-3.1869037628173826
tp2262
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2263
(F-2.5270130649958973
F-3.195835304260254
tp2264
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2265
(F-2.500322418897141
F-3.2083724975585937
tp2266
sS'a = []'
p2267
(F-3.596229871114095
F-3.1974964141845703
tp2268
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2269
(F-2.1669660497594765
F-3.290283203125
tp2270
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2271
(F-2.6102594796836227
F-3.2257720947265627
tp2272
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2273
(F-2.126921468706273
F-3.2435989379882812
tp2274
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p2275
(F-1.8477906891793916
F-3.2603546142578126
tp2276
sS"print ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2277
(F-1.949827406141493
F-3.2721111297607424
tp2278
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2279
(F-2.434218067233845
F-3.188365364074707
tp2280
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2281
(F-2.6101874635930646
F-3.228549575805664
tp2282
sS"print 'list slicing [:]:', (time() - t)"
p2283
(F-3.126575469970703
F-3.213360595703125
tp2284
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2285
(F-2.504163296737335
F-3.1987937927246093
tp2286
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2287
(F-2.500230500192353
F-3.204951858520508
tp2288
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2289
(F-2.6858194139268665
F-3.2014915466308596
tp2290
sS'def __init__(self):\n    pass'
p2291
(F-1.279043742588588
F-3.2958000183105467
tp2292
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2293
(F-2.6683136789422286
F-3.2521881103515624
tp2294
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2295
(F-2.255604989188058
F-3.1835723876953126
tp2296
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2297
(F-2.6446821137336687
F-3.2074748992919924
tp2298
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2299
(F-2.585021179991883
F-3.2244491577148438
tp2300
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p2301
(F-1.0985891381088568
F-3.22237548828125
tp2302
sS't = time()\nfor i in xrange(num_times):\n    list(L)'
p2303
(F-2.2215953063964844
F-3.1971818923950197
tp2304
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2305
(F-2.6220345445858535
F-3.217197799682617
tp2306
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2307
(F-1.6911648609599128
F-3.229105758666992
tp2308
sS'def Copy(obj, use_deepcopy=True):\n    pass'
p2309
(F-1.8839244842529297
F-3.256046676635742
tp2310
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p2311
(F-2.7639701149680396
F-3.1789751052856445
tp2312
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2313
(F-2.6224127269926525
F-3.2245983123779296
tp2314
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2315
(F-2.5183181762695312
F-3.310980224609375
tp2316
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2317
(F-2.287370409284319
F-3.2571365356445314
tp2318
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2319
(F-2.4672105816048635
F-3.225467300415039
tp2320
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2321
(F-2.5911351502171813
F-3.2145126342773436
tp2322
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2323
(F-2.495200635566086
F-3.204206085205078
tp2324
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2325
(F-2.518288782400678
F-3.212894058227539
tp2326
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p2327
(F-2.970212599810432
F-3.3047359466552733
tp2328
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2329
(F-2.570411018703295
F-3.1853614807128907
tp2330
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2331
(F-2.6930698338400556
F-3.2256664276123046
tp2332
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2333
(F-2.5614731732536766
F-3.205859375
tp2334
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p2335
(F-2.698426478117415
F-3.230294036865234
tp2336
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2337
(F-2.852388218470982
F-3.18505916595459
tp2338
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2339
(F-2.3205735948350696
F-3.1806243896484374
tp2340
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2341
(F-2.4885461284387067
F-3.2083988189697266
tp2342
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2343
(F-2.5840281554918247
F-3.2089984893798826
tp2344
sS'for k in obj:\n    pass'
p2345
(F-2.075185602361506
F-3.227345275878906
tp2346
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2347
(F-2.626053713680653
F-3.193369483947754
tp2348
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2349
(F-3.0094745520389443
F-3.2763389587402343
tp2350
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2351
(F-2.468496336159131
F-3.2234966278076174
tp2352
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2353
(F-2.2231440688624526
F-3.2172618865966798
tp2354
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2355
(F-2.628043717252994
F-3.1879627227783205
tp2356
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2357
(F-2.683686578388766
F-3.2208213806152344
tp2358
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2359
(F-2.4558168661714803
F-3.2229637145996093
tp2360
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2361
(F-2.4980757279829544
F-3.2169773101806642
tp2362
sS"print 'copy.deepcopy:', (time() - t)"
p2363
(F-3.126575469970703
F-3.213360595703125
tp2364
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2365
(F-2.445509521484375
F-3.207889938354492
tp2366
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2367
(F-2.6309561032300803
F-3.2145313262939452
tp2368
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2369
(F-2.609458509341691
F-3.191793441772461
tp2370
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2371
(F-2.5473047373246174
F-3.202831268310547
tp2372
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2373
(F-2.467197042115977
F-3.325112152099609
tp2374
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2375
(F-2.7777666707677167
F-3.1914899826049803
tp2376
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2377
(F-2.617823565447772
F-3.2044506072998047
tp2378
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p2379
(F-2.572850579383389
F-3.2461620330810548
tp2380
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p2381
(F-1.8445180257161458
F-3.2540164947509767
tp2382
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2383
(F-2.4906150338730373
F-3.2157562255859373
tp2384
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2385
(F-2.588848009786971
F-3.2107189178466795
tp2386
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2387
(F-2.419196077095446
F-3.224766159057617
tp2388
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2389
(F-2.5549163818359375
F-3.204669952392578
tp2390
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2391
(F-2.701505235805633
F-3.1941301345825197
tp2392
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2393
(F-2.5131655218880935
F-3.2331096649169924
tp2394
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2395
(F-2.477754887846327
F-3.208312225341797
tp2396
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2397
(F-2.5599854667231723
F-3.208169174194336
tp2398
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2399
(F-2.5259267706620068
F-3.1941577911376955
tp2400
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2401
(F-2.6125856236049105
F-3.218272399902344
tp2402
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2403
(F-2.583123553240741
F-3.2070274353027344
tp2404
sS'obj = deepcopy(obj)'
p2405
(F-2.5655136108398438
F-3.3346817016601564
tp2406
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2407
(F-2.5380574040368615
F-3.205251693725586
tp2408
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2409
(F-2.468967625352203
F-3.2318771362304686
tp2410
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2411
(F-2.5508516584123884
F-3.193272018432617
tp2412
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2413
(F-2.486968994140625
F-3.2155948638916017
tp2414
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2415
(F-2.4928956112619174
F-3.216645050048828
tp2416
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2417
(F-2.5503346034458705
F-3.221217727661133
tp2418
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2419
(F-2.5579414774938836
F-3.202591323852539
tp2420
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p2421
(F-3.1297962701142725
F-3.1801856994628905
tp2422
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2423
(F-2.5481304093903185
F-3.2046985626220703
tp2424
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2425
(F-2.6288865851776215
F-3.2234050750732424
tp2426
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2427
(F-2.802360604662414
F-3.207728958129883
tp2428
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2429
(F-2.1727359294891357
F-3.294108581542969
tp2430
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2431
(F-2.4326970953690377
F-3.219327926635742
tp2432
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2433
(F-2.6831146949945492
F-3.190780258178711
tp2434
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2435
(F-2.453557891845703
F-3.220911407470703
tp2436
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2437
(F-2.5230312433717477
F-3.212910842895508
tp2438
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2439
(F-2.5638944391618694
F-3.2208351135253905
tp2440
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2441
(F-2.662124864982836
F-3.181107521057129
tp2442
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2443
(F-2.548576726140203
F-3.212021255493164
tp2444
sS'a.extend((i for i in L))'
p2445
(F-2.0291061401367188
F-3.2671432495117188
tp2446
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2447
(F-2.494093586085254
F-3.208792877197266
tp2448
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p2449
(F-2.335754939488002
F-3.309557342529297
tp2450
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2451
(F-2.564024167640187
F-3.201338195800781
tp2452
sS'for i in xrange(num_times):\n    a = []'
p2453
(F-2.135201905903063
F-3.2482666015625
tp2454
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    pass'
p2455
(F-2.024217688519022
F-3.2371185302734373
tp2456
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2457
(F-2.728476590888445
F-3.1970306396484376
tp2458
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2459
(F-2.531966914571458
F-3.197920036315918
tp2460
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2461
(F-2.61866212502504
F-3.201186752319336
tp2462
sS'if (type(obj[k]) in dignore):\n    continue'
p2463
(F-2.5618515014648438
F-3.2458606719970704
tp2464
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)'
p2465
(F-2.367182493209839
F-3.216566467285156
tp2466
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2467
(F-2.3165603637695313
F-3.2479633331298827
tp2468
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2469
(F-2.3119112141927083
F-3.217481231689453
tp2470
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p2471
(F-2.380116688121449
F-3.2676151275634764
tp2472
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2473
(F-2.0327966624292833
F-3.2096092224121096
tp2474
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2475
(F-2.0791168212890625
F-3.2190418243408203
tp2476
sS'c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p2477
(F-2.329072805551382
F-3.2468032836914062
tp2478
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2479
(F-2.6810530650464792
F-3.235546112060547
tp2480
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2481
(F-2.885764170501192
F-3.2046703338623046
tp2482
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2483
(F-1.6735265588247648
F-3.182796096801758
tp2484
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2485
(F-2.672256697469683
F-3.224073028564453
tp2486
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2487
(F-2.644907113008721
F-3.215388870239258
tp2488
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2489
(F-2.393918785682091
F-3.2335060119628904
tp2490
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2491
(F-2.5951416015625
F-3.1866971969604494
tp2492
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2493
(F-2.623024408071319
F-3.220843505859375
tp2494
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2495
(F-2.625538951945755
F-3.19313907623291
tp2496
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2497
(F-2.6030094749049137
F-3.1953107833862306
tp2498
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2499
(F-2.5753910187752016
F-3.2052555084228516
tp2500
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2501
(F-2.7144191966337314
F-3.179545593261719
tp2502
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2503
(F-2.5300248798571134
F-3.2217243194580076
tp2504
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2505
(F-2.8506583630199165
F-3.2018218994140626
tp2506
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p2507
(F-0.9071902361783114
F-3.213201904296875
tp2508
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2509
(F-2.365387118592554
F-3.210174560546875
tp2510
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2511
(F-2.583273902676459
F-3.1895444869995115
tp2512
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2513
(F-2.519589378720238
F-3.1917207717895506
tp2514
sS'obj = obj[:]'
p2515
(F-3.279006004333496
F-3.308545684814453
tp2516
sS'for y in L:\n    pass'
p2517
(F-1.6916748393665662
F-3.1482479095458986
tp2518
sS"print 'list slicing [:]:', (time() - t)\nt = time()"
p2519
(F-3.558274163140191
F-3.2141300201416017
tp2520
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2521
(F-2.509274266347164
F-3.2259178161621094
tp2522
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2523
(F-2.662124864982836
F-3.181107521057129
tp2524
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2525
(F-2.297329173368566
F-3.198384094238281
tp2526
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2527
(F-2.5794722224693905
F-3.2211971282958984
tp2528
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2529
(F-1.6065668626265093
F-3.1894599914550783
tp2530
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2531
(F-2.9328860812717013
F-3.258448028564453
tp2532
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2533
(F-2.5453385416666667
F-3.221272277832031
tp2534
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2535
(F-2.3285255432128906
F-3.234503173828125
tp2536
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2537
(F-2.765509571748621
F-3.1932701110839843
tp2538
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2539
(F-2.7608357251175053
F-3.260769271850586
tp2540
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2541
(F-2.5009622012867645
F-3.209501266479492
tp2542
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2543
(F-2.584083446557971
F-3.2130298614501953
tp2544
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2545
(F-2.64790898219795
F-3.219827651977539
tp2546
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2547
(F-2.657957367549669
F-3.2034255981445314
tp2548
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time"
p2549
(F-3.226182120186942
F-3.21536865234375
tp2550
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2551
(F-2.474406595762611
F-3.2362911224365236
tp2552
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2553
(F-2.6710317642962345
F-3.2011924743652345
tp2554
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2555
(F-2.4816743204416323
F-3.209645462036133
tp2556
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2557
(F-2.690582275390625
F-3.2125923156738283
tp2558
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2559
(F-2.5829493596003608
F-3.219202423095703
tp2560
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2561
(F-2.420309029373468
F-3.214145278930664
tp2562
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2563
(F-2.524532542509191
F-3.2175537109375
tp2564
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2565
(F-2.569659423828125
F-3.216318893432617
tp2566
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2567
(F-2.5171911820121435
F-3.225757598876953
tp2568
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2569
(F-2.047102636220504
F-3.2327136993408203
tp2570
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2571
(F-1.5363722664969308
F-3.196152687072754
tp2572
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2573
(F-2.5500767594676907
F-3.2160499572753904
tp2574
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2575
(F-2.532606378797407
F-3.207901382446289
tp2576
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2577
(F-2.514149639423077
F-3.2073135375976562
tp2578
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2579
(F-2.646685564959491
F-3.1965784072875976
tp2580
sS"foo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2581
(F-2.3577216466267905
F-3.2449672698974608
tp2582
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2583
(F-2.674824826003331
F-3.2119068145751952
tp2584
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2585
(F-2.659420625663098
F-3.208879089355469
tp2586
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p2587
(F-0.9205805097307478
F-3.2283370971679686
tp2588
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2589
(F-2.5933848789760043
F-3.205276107788086
tp2590
sS"a.append('baz')"
p2591
(F-1.7629549503326416
F-3.1925052642822265
tp2592
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2593
(F-2.561169786851889
F-3.1878129959106447
tp2594
sS'if (type(obj[x]) in dignore):\n    continue'
p2595
(F-2.5798384013928866
F-3.2223316192626954
tp2596
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2597
(F-2.5244234525240383
F-3.2044692993164063
tp2598
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2599
(F-2.7058139038085938
F-3.1897354125976562
tp2600
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p2601
(F-2.8451746622721354
F-3.267435836791992
tp2602
sS"print 'list(L):', (time() - t)\nt = time()"
p2603
(F-3.558274163140191
F-3.2141300201416017
tp2604
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2605
(F-2.6487662575461646
F-3.311664581298828
tp2606
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2607
(F-2.5640031403186274
F-3.19748477935791
tp2608
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2609
(F-2.744416872660319
F-3.210546112060547
tp2610
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p2611
(F-2.7843455561885126
F-3.1793846130371093
tp2612
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2613
(F-2.5431069083835767
F-3.280963897705078
tp2614
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2615
(F-2.9840908474392362
F-3.1862104415893553
tp2616
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2617
(F-2.6071565900530134
F-3.2089500427246094
tp2618
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2619
(F-2.446115513040562
F-3.2406280517578123
tp2620
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2621
(F-2.6011472929508312
F-3.224233627319336
tp2622
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2623
(F-2.6688275855132257
F-3.20736083984375
tp2624
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2625
(F-2.656028705867913
F-3.1892940521240236
tp2626
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2627
(F-2.513653353987069
F-3.210894012451172
tp2628
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2629
(F-2.5578483367061997
F-3.2035411834716796
tp2630
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2631
(F-2.5644469118403816
F-3.2029624938964845
tp2632
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2633
(F-2.6290501662290815
F-3.1924015045166017
tp2634
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2635
(F-2.5196630859375
F-3.212087631225586
tp2636
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2637
(F-2.4527273632231212
F-3.236119842529297
tp2638
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2639
(F-2.5828065660264756
F-3.2180507659912108
tp2640
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p2641
(F-3.339381844656808
F-3.1906644821166994
tp2642
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2643
(F-2.638524022595636
F-3.2146987915039062
tp2644
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2645
(F-2.469997308193109
F-3.237337112426758
tp2646
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2647
(F-2.671352111187178
F-3.1902187347412108
tp2648
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2649
(F-2.6629953513857467
F-3.2298229217529295
tp2650
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p2651
(F-2.434846978438528
F-3.2414974212646483
tp2652
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2653
(F-2.6742522063078704
F-3.188068389892578
tp2654
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2655
(F-2.46666874445922
F-3.229012298583984
tp2656
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2657
(F-2.460356692050366
F-3.2292800903320313
tp2658
sS'def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2659
(F-1.8071666293674045
F-3.249461364746094
tp2660
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2661
(F-2.6260911680811603
F-3.208993148803711
tp2662
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2663
(F-2.5302182937680984
F-3.2021240234375
tp2664
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p2665
(F-2.6399388994489397
F-3.1860836029052733
tp2666
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2667
(F-2.4968346988453582
F-3.2101478576660156
tp2668
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2669
(F-2.4539680270200277
F-3.222458267211914
tp2670
sS't = time()\nfor i in xrange(num_times):\n    pass'
p2671
(F-2.182938662442294
F-3.176471138000488
tp2672
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2673
(F-1.5602318092628762
F-3.243367004394531
tp2674
sS'continue'
p2675
(F-5.638313929239909
F-3.4156772613525392
tp2676
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2677
(F-2.430182869203629
F-3.2202522277832033
tp2678
sS'Copy(L)'
p2679
(F-1.6081485748291016
F-3.2384521484375
tp2680
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2681
(F-2.634160208194814
F-3.198393630981445
tp2682
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2683
(F-2.562540846604567
F-3.2209678649902345
tp2684
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2685
(F-2.371827891175176
F-3.2247898101806642
tp2686
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2687
(F-2.451885354929957
F-3.2294776916503904
tp2688
sS"if (__name__ == '__main__'):\n    import copy"
p2689
(F-2.6099438667297363
F-3.1863353729248045
tp2690
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2691
(F-2.3952719679156553
F-3.2202205657958984
tp2692
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2693
(F-2.4958552003816794
F-3.2124176025390625
tp2694
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2695
(F-2.55576123289801
F-3.213405990600586
tp2696
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2697
(F-2.65123291015625
F-3.2045127868652346
tp2698
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2699
(F-2.580216780952785
F-3.212899017333984
tp2700
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2701
(F-2.5478586315435203
F-3.2115463256835937
tp2702
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2703
(F-2.6909733986367983
F-3.205363082885742
tp2704
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p2705
(F-2.2929409572056363
F-3.222605514526367
tp2706
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2707
(F-2.573227351262019
F-3.1904706954956055
tp2708
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2709
(F-2.432525108600485
F-3.209168243408203
tp2710
sS'obj = list(obj)'
p2711
(F-2.524665594100952
F-3.2701171875
tp2712
sS'for i in xrange(num_times):\n    list(L)'
p2713
(F-1.9798427381013568
F-3.2346263885498048
tp2714
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2715
(F-2.527043104171753
F-3.2457290649414063
tp2716
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2717
(F-2.5617888077445654
F-3.215087127685547
tp2718
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2719
(F-2.6730438732710042
F-3.2081844329833986
tp2720
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2721
(F-2.5327991303943453
F-3.207637405395508
tp2722
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2723
(F-2.455741188742898
F-3.341516876220703
tp2724
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2725
(F-2.5360524011036705
F-3.2070777893066404
tp2726
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2727
(F-2.545557657877604
F-3.2163848876953125
tp2728
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2729
(F-2.441653297061012
F-3.390822982788086
tp2730
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2731
(F-2.583428034087276
F-3.2151702880859374
tp2732
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2733
(F-2.492552635428139
F-3.2103858947753907
tp2734
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2735
(F-2.5426356649806356
F-3.19445686340332
tp2736
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2737
(F-2.540655058932442
F-3.190089797973633
tp2738
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2739
(F-2.5807524745904127
F-3.218875503540039
tp2740
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2741
(F-2.571773052215576
F-3.235363006591797
tp2742
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2743
(F-2.4844945271809897
F-3.3739322662353515
tp2744
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2745
(F-3.1664902259563577
F-3.2484882354736326
tp2746
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2747
(F-2.6321280343191966
F-3.213975524902344
tp2748
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2749
(F-2.5955400277447227
F-3.208877944946289
tp2750
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2751
(F-2.4217681884765625
F-3.240287017822266
tp2752
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2753
(F-2.5231739795991106
F-3.2131011962890623
tp2754
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2755
(F-2.6894489044838763
F-3.3483810424804688
tp2756
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2757
(F-2.432892371868265
F-3.2183692932128904
tp2758
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2759
(F-2.604334332191781
F-3.2134258270263674
tp2760
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2761
(F-2.548014575650233
F-3.209710693359375
tp2762
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2763
(F-2.502464076450893
F-3.2214286804199217
tp2764
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p2765
(F-2.3026527404785155
F-3.336945343017578
tp2766
sS"print 'list extend:', (time() - t)\nt = time()"
p2767
(F-3.5582737392849393
F-3.2141300201416017
tp2768
sS"a.extend(L)\nprint 'list extend:', (time() - t)"
p2769
(F-2.877687353836863
F-3.1736623764038088
tp2770
sS'new_list = copy.deepcopy(old_list)'
p2771
(F-2.0465292249407088
F-3.245921325683594
tp2772
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2773
(F-2.680085905305632
F-3.183261489868164
tp2774
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2775
(F-2.730152130126953
F-3.224448013305664
tp2776
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2777
(F-2.5293933002888656
F-3.207476043701172
tp2778
sS"print 'generator expression extend:', (time() - t)"
p2779
(F-3.126575469970703
F-3.213360595703125
tp2780
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2781
(F-2.536554469293727
F-3.2077987670898436
tp2782
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2783
(F-2.7256237692084193
F-3.1917911529541017
tp2784
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2785
(F-2.51098099674087
F-3.224333953857422
tp2786
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2787
(F-2.4484444895098285
F-3.248794937133789
tp2788
sS'return str(self.val)'
p2789
(F-2.109898461235894
F-3.2314407348632814
tp2790
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2791
(F-2.334517845740685
F-3.2739654541015626
tp2792
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2793
(F-2.5120864868164063
F-3.205953598022461
tp2794
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2795
(F-2.981028747558594
F-3.195459747314453
tp2796
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2797
(F-2.672113156786152
F-3.208292770385742
tp2798
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2799
(F-2.4741069057531524
F-3.2188880920410154
tp2800
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2801
(F-2.5626339561060854
F-3.216934585571289
tp2802
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2803
(F-2.319666775790128
F-3.2211383819580077
tp2804
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2805
(F-2.5318909509571883
F-3.2054325103759767
tp2806
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2807
(F-2.428014967176649
F-3.1855756759643556
tp2808
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2809
(F-2.5191925200656873
F-3.207904052734375
tp2810
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2811
(F-2.887733320756392
F-3.199684715270996
tp2812
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2813
(F-2.5859219477726865
F-3.2106918334960937
tp2814
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2815
(F-2.858588205256932
F-3.3108055114746096
tp2816
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2817
(F-2.8857267553156074
F-3.1857505798339845
tp2818
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2819
(F-2.636663786403796
F-3.2139854431152344
tp2820
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2821
(F-2.6840019851434427
F-3.2067684173583983
tp2822
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2823
(F-2.42977294921875
F-3.319893646240234
tp2824
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2825
(F-2.638688446373068
F-3.208268737792969
tp2826
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2827
(F-2.662124864982836
F-3.181107521057129
tp2828
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2829
(F-2.577305056014151
F-3.2075984954833983
tp2830
sS'foo.val = 5'
p2831
(F-2.8802157810756137
F-3.2598030090332033
tp2832
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2833
(F-2.6115833629261362
F-3.2120399475097656
tp2834
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2835
(F-2.7026570638020835
F-3.1861454010009767
tp2836
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2837
(F-2.517078045132435
F-3.2250667572021485
tp2838
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2839
(F-2.5072013346354165
F-3.2196418762207033
tp2840
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2841
(F-1.7814155910326086
F-3.1785343170166014
tp2842
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2843
(F-2.4940265712453358
F-3.2051010131835938
tp2844
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2845
(F-2.6612642728365383
F-3.1897214889526366
tp2846
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2847
(F-2.5852344804427947
F-3.2122264862060548
tp2848
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2849
(F-2.4426228841145834
F-3.231256866455078
tp2850
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2851
(F-2.410367140129431
F-3.2333839416503904
tp2852
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2853
(F-2.591639592097356
F-3.208782196044922
tp2854
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2855
(F-2.5597092102621204
F-3.223388671875
tp2856
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2857
(F-2.7088356018066406
F-3.1838638305664064
tp2858
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2859
(F-2.700898114372702
F-3.2051727294921877
tp2860
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2861
(F-2.4928269311395614
F-3.2143630981445312
tp2862
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2863
(F-2.5989533523033406
F-3.1999481201171873
tp2864
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2865
(F-2.4532204561455306
F-3.2117851257324217
tp2866
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2867
(F-2.574049886067708
F-3.188210678100586
tp2868
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2869
(F-2.5418398003829155
F-3.2259262084960936
tp2870
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2871
(F-2.5741163741710573
F-3.2017078399658203
tp2872
sS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p2873
(F-2.257097053527832
F-3.2364444732666016
tp2874
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2875
(F-2.516654433718153
F-3.2229755401611326
tp2876
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2877
(F-2.631375789642334
F-3.2256790161132813
tp2878
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2879
(F-2.5273953951322117
F-3.2051227569580076
tp2880
sS"for i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2881
(F-2.6354488993799965
F-3.2350833892822264
tp2882
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2883
(F-2.6108865940824466
F-3.2023204803466796
tp2884
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2885
(F-2.7514307195490058
F-3.2129154205322266
tp2886
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2887
(F-2.635505284245306
F-3.2225677490234377
tp2888
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2889
(F-2.4601752758026123
F-3.2169803619384765
tp2890
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2891
(F-2.6568452380952383
F-3.19445858001709
tp2892
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2893
(F-2.3181293766673017
F-3.2210739135742186
tp2894
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2895
(F-2.7336831994958826
F-3.2052207946777345
tp2896
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2897
(F-2.606471587724215
F-3.2019832611083983
tp2898
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2899
(F-2.388869436163651
F-3.176295852661133
tp2900
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2901
(F-2.5787756522876792
F-3.1901477813720702
tp2902
sS'for i in xrange(num_times):\n    Copy(L)'
p2903
(F-1.7005356236508018
F-3.24798469543457
tp2904
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2905
(F-2.4383041063944497
F-3.2022823333740233
tp2906
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2907
(F-2.601678256330819
F-3.188564491271973
tp2908
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2909
(F-2.749641535832332
F-3.2044933319091795
tp2910
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2911
(F-2.281127505832248
F-3.200043487548828
tp2912
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2913
(F-2.6867699256310096
F-3.2136951446533204
tp2914
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p2915
(F-2.912555316547016
F-3.184678649902344
tp2916
sS"print 'list expression(L):', (time() - t)"
p2917
(F-3.126575469970703
F-3.213360595703125
tp2918
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2919
(F-2.6083158167397102
F-3.1881980895996094
tp2920
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2921
(F-3.0290562947591146
F-3.2161510467529295
tp2922
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2923
(F-2.790531596199411
F-3.3106075286865235
tp2924
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2925
(F-1.2439769276401453
F-3.204229736328125
tp2926
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2927
(F-2.665960248732409
F-3.2259841918945313
tp2928
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2929
(F-2.652936168552674
F-3.2018463134765627
tp2930
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2931
(F-2.5576610296544895
F-3.2103031158447264
tp2932
sS'def __repr__(self):\n    return str(self.val)'
p2933
(F-1.3655067443847657
F-3.270542526245117
tp2934
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2935
(F-2.5366507576895763
F-3.213156509399414
tp2936
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2937
(F-2.551159198467548
F-3.2258445739746096
tp2938
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2939
(F-2.579060017561712
F-3.2159049987792967
tp2940
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2941
(F-2.416832216324345
F-3.361708068847656
tp2942
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2943
(F-2.535027879284274
F-3.2069812774658204
tp2944
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2945
(F-2.5442192263719514
F-3.2145851135253904
tp2946
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2947
(F-2.606534156573595
F-3.221774673461914
tp2948
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p2949
(F-2.47658634185791
F-3.226285934448242
tp2950
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2951
(F-3.1909087558962264
F-3.1851518630981444
tp2952
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2953
(F-2.3741576631190413
F-3.213540267944336
tp2954
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time"
p2955
(F-3.7952378590901694
F-3.215277099609375
tp2956
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p2957
(F-2.462377157556005
F-3.354070281982422
tp2958
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2959
(F-2.579339599609375
F-3.204573059082031
tp2960
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2961
(F-1.6814757671552836
F-3.186610984802246
tp2962
sS'for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p2963
(F-2.0587091064453125
F-3.3590713500976563
tp2964
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p2965
(F-0.8889576721191407
F-3.214649963378906
tp2966
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2967
(F-2.625998386116915
F-3.1903167724609376
tp2968
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2969
(F-2.430882649249341
F-3.1992818832397463
tp2970
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2971
(F-2.5330731893323133
F-3.1916860580444335
tp2972
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2973
(F-2.5651740677859807
F-3.199517822265625
tp2974
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2975
(F-2.5948950924090486
F-3.209775924682617
tp2976
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2977
(F-2.5732909611293246
F-3.2556522369384764
tp2978
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2979
(F-2.585211832015241
F-3.227754592895508
tp2980
sS'obj = obj.copy()'
p2981
(F-2.366242938571506
F-3.292408752441406
tp2982
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2983
(F-2.6561557769775392
F-3.1788002014160157
tp2984
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2985
(F-2.5648759905801435
F-3.2270320892333983
tp2986
sS"print 'list extend:', (time() - t)"
p2987
(F-3.126575469970703
F-3.213360595703125
tp2988
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2989
(F-2.8383192404722557
F-3.190449523925781
tp2990
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2991
(F-2.408614773220486
F-3.216878128051758
tp2992
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2993
(F-2.551530008422398
F-3.210189437866211
tp2994
sS'new_list = list(old_list)'
p2995
(F-1.8214124043782551
F-3.230547332763672
tp2996
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2997
(F-2.5729125386850846
F-3.200444793701172
tp2998
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2999
(F-2.5292634474327627
F-3.1915586471557615
tp3000
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3001
(F-2.0920831589471724
F-3.2324676513671875
tp3002
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p3003
(F-2.546032763867972
F-3.2214794158935547
tp3004
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3005
(F-2.471388334386489
F-3.206684875488281
tp3006
sS"a.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p3007
(F-2.173221218970514
F-3.2551292419433593
tp3008
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3009
(F-2.701056344168527
F-3.208393859863281
tp3010
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p3011
(F-1.7693695308655266
F-3.2112430572509765
tp3012
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3013
(F-2.5215024904573347
F-3.2267105102539064
tp3014
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3015
(F-2.6278994160313762
F-3.2236862182617188
tp3016
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p3017
(F-2.523616133065059
F-3.228010559082031
tp3018
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p3019
(F-2.380434195200602
F-3.2692604064941406
tp3020
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p3021
(F-2.4892377500180847
F-3.2278541564941405
tp3022
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3023
(F-1.697572267972506
F-3.186353302001953
tp3024
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3025
(F-2.6152351285204474
F-3.2081737518310547
tp3026
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p3027
(F-2.545319892990757
F-3.232535171508789
tp3028
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3029
(F-2.499780789227553
F-3.210846710205078
tp3030
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p3031
(F-2.633336385091146
F-3.2039630889892576
tp3032
sS"a.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p3033
(F-2.830120849609375
F-3.208725357055664
tp3034
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3035
(F-2.6118612436147837
F-3.198351287841797
tp3036
sS'is_tuple = False'
p3037
(F-3.430753435407366
F-3.2123157501220705
tp3038
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p3039
(F-2.5751872343175553
F-3.27550048828125
tp3040
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3041
(F-2.542970657348633
F-3.2205276489257812
tp3042
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3043
(F-2.7132194205506206
F-3.2134265899658203
tp3044
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint ('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e))"
p3045
(F-2.2642106606926715
F-3.275090789794922
tp3046
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3047
(F-2.1347631506017737
F-3.2409011840820314
tp3048
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3049
(F-2.402250453404018
F-3.2247550964355467
tp3050
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p3051
(F-2.7305550860543537
F-3.253126525878906
tp3052
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p3053
(F-2.503035458651456
F-3.4137420654296875
tp3054
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3055
(F-2.6844820889559657
F-3.1924503326416014
tp3056
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3057
(F-2.557866459399198
F-3.2124164581298826
tp3058
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p3059
(F-1.603851787860577
F-3.2287750244140625
tp3060
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3061
(F-2.5732649220716235
F-3.1968963623046873
tp3062
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3063
(F-1.6228701108461852
F-3.188623046875
tp3064
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3065
(F-2.50069778535995
F-3.2173931121826174
tp3066
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3067
(F-2.6167074420494947
F-3.187270736694336
tp3068
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p3069
(F-2.5653547320449563
F-3.2275718688964843
tp3070
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p3071
(F-2.5623180407313675
F-3.1907751083374025
tp3072
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p3073
(F-2.4969816289396367
F-3.204862594604492
tp3074
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3075
(F-2.57581030804178
F-3.2083198547363283
tp3076
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3077
(F-3.066899226262019
F-3.2047149658203127
tp3078
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p3079
(F-2.6606265208760247
F-3.221910858154297
tp3080
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3081
(F-2.61785057233214
F-3.210791015625
tp3082
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3083
(F-2.5152489877965327
F-3.205801010131836
tp3084
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3085
(F-2.5324145155262863
F-3.2149978637695313
tp3086
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p3087
(F-2.7554177783784413
F-3.1992916107177733
tp3088
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3089
(F-2.334254370795356
F-3.2248825073242187
tp3090
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3091
(F-2.517504116187349
F-3.2073150634765626
tp3092
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3093
(F-2.421664237976074
F-3.2855560302734377
tp3094
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3095
(F-2.4988910721009034
F-3.215126800537109
tp3096
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p3097
(F-2.5707344987273757
F-3.2190223693847657
tp3098
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p3099
(F-2.6792439243249726
F-3.2034378051757812
tp3100
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p3101
(F-2.581569126674107
F-3.1918966293334963
tp3102
ssI402504
(dp3103
S'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p3104
(F-3.843080520629883
F-2.138345891779119
tp3105
sS'(type(i) is float)'
p3106
(F-3.883392333984375
F-2.1195418617942114
tp3107
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3108
(F-4.310907102098652
F-2.1329174041748047
tp3109
sS'type(i)\n(type(i) is long)\ni = 123.456'
p3110
(F-4.6700804860968335
F-2.1478321769020776
tp3111
sS'(type(i) is int)\ni = 123456789L\ntype(i)'
p3112
(F-3.755289178145559
F-2.129078604958274
tp3113
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3114
(F-4.106096302379261
F-2.130427447232333
tp3115
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3116
(F-4.411809921264648
F-2.135234139182351
tp3117
sS"v = 'hi'"
p3118
(F-3.427454376220703
F-2.393678144975142
tp3119
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3120
(F-4.134778409390836
F-2.134105855768377
tp3121
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3122
(F-4.426022120884487
F-2.128382769497958
tp3123
sS'i = 123'
p3124
(F-2.988303565979004
F-2.263093601573597
tp3125
sS'v = 10\ntype(v)'
p3126
(F-3.4106658935546874
F-2.144324389371005
tp3127
sS'i = 123.456\ntype(i)'
p3128
(F-2.7987380981445313
F-2.1973391446200283
tp3129
sS'v = 100000000000000'
p3130
(F-3.3720706939697265
F-2.3179487748579546
tp3131
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p3132
(F-3.652383804321289
F-2.1418850638649682
tp3133
sS'i = 123\ntype(i)'
p3134
(F-2.7987380981445313
F-2.197339318015359
tp3135
sS'(type(i) is long)\ni = 123.456'
p3136
(F-4.765906742640904
F-2.1400156888094815
tp3137
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3138
(F-4.283213408096977
F-2.1511384790593926
tp3139
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L'
p3140
(F-3.990118275518003
F-2.1486552845348013
tp3141
sS'v = 100000000000000\ntype(v)'
p3142
(F-2.8631690979003905
F-2.2203634435480293
tp3143
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3144
(F-4.175419132883956
F-2.1399898529052734
tp3145
sS'(type(i) is int)\ni = 123456789L'
p3146
(F-4.3316386086600165
F-2.1324277357621626
tp3147
sS'(type(i) is long)\ni = 123.456\ntype(i)'
p3148
(F-4.062349018297698
F-2.1323294206099077
tp3149
sS'type(i)\n(type(i) is long)'
p3150
(F-4.492815144856771
F-2.134259484030984
tp3151
sS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3152
(F-4.39693612763376
F-2.13416879827326
tp3153
sS'type(i)\n(type(i) is int)'
p3154
(F-3.979178873697917
F-2.128591017289595
tp3155
sS'i = 123456789L\ntype(i)\n(type(i) is long)'
p3156
(F-4.240350823653372
F-2.1403076865456323
tp3157
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3158
(F-4.120894659133184
F-2.136367451060902
tp3159
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3160
(F-4.08667363347234
F-2.1305972012606533
tp3161
sS'i = 123456789L\ntype(i)'
p3162
(F-2.7987380981445313
F-2.197339318015359
tp3163
sS'type(v)'
p3164
(F-2.527856985727946
F-2.221861232410778
tp3165
sS'i = 123.456'
p3166
(F-2.988303565979004
F-2.263093601573597
tp3167
sS'print type(variable_name)'
p3168
(F-3.5360921223958335
F-2.087196176702326
tp3169
sS'v = (-10)\ntype(v)'
p3170
(F-3.5410118103027344
F-2.1593780517578125
tp3171
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3172
(F-4.376776030569365
F-2.1341771212491123
tp3173
sS'type(i)\n(type(i) is int)\ni = 123456789L'
p3174
(F-4.316425524259868
F-2.143029646439986
tp3175
sS'type(i)'
p3176
(F-2.5071476300557456
F-2.1805286407470703
tp3177
sS'i = 123.456\ntype(i)\n(type(i) is float)'
p3178
(F-3.959706758197985
F-2.137475447221236
tp3179
sS'v = (-10)'
p3180
(F-3.957332134246826
F-2.169430125843395
tp3181
sS'(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3182
(F-4.443003245762417
F-2.128610784357244
tp3183
sS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3184
(F-4.11433760325114
F-2.140304218639027
tp3185
sS'type(i)\n(type(i) is float)'
p3186
(F-4.102220662434896
F-2.131016817959872
tp3187
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3188
(F-4.412132469383446
F-2.1404602744362573
tp3189
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3190
(F-3.879140853881836
F-2.1417980194091797
tp3191
sS'(type(i) is int)'
p3192
(F-3.6575847625732423
F-2.114988847212358
tp3193
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3194
(F-4.146790375580659
F-2.1323152021928267
tp3195
sS'(type(i) is long)'
p3196
(F-4.230458068847656
F-2.1244451349431817
tp3197
sS'v = 10'
p3198
(F-4.880004119873047
F-2.1524184833873403
tp3199
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3200
(F-4.333201532778532
F-2.1284666928378018
tp3201
sS'i = 123456789L'
p3202
(F-2.988303565979004
F-2.263093601573597
tp3203
sS'i = 123\ntype(i)\n(type(i) is int)'
p3204
(F-3.8616722508480676
F-2.136326876553622
tp3205
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3206
(F-3.9335479736328125
F-2.135562203147195
tp3207
sS"v = 'hi'\ntype(v)"
p3208
(F-2.7472854614257813
F-2.2921903783624824
tp3209
ssI275018
(dp3210
S's.strip()'
p3211
(F-2.0088018689836775
F-2.3425609043666293
tp3212
sS's.rstrip()'
p3213
(F-2.0682525634765625
F-2.433877944946289
tp3214
sS"'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3215
(F-2.28983211517334
F-2.426765169416155
tp3216
sS"s = ' \\n  abc   def   '"
p3217
(F-3.3777008056640625
F-2.401491437639509
tp3218
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'\ntext.splitlines()"
p3219
(F-2.4545985135165127
F-2.3901893070765903
tp3220
sS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p3221
(F-3.075313914905895
F-2.410017558506557
tp3222
sS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3223
(F-2.888744099934896
F-2.413801738194057
tp3224
sS's.strip()\ns.rstrip()\ns.lstrip()'
p3225
(F-1.9856577421489514
F-2.358377456665039
tp3226
sS"s = ' \\n  abc   def   '\ns.strip()"
p3227
(F-1.9487575184215198
F-2.3250132969447543
tp3228
sS"'Hello\\n\\n\\n'.rstrip('\\n')"
p3229
(F-2.28983211517334
F-2.426765169416155
tp3230
sS's.rstrip()\ns.lstrip()'
p3231
(F-2.033494362464318
F-2.4237207685198103
tp3232
sS's.strip()\ns.rstrip()'
p3233
(F-2.0060467353233924
F-2.350755419049944
tp3234
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'"
p3235
(F-3.7315441131591798
F-2.438190187726702
tp3236
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()"
p3237
(F-1.7796187681310318
F-2.328741891043527
tp3238
sS'text.splitlines()'
p3239
(F-2.284626143319266
F-2.4389659336635043
tp3240
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()\ns.lstrip()"
p3241
(F-1.7140814739724863
F-2.3366012573242188
tp3242
sS's.lstrip()'
p3243
(F-2.0682525634765625
F-2.433877944946289
tp3244
sS"'test string\\n'.rstrip()"
p3245
(F-2.599072047642299
F-2.4463509150913785
tp3246
sS"'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p3247
(F-2.888744099934896
F-2.413801738194057
tp3248
sS"'Mac EOL\\r'.rstrip('\\r\\n')"
p3249
(F-2.28983211517334
F-2.426765169416155
tp3250
sS"'test string \\n\\n'.rstrip('\\n')"
p3251
(F-2.28983211517334
F-2.426765169416155
tp3252
sS"'Unix EOL\\n'.rstrip('\\r\\n')"
p3253
(F-2.28983211517334
F-2.426765169416155
tp3254
ssI276052
(dp3255
S'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3256
(F-2.1709636916762673
F-2.5768470764160156
tp3257
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3258
(F-2.3981083768234406
F-2.8086568392240086
tp3259
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3260
(F-2.3076416015625
F-2.8213377732496996
tp3261
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3262
(F-2.889585996928968
F-2.8399828397310696
tp3263
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3264
(F-2.0006154215754792
F-2.761598440317007
tp3265
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3266
(F-2.8984838312322445
F-2.8555321326622596
tp3267
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3268
(F-2.8983061137952304
F-2.7764613811786356
tp3269
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3270
(F-3.0037789344787598
F-2.8681954603928785
tp3271
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3272
(F-2.6488745977794528
F-2.8492279052734375
tp3273
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3274
(F-2.5184451219512196
F-2.6427665123572717
tp3275
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3276
(F-2.4814667821529524
F-2.706741919884315
tp3277
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3278
(F-2.640339479608051
F-2.7394784780649037
tp3279
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3280
(F-2.7406522310697117
F-2.833648681640625
tp3281
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p3282
(F-1.9463301265940947
F-2.7907268817608175
tp3283
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3284
(F-2.808964655949519
F-2.7660003075232873
tp3285
sS'return proc_results_list\n\ndef get_sys_stats():\n    pass'
p3286
(F-2.6420168669327446
F-2.636249835674579
tp3287
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3288
(F-2.8127801829370958
F-2.865635798527644
tp3289
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3290
(F-2.893220068703235
F-2.850742926964393
tp3291
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3292
(F-2.5433162342418325
F-2.5733085045447717
tp3293
sS'import psutil'
p3294
(F-3.666597604751587
F-2.5794557424692006
tp3295
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3296
(F-2.4532197651110197
F-2.8130710308368387
tp3297
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p3298
(F-1.1284823073554284
F-2.5202889075646033
tp3299
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p3300
(F-3.363463009105009
F-2.670474419227013
tp3301
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3302
(F-1.582438327955163
F-2.6633019080528846
tp3303
sS"eval_str = ('objItem.%s' % attribute)"
p3304
(F-4.992645957253196
F-2.9013489943284254
tp3305
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3306
(F-2.978241149536864
F-2.86365714439979
tp3307
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3308
(F-3.0957961082458496
F-2.896564483642578
tp3309
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p3310
(F-2.726426464016155
F-2.714633061335637
tp3311
sS'import psutil\nprint psutil.cpu_percent()'
p3312
(F-2.2210452740009012
F-2.540953416090745
tp3313
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3314
(F-2.159220984919154
F-2.8937879709097056
tp3315
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3316
(F-2.50074672981964
F-2.7689696091871996
tp3317
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3318
(F-2.7057952880859375
F-2.836851560152494
tp3319
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3320
(F-2.6524253346812188
F-2.786178001990685
tp3321
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3322
(F-2.218935172121896
F-2.8267734234149637
tp3323
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3324
(F-2.2215008574407458
F-2.8526866619403544
tp3325
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3326
(F-2.9457934934701493
F-2.834353520320012
tp3327
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p3328
(F-3.0402762673117896
F-2.635029132549579
tp3329
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3330
(F-2.6545423087427173
F-2.851531982421875
tp3331
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p3332
(F-2.5898361206054688
F-2.8236336341271033
tp3333
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3334
(F-2.633646230228612
F-2.7971297044020433
tp3335
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3336
(F-2.9782129404496174
F-2.7831297654371996
tp3337
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3338
(F-2.6227675673043627
F-2.7823756291316104
tp3339
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3340
(F-2.985311289302638
F-2.9020168597881613
tp3341
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3342
(F-2.814099616810755
F-2.6680368276742787
tp3343
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3344
(F-1.962308326863354
F-2.5891747107872596
tp3345
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3346
(F-2.8992542811802458
F-2.8110600985013523
tp3347
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3348
(F-1.994789321415706
F-2.617642035851112
tp3349
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3350
(F-2.97121322202874
F-2.7956158564640927
tp3351
sS'colItems = objSWbemServices.ExecQuery(query_str)'
p3352
(F-2.7187633514404297
F-2.857628162090595
tp3353
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p3354
(F-2.8121495650986494
F-2.857436253474309
tp3355
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3356
(F-2.638080323295754
F-2.809766622690054
tp3357
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3358
(F-1.5396231651306151
F-2.578026111309345
tp3359
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3360
(F-2.2249781709558825
F-2.6668651287372294
tp3361
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p3362
(F-1.9906048244900174
F-2.6287307739257812
tp3363
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3364
(F-2.247463680048871
F-2.773841564471905
tp3365
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3366
(F-3.0838556534204726
F-2.807035886324369
tp3367
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3368
(F-2.8746969185623468
F-2.9366475618802586
tp3369
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3370
(F-3.08592195864077
F-2.8910322922926683
tp3371
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3372
(F-3.736967233511118
F-3.044619927039513
tp3373
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3374
(F-2.560285128079928
F-2.8428497314453125
tp3375
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3376
(F-2.255382063202045
F-2.776368948129507
tp3377
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3378
(F-2.3471322295330324
F-2.84473624596229
tp3379
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list"
p3380
(F-2.8094080607096354
F-2.8772254356971154
tp3381
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3382
(F-2.67813337341813
F-2.802798344538762
tp3383
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3384
(F-2.666900634765625
F-2.697992178109976
tp3385
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p3386
(F-0.8109788440522694
F-2.8592086205115685
tp3387
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3388
(F-2.489361278005929
F-2.81913816011869
tp3389
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3390
(F-3.0874430338541665
F-2.867957775409405
tp3391
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3392
(F-2.392367362976074
F-2.7429439838115988
tp3393
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3394
(F-2.718449910481771
F-2.832471407376803
tp3395
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3396
(F-2.0664415224415724
F-2.6011898334209738
tp3397
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3398
(F-2.027726199648796
F-2.7802247267503004
tp3399
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3400
(F-2.862720404730903
F-2.6798873314490685
tp3401
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3402
(F-2.330969867509665
F-2.695169595571665
tp3403
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3404
(F-2.0730221218532985
F-2.745269775390625
tp3405
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3406
(F-2.1276295698808703
F-2.840362842266376
tp3407
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3408
(F-2.5025905825277563
F-2.7197641225961537
tp3409
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p3410
(F-2.6264729977590866
F-2.7963292048527646
tp3411
sS'import pythoncom\nimport pywintypes'
p3412
(F-2.7376251220703125
F-2.561887887807993
tp3413
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3414
(F-2.618272160909262
F-2.723866976224459
tp3415
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3416
(F-1.6080322265625
F-2.5903458228478065
tp3417
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3418
(F-3.1973209926060266
F-2.631180396446815
tp3419
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3420
(F-2.807437106295749
F-2.8950465275691104
tp3421
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3422
(F-2.6407767704554965
F-2.8077339759239783
tp3423
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3424
(F-2.691153988273129
F-2.8483616755558896
tp3425
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3426
(F-3.067303419113159
F-2.8413540766789365
tp3427
sS'import os\nimport psutil\npid = os.getpid()'
p3428
(F-1.8889710744222006
F-2.6315169701209435
tp3429
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3430
(F-2.4675020811987705
F-2.809167715219351
tp3431
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3432
(F-1.5159295399983723
F-2.72238775400015
tp3433
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3434
(F-2.517060798080788
F-2.6506423950195312
tp3435
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3436
(F-2.8288505927666083
F-2.8093784038837137
tp3437
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3438
(F-2.4710601459849966
F-2.8634975139911356
tp3439
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3440
(F-3.111675109863281
F-2.836695744441106
tp3441
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3442
(F-1.9229207224660105
F-2.7166081942044773
tp3443
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3444
(F-2.626757580301036
F-2.850096482496995
tp3445
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3446
(F-2.3379927201704547
F-2.7573887751652646
tp3447
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3448
(F-1.8322530893179088
F-3.0325657771183896
tp3449
sS'def winmem():\n    x = MEMORYSTATUS()'
p3450
(F-1.5518441518147787
F-2.6714674142690806
tp3451
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3452
(F-3.020186714504076
F-2.970178457406851
tp3453
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3454
(F-2.4987057460827775
F-2.8343294583834133
tp3455
sS'break'
p3456
(F-3.1522143681844077
F-2.6250715989332933
tp3457
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3458
(F-2.980563181751179
F-2.7211541395920973
tp3459
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p3460
(F-2.4357310208407315
F-2.6483568044809194
tp3461
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3462
(F-3.0996129132699277
F-2.813672579251803
tp3463
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3464
(F-2.3393609523773193
F-2.896121391883263
tp3465
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3466
(F-2.0542230475438785
F-2.64558351956881
tp3467
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3468
(F-2.6298958753747694
F-2.800066140981821
tp3469
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3470
(F-2.9879696494654606
F-2.7847879849947414
tp3471
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3472
(F-2.4706146800657347
F-2.7612424997182994
tp3473
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            eval_str = ('objItem.%s' % attribute)"
p3474
(F-3.5123182727444555
F-2.755228776198167
tp3475
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3476
(F-2.2547007896947755
F-2.786725264329177
tp3477
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3478
(F-2.9128047755507174
F-2.795135204608624
tp3479
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3480
(F-2.8769068564138105
F-2.8405682490422177
tp3481
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3482
(F-3.0073876288150534
F-2.799448453463041
tp3483
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3484
(F-3.1314299827398258
F-2.812146993783804
tp3485
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p3486
(F-2.4673118394336275
F-2.668935335599459
tp3487
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())'
p3488
(F-1.9418452580769856
F-2.5580825805664062
tp3489
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3490
(F-3.0545886004412615
F-2.805312230036809
tp3491
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3492
(F-3.0172873971542873
F-2.8308369563176083
tp3493
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3494
(F-2.0210840114265927
F-2.626397939828726
tp3495
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3496
(F-2.5941941765916376
F-2.7982007540189304
tp3497
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3498
(F-2.263096573329208
F-2.7769364577073317
tp3499
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3500
(F-2.9109002976190474
F-2.8619349553034854
tp3501
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p3502
(F-2.8446199186555634
F-2.84770994919997
tp3503
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3504
(F-2.2197426167709566
F-2.80465815617488
tp3505
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3506
(F-1.9787736189992804
F-2.8118564899151144
tp3507
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3508
(F-2.4779555059112277
F-2.818792783297025
tp3509
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3510
(F-2.985863370028409
F-2.834247295673077
tp3511
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3512
(F-2.516667416221217
F-2.8195794912484975
tp3513
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3514
(F-2.503150081327874
F-2.8728848970853367
tp3515
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3516
(F-2.82597900390625
F-2.905812483567458
tp3517
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3518
(F-1.181232380417158
F-2.5509185791015625
tp3519
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3520
(F-2.3876533280784047
F-2.759977487417368
tp3521
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3522
(F-3.026508116989993
F-2.8796395521897535
tp3523
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3524
(F-2.503609193136248
F-2.6525919987605167
tp3525
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3526
(F-2.6506494241718426
F-2.832561492919922
tp3527
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3528
(F-2.280016557885966
F-2.637022752028245
tp3529
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3530
(F-2.953318600201499
F-2.8236814645620494
tp3531
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3532
(F-2.524408428485577
F-2.842340322641226
tp3533
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3534
(F-2.3720095111949235
F-2.9063788193922777
tp3535
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p3536
(F-2.0316221864073425
F-2.816734607403095
tp3537
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3538
(F-2.648721412907268
F-2.8092730595515323
tp3539
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3540
(F-2.395020263671875
F-2.7724556556114783
tp3541
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3542
(F-1.9207030505668827
F-2.6011886596679688
tp3543
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3544
(F-1.9253553266495742
F-2.6142833416278544
tp3545
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3546
(F-2.9555888456456803
F-2.8500759418194113
tp3547
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3548
(F-2.1198412518168603
F-2.5834491436298075
tp3549
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3550
(F-3.196710076130612
F-2.8202664301945615
tp3551
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3552
(F-2.7858493511493387
F-2.9088695232684794
tp3553
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3554
(F-2.063065418645964
F-2.612725771390475
tp3555
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3556
(F-2.668430908203125
F-2.833865239070012
tp3557
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3558
(F-2.690011989480198
F-2.8047723036545973
tp3559
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3560
(F-1.962611148231908
F-2.5674825815054088
tp3561
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3562
(F-2.807331821374726
F-2.9266266456017127
tp3563
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3564
(F-2.421694220735027
F-2.8069933377779446
tp3565
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3566
(F-2.2537640150793377
F-2.712506807767428
tp3567
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3568
(F-1.1481932082978805
F-2.524624751164363
tp3569
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3570
(F-1.8466518785826553
F-2.5604738088754506
tp3571
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3572
(F-2.02946447688628
F-2.5871182955228367
tp3573
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3574
(F-1.8070406979077482
F-2.815791203425481
tp3575
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3576
(F-2.682877706073904
F-2.8346692598783054
tp3577
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3578
(F-2.6929995567721323
F-2.860857450045072
tp3579
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3580
(F-2.702544696514423
F-2.790321056659405
tp3581
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3582
(F-2.580239485757064
F-2.8156453646146336
tp3583
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3584
(F-2.631105606765257
F-2.81957039466271
tp3585
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p3586
(F-3.5719445364815847
F-3.1361958430363583
tp3587
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3588
(F-2.4498410001128157
F-2.749254666841947
tp3589
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p3590
(F-2.6778226579938615
F-2.6948280334472656
tp3591
sS'__revision__ = 3'
p3592
(F-2.3104400634765625
F-2.7305984497070312
tp3593
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3594
(F-2.6287860481106504
F-2.826032198392428
tp3595
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3596
(F-2.058810234069824
F-2.7020560044508715
tp3597
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p3598
(F-2.875745300852924
F-2.7564556415264425
tp3599
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3600
(F-2.003231430053711
F-2.6911380474384012
tp3601
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3602
(F-1.6187760009765626
F-2.559987581693209
tp3603
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3604
(F-2.450758463541667
F-2.6553118779109073
tp3605
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3606
(F-2.638881872196009
F-2.80005616408128
tp3607
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3608
(F-3.4192039294120593
F-2.86602049607497
tp3609
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3610
(F-2.7770678612493698
F-2.73842532818134
tp3611
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3612
(F-2.641559912723565
F-2.777303255521334
tp3613
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3614
(F-1.5538857919198494
F-2.5581638629619894
tp3615
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3616
(F-3.0183414660002055
F-2.8398622366098256
tp3617
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3618
(F-3.169234882701527
F-2.7802455608661356
tp3619
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3620
(F-2.7042093397695806
F-2.8150303180401144
tp3621
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3622
(F-2.3097183935752903
F-2.6201453575721154
tp3623
sS'import os'
p3624
(F-4.026505470275879
F-2.6359346829927883
tp3625
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3626
(F-2.2154407104774103
F-2.8269577026367188
tp3627
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p3628
(F-2.6120513389850486
F-2.723973200871394
tp3629
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p3630
(F-2.77838674405726
F-2.6896773118239183
tp3631
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3632
(F-2.6291697619844143
F-2.8107211773212137
tp3633
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3634
(F-2.1922564667780042
F-2.6181094829852762
tp3635
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()'
p3636
(F-1.5773813348067434
F-2.5613864018366885
tp3637
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3638
(F-2.873634847005208
F-2.7500152587890625
tp3639
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3640
(F-3.082344411689544
F-2.7947528545673075
tp3641
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list"
p3642
(F-2.867347898937407
F-3.004924774169922
tp3643
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3644
(F-3.032272806928202
F-2.738512479341947
tp3645
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3646
(F-2.9566265261041282
F-2.793204380915715
tp3647
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3648
(F-2.3020022053363896
F-2.8842122004582333
tp3649
sS'for counter_type in perf_object_list:\n    pass'
p3650
(F-2.932873445398667
F-2.909734872671274
tp3651
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3652
(F-2.247511138916016
F-2.85362302339994
tp3653
sS'def winmem():\n    pass'
p3654
(F-1.472010525790128
F-2.609465085543119
tp3655
sS'import datetime'
p3656
(F-5.846595764160156
F-2.686030461237981
tp3657
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3658
(F-1.877136819232315
F-2.6286629896897535
tp3659
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3660
(F-2.988848806797773
F-2.8438656146709738
tp3661
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3662
(F-2.2132394933490502
F-2.6161111684945912
tp3663
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3664
(F-2.708413733057229
F-2.8251712505634012
tp3665
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3666
(F-1.9263586587463783
F-2.7575445908766527
tp3667
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3668
(F-2.912115478515625
F-2.931438739483173
tp3669
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3670
(F-2.444965342919168
F-2.7591940072866588
tp3671
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3672
(F-3.8358479252568
F-2.9465161837064304
tp3673
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p3674
(F-3.3218225751604353
F-2.951795137845553
tp3675
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3676
(F-2.4798926811713677
F-2.658796163705679
tp3677
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3678
(F-2.5407465483966747
F-2.796156956599309
tp3679
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3680
(F-2.0729392782762766
F-2.634479522705078
tp3681
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3682
(F-2.6169363291475785
F-2.783373612623948
tp3683
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3684
(F-2.9496155911266144
F-2.791010929987981
tp3685
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3686
(F-3.049762432391827
F-3.0286639286921573
tp3687
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3688
(F-2.520457537051482
F-2.646578862116887
tp3689
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3690
(F-1.8135453315630352
F-2.812482393704928
tp3691
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3692
(F-2.624938830108306
F-2.846358372614934
tp3693
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3694
(F-2.6798746009981658
F-2.799759791447566
tp3695
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3696
(F-2.88224166067023
F-2.6767220130333533
tp3697
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3698
(F-2.5814822803844106
F-2.8963103661170373
tp3699
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3700
(F-2.3803639729817707
F-2.691576444185697
tp3701
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3702
(F-2.2412202309188527
F-2.7750396728515625
tp3703
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p3704
(F-2.33289256848787
F-2.5748546306903544
tp3705
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3706
(F-3.0063277534816577
F-2.831903017484225
tp3707
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3708
(F-2.0394543420152003
F-2.59283447265625
tp3709
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p3710
(F-2.457956324143234
F-2.762555929330679
tp3711
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3712
(F-2.2589604206165013
F-2.8057162945087137
tp3713
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3714
(F-3.500443696975708
F-2.706014193021334
tp3715
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3716
(F-2.4518662025188576
F-2.7709726186899037
tp3717
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3718
(F-3.0138693416819855
F-2.657342764047476
tp3719
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3720
(F-3.0338927845896024
F-2.853762993445763
tp3721
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3722
(F-2.649970470610119
F-2.7969468923715444
tp3723
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3724
(F-2.933664359298407
F-2.7922603900615988
tp3725
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3726
(F-2.8762264251708984
F-2.9183326134314904
tp3727
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3728
(F-2.119326443142361
F-2.805208059457632
tp3729
sS'pid = os.getpid()\npy = psutil.Process(pid)'
p3730
(F-2.093034108479818
F-2.630297440748948
tp3731
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3732
(F-2.5116051169002755
F-2.8368650583120494
tp3733
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3734
(F-2.6583748195482335
F-2.84364260160006
tp3735
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3736
(F-2.2091798372795246
F-2.9473052391639123
tp3737
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3738
(F-2.5358382994870103
F-2.801709688626803
tp3739
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3740
(F-2.9134878763338414
F-2.852635016808143
tp3741
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3742
(F-2.7194924425722946
F-2.822684361384465
tp3743
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3744
(F-2.346108353845605
F-2.8081321716308594
tp3745
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3746
(F-1.892428403401243
F-2.5799179077148438
tp3747
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3748
(F-2.537260734910581
F-2.656696026141827
tp3749
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3750
(F-2.6730125497240538
F-2.8097091087928185
tp3751
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3752
(F-2.686782165143475
F-2.8283603374774637
tp3753
sS'import psutil\npid = os.getpid()'
p3754
(F-2.0241130193074546
F-2.6049869243915262
tp3755
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3756
(F-2.6272082382373596
F-2.806935530442458
tp3757
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p3758
(F-2.41595403396801
F-2.8082750760591946
tp3759
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p3760
(F-1.6126380151556443
F-2.578454824594351
tp3761
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3762
(F-2.451387305708297
F-2.6659234853891225
tp3763
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3764
(F-2.5478424828899793
F-2.696027315579928
tp3765
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3766
(F-3.004877983769284
F-2.8861917349008412
tp3767
sS'print this_proc_results'
p3768
(F-3.698667049407959
F-2.655257298396184
tp3769
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3770
(F-2.494698866783604
F-2.7584187434269833
tp3771
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3772
(F-2.5056246943694114
F-2.802128425011268
tp3773
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3774
(F-3.107575586237059
F-2.8080074603740988
tp3775
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p3776
(F-3.365074040339543
F-2.9159745436448317
tp3777
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3778
(F-2.637935985218395
F-2.8503459050105167
tp3779
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3780
(F-2.9041307643502057
F-2.8047461876502404
tp3781
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3782
(F-2.4992832755176817
F-2.7597406827486477
tp3783
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p3784
(F-2.9963754507211537
F-2.6413113520695615
tp3785
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3786
(F-2.076133207841353
F-2.843827174260066
tp3787
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3788
(F-2.920782387093322
F-2.8142978961651144
tp3789
sS'import pywintypes'
p3790
(F-3.666597604751587
F-2.5794557424692006
tp3791
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3792
(F-2.4773186805264262
F-2.7729178208571215
tp3793
sS'if (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3794
(F-2.6143148916739003
F-2.7930494455190806
tp3795
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3796
(F-2.873958642931952
F-2.7424997182992787
tp3797
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3798
(F-1.135076922039653
F-2.6608913128192606
tp3799
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3800
(F-2.0330076904296877
F-2.9112220177283654
tp3801
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3802
(F-1.9162097008399714
F-2.6750975388746996
tp3803
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3804
(F-2.5709440443250866
F-2.845508282001202
tp3805
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3806
(F-2.6993617602491473
F-2.827774928166316
tp3807
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p3808
(F-3.5258158365885417
F-2.7733133756197414
tp3809
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3810
(F-2.650994734330611
F-2.8723373413085938
tp3811
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p3812
(F-1.9215122091359105
F-2.7355513939490685
tp3813
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p3814
(F-1.3106874084472657
F-2.668961158165565
tp3815
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p3816
(F-3.0330493450164795
F-2.7195393488957333
tp3817
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3818
(F-2.78289794921875
F-2.952869415283203
tp3819
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3820
(F-2.484147071838379
F-2.8184532752403846
tp3821
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3822
(F-2.4624614684153623
F-2.6569269620455227
tp3823
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3824
(F-2.6071364879608154
F-2.943510202261118
tp3825
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3826
(F-1.8858162406441215
F-2.569315103384165
tp3827
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3828
(F-2.546875528442911
F-2.8119559654822717
tp3829
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3830
(F-2.663509931720671
F-2.83989510169396
tp3831
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3832
(F-2.5313332080841064
F-2.554747067964994
tp3833
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3834
(F-2.9277233445500754
F-2.6813741830679088
tp3835
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3836
(F-1.648061888558524
F-2.713380666879507
tp3837
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3838
(F-2.418446760911208
F-2.8017281752366285
tp3839
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3840
(F-3.0133199126878267
F-2.850361163799579
tp3841
sS'def get_pid_stats(self, pid):\n    pass'
p3842
(F-2.060134251912435
F-2.5632864145132213
tp3843
sS'import win32com.client'
p3844
(F-2.6949551900227866
F-2.7269973754882812
tp3845
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3846
(F-2.2736357919412766
F-2.8522779024564304
tp3847
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3848
(F-2.5765838623046875
F-2.8449668884277344
tp3849
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3850
(F-2.5582816343613337
F-2.662652529202975
tp3851
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3852
(F-2.9473154544830322
F-2.8934288024902344
tp3853
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3854
(F-3.507707678753397
F-2.7740892263559194
tp3855
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3856
(F-2.639244763604526
F-2.8087313725398135
tp3857
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p3858
(F-2.6386752088530723
F-2.8338118333082933
tp3859
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3860
(F-2.2303732299804686
F-2.8285164466271033
tp3861
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3862
(F-2.9657809349798385
F-2.797947810246394
tp3863
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3864
(F-2.679935893074411
F-2.7921133774977465
tp3865
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3866
(F-2.6781285603841147
F-3.0487309969388523
tp3867
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3868
(F-2.724746229605667
F-2.8210569528432994
tp3869
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3870
(F-2.2717549800872803
F-2.812373234675481
tp3871
sS"pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p3872
(F-3.379014015197754
F-2.6120100754957933
tp3873
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p3874
(F-2.5443355984157985
F-2.621268345759465
tp3875
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3876
(F-2.6448703931725546
F-2.8029996431790867
tp3877
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3878
(F-2.8611371306335034
F-2.9731947091909556
tp3879
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3880
(F-2.5326661182050945
F-2.7712642963115988
tp3881
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3882
(F-2.982673506303267
F-2.9422002939077525
tp3883
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p3884
(F-2.973409652709961
F-2.7393848712627706
tp3885
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p3886
(F-1.161576514150582
F-2.54569332416241
tp3887
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3888
(F-2.1040667707978544
F-2.7099025432880106
tp3889
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3890
(F-2.313091350051592
F-2.821894719050481
tp3891
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3892
(F-2.57555804045304
F-2.7722479013296275
tp3893
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3894
(F-2.5893909831169655
F-2.6872303302471456
tp3895
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3896
(F-2.552360781469761
F-2.6913167513333836
tp3897
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3898
(F-2.783093716235871
F-2.638903397780198
tp3899
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3900
(F-3.9376811151919155
F-2.963579324575571
tp3901
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3902
(F-1.9922265839158444
F-2.648991217980018
tp3903
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3904
(F-2.575291317400945
F-2.849676572359525
tp3905
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p3906
(F-2.6487714609204422
F-2.8450602017916164
tp3907
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3908
(F-2.9808309164391944
F-2.695723606989934
tp3909
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3910
(F-3.0538511730375744
F-2.5678881131685696
tp3911
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3912
(F-2.483502285438403
F-2.7098464965820312
tp3913
sS"import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p3914
(F-3.177597328468605
F-2.631285447340745
tp3915
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3916
(F-2.7166486133560825
F-2.845976316011869
tp3917
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3918
(F-2.1766550349093032
F-2.7276617196890025
tp3919
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3920
(F-2.9547121368185447
F-2.8057826115534854
tp3921
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3922
(F-3.110313577854887
F-2.810811849740835
tp3923
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3924
(F-2.6401257722274116
F-2.7858135516826925
tp3925
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p3926
(F-3.7799991808439555
F-2.7572869520920973
tp3927
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3928
(F-2.7900601091056036
F-2.942699725811298
tp3929
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3930
(F-2.39844601653343
F-2.8139959482046275
tp3931
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os'
p3932
(F-2.8017955235072542
F-2.7072340158315806
tp3933
sS'import os\nimport psutil'
p3934
(F-3.0869437626429965
F-2.6066771287184496
tp3935
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3936
(F-2.8466928519454657
F-2.7816907442533054
tp3937
sS'return x'
p3938
(F-3.9364025592803955
F-2.702813955453726
tp3939
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3940
(F-3.096670113357843
F-2.926233144906851
tp3941
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3942
(F-2.237247573596805
F-2.9128335806039662
tp3943
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3944
(F-2.5250904347636913
F-2.7921377328725963
tp3945
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3946
(F-2.24350012532158
F-2.7766474210298977
tp3947
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3948
(F-2.002542450097189
F-2.57883306650015
tp3949
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3950
(F-2.4567645253937402
F-2.7807461665226865
tp3951
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3952
(F-2.4024619906556373
F-2.703046651986929
tp3953
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3954
(F-2.9336807342346556
F-2.7710271982046275
tp3955
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3956
(F-2.9544876397824753
F-2.785138643704928
tp3957
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3958
(F-3.008758544921875
F-2.814753605769231
tp3959
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3960
(F-2.9820424860174004
F-2.7017291142390323
tp3961
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3962
(F-1.2352488040924072
F-2.535201439490685
tp3963
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3964
(F-2.5627831223660147
F-2.841046846829928
tp3965
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3966
(F-3.2963117928340515
F-2.8100808950570912
tp3967
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3968
(F-2.6596194922678755
F-2.8256715627817006
tp3969
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p3970
(F-2.8223228977151114
F-2.9973123990572414
tp3971
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p3972
(F-2.6331655328924004
F-2.5963258009690504
tp3973
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3974
(F-1.697530280219184
F-3.0177588829627404
tp3975
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p3976
(F-2.864924748738607
F-2.828826904296875
tp3977
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3978
(F-3.085950717804538
F-2.7948444073016825
tp3979
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3980
(F-2.517307015352471
F-2.808689997746394
tp3981
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3982
(F-2.8029110378689235
F-2.839794158935547
tp3983
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3984
(F-2.0919544270833335
F-2.6691800631009617
tp3985
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p3986
(F-3.136973762512207
F-2.8434324998121996
tp3987
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3988
(F-2.5842130184173584
F-2.9491048959585338
tp3989
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3990
(F-2.6240715426573176
F-2.8383824275090146
tp3991
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3992
(F-2.545559659917304
F-2.8385080190805287
tp3993
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3994
(F-2.913621143628192
F-2.808141855093149
tp3995
sS"return sys_dict\nif (__name__ == '__main__'):\n    pass"
p3996
(F-3.1196722030639648
F-2.7237223111666164
tp3997
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3998
(F-2.9406731423367276
F-2.8121428856482873
tp3999
sS'from __future__ import print_function'
p4000
(F-1.2804258346557618
F-2.577510246863732
tp4001
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4002
(F-2.2750157719164825
F-2.9024103604830227
tp4003
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4004
(F-2.5989029128830152
F-2.771403972919171
tp4005
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4006
(F-2.6620622731218435
F-2.8176204974834738
tp4007
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4008
(F-2.0133493460860907
F-2.854925595797025
tp4009
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4010
(F-3.189159777737403
F-2.7829190767728367
tp4011
sS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4012
(F-2.37284162567883
F-3.0015651996319113
tp4013
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4014
(F-2.131582558302962
F-2.650339566744291
tp4015
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4016
(F-1.9167462633801746
F-2.720274705153245
tp4017
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4018
(F-2.6611794211647726
F-2.63731442964994
tp4019
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4020
(F-2.6628453321310688
F-2.7955721341646633
tp4021
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4022
(F-2.3254885382401316
F-2.7659237201397238
tp4023
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4024
(F-2.6248700845517354
F-2.7841817415677586
tp4025
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4026
(F-1.9670357259114584
F-2.8107367295485277
tp4027
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4028
(F-2.078765869140625
F-2.758085691011869
tp4029
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4030
(F-1.6803969695788472
F-2.7106349651630106
tp4031
sS'if (not self.process_name_list):\n    found_flag = True'
p4032
(F-3.0505197698419746
F-2.7097420325646033
tp4033
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4034
(F-2.7269351734834557
F-2.83985343346229
tp4035
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p4036
(F-1.8099384307861328
F-2.6136920635516825
tp4037
sS"memoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p4038
(F-3.9342498779296875
F-2.6346397399902344
tp4039
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4040
(F-2.4883554655056064
F-2.8274612426757812
tp4041
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p4042
(F-2.7417464385161527
F-2.750063969538762
tp4043
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4044
(F-2.5965605110957704
F-2.7995306161733775
tp4045
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4046
(F-3.3748330170253538
F-2.840807401216947
tp4047
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4048
(F-2.044256119501023
F-2.5994429955115685
tp4049
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4050
(F-3.16495849609375
F-2.572979266826923
tp4051
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4052
(F-3.3698966286399146
F-2.9520979661207933
tp4053
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4054
(F-1.950906513542529
F-2.831854013296274
tp4055
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4056
(F-2.474008913393374
F-2.755089099590595
tp4057
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4058
(F-2.664684630276864
F-2.8262593195988583
tp4059
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4060
(F-2.634955044450431
F-2.8365616431603065
tp4061
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4062
(F-2.4187430903596696
F-2.8277403024526744
tp4063
sS'if (not self.perf_object_list):\n    pass'
p4064
(F-2.466528574625651
F-2.8040877122145433
tp4065
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4066
(F-2.2134387704680005
F-2.833363753098708
tp4067
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4068
(F-2.6301197725183822
F-2.831393608680138
tp4069
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4070
(F-2.70777549246392
F-2.84642087496244
tp4071
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4072
(F-2.296344422457511
F-2.8114395141601562
tp4073
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4074
(F-2.404541462769002
F-2.87632076556866
tp4075
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4076
(F-2.4911120830138036
F-2.8643423227163463
tp4077
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4078
(F-2.6706715515394253
F-2.819242624136118
tp4079
sS'if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p4080
(F-3.1343206678118025
F-2.813441349909856
tp4081
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4082
(F-1.344618199235302
F-2.541012397179237
tp4083
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4084
(F-2.456436765462522
F-2.807185246394231
tp4085
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4086
(F-2.0080040716355847
F-2.7757943960336537
tp4087
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4088
(F-1.4228406247839462
F-2.5644363990196815
tp4089
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4090
(F-1.850023993130388
F-2.5729290888859677
tp4091
sS'return proc_results_list'
p4092
(F-3.259523868560791
F-2.7744436997633715
tp4093
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4094
(F-2.119559283232569
F-2.8254767197829027
tp4095
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4096
(F-2.0538809232622666
F-2.6750576312725363
tp4097
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4098
(F-2.4640284203018346
F-2.6561848567082333
tp4099
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4100
(F-2.4617342826647635
F-2.8149375915527344
tp4101
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4102
(F-2.444897851910031
F-2.760303203876202
tp4103
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4104
(F-2.2642354762300534
F-2.627788543701172
tp4105
sS'for proc_name in self.process_name_list:\n    pass'
p4106
(F-2.467797931871916
F-2.76578609759991
tp4107
sS"for counter_type in perf_object_list:\n    strComputer = '.'"
p4108
(F-3.463631439208984
F-2.918224041278546
tp4109
sS"strComputer = '.'"
p4110
(F-4.411866823832194
F-2.695874434251052
tp4111
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4112
(F-2.9090262164640275
F-2.7835176908052883
tp4113
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4114
(F-1.5403609055739182
F-2.536670978252704
tp4115
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4116
(F-2.942625320077341
F-2.8652194096491885
tp4117
sS"print ('memory use:', memoryUse)"
p4118
(F-3.941044701470269
F-2.63527826162485
tp4119
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4120
(F-2.5631336701221956
F-2.8122197664701023
tp4121
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4122
(F-2.168583713107639
F-2.791582841139573
tp4123
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4124
(F-2.087694144543306
F-2.7486959604116588
tp4125
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        pass"
p4126
(F-3.599301078102805
F-2.6184469369741588
tp4127
sS'pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p4128
(F-3.4222522735595704
F-2.609857412484976
tp4129
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4130
(F-2.308354916779891
F-2.7728280287522535
tp4131
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4132
(F-2.890253825360034
F-2.7858516986553488
tp4133
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4134
(F-2.6452307957955212
F-2.7970862755408654
tp4135
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4136
(F-2.849650643088601
F-2.8843198922964244
tp4137
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4138
(F-2.343564879219487
F-2.7679813091571512
tp4139
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4140
(F-2.680854180518617
F-2.830054943378155
tp4141
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4142
(F-2.931594684559812
F-2.894831730769231
tp4143
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4144
(F-2.253678676060268
F-2.7121429443359375
tp4145
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4146
(F-2.6633817926416254
F-2.8119723980243387
tp4147
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4148
(F-2.3740623209006997
F-2.637163602388822
tp4149
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4150
(F-2.685740401105183
F-2.8526268005371094
tp4151
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4152
(F-2.4853629002999225
F-2.785640129676232
tp4153
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4154
(F-2.1667393275669644
F-2.813333658071665
tp4155
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p4156
(F-2.519095809371383
F-2.8987197875976562
tp4157
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4158
(F-2.479749534562317
F-2.862530928391677
tp4159
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4160
(F-2.4079794702232915
F-2.862423823429988
tp4161
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4162
(F-2.673263245844746
F-2.816570575420673
tp4163
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4164
(F-2.986068825316585
F-2.849487011249249
tp4165
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4166
(F-2.5060796006574746
F-2.6389198303222656
tp4167
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p4168
(F-2.960204760233561
F-2.649066631610577
tp4169
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4170
(F-1.49490293522471
F-2.571195749136118
tp4171
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4172
(F-2.3347243254405288
F-2.7722960252028246
tp4173
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4174
(F-2.422467064764713
F-2.885834033672626
tp4175
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4176
(F-2.509544162168904
F-2.676580575796274
tp4177
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4178
(F-2.9460175803344173
F-2.820523188664363
tp4179
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p4180
(F-2.9733600227200254
F-2.787488203782302
tp4181
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4182
(F-3.0805990816366795
F-2.8895463209885817
tp4183
sS'import pywintypes\nimport datetime'
p4184
(F-3.8396358489990234
F-2.5763282775878906
tp4185
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4186
(F-1.097565831364812
F-2.6506758469801683
tp4187
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass'
p4188
(F-2.24053770920326
F-2.7199815603402944
tp4189
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4190
(F-3.0378442679339575
F-2.8402208181527944
tp4191
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4192
(F-2.9623889511437724
F-2.7930523799015927
tp4193
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4194
(F-2.641514862965381
F-2.8291361882136417
tp4195
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4196
(F-2.9764291492625827
F-2.7958104060246396
tp4197
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4198
(F-2.6431222401494567
F-2.811189504770132
tp4199
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4200
(F-1.8626736534966364
F-2.8217233511117787
tp4201
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4202
(F-3.2547712326049805
F-2.8776773306039662
tp4203
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4204
(F-2.948384894340974
F-2.8192074115459738
tp4205
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4206
(F-2.7914617438065377
F-2.7832606388972354
tp4207
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4208
(F-2.698854585973228
F-2.6237059373121996
tp4209
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4210
(F-2.770471052689986
F-2.866712423471304
tp4211
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4212
(F-3.0948786102564987
F-2.847008044903095
tp4213
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p4214
(F-1.7358874568232783
F-2.8089300302358775
tp4215
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p4216
(F-3.006043243408203
F-2.6355379544771633
tp4217
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4218
(F-2.2235146262428978
F-2.669935079721304
tp4219
sS'this_proc_results = stats_processor.get_pid_stats(this_pid)'
p4220
(F-2.986287897283381
F-2.5848919795109677
tp4221
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4222
(F-2.4364794049944196
F-2.7615016056941104
tp4223
sS'obj_name = objItem.Name'
p4224
(F-5.402353286743164
F-2.855009225698618
tp4225
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4226
(F-2.620493663441051
F-2.8617632939265323
tp4227
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4228
(F-2.671449816724652
F-2.793773944561298
tp4229
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p4230
(F-3.1011086203835228
F-2.975956843449519
tp4231
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4232
(F-2.3449131415142275
F-2.7698513911320615
tp4233
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4234
(F-3.007105539536335
F-2.7139041607196512
tp4235
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4236
(F-2.6852621066789686
F-2.696216876690204
tp4237
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4238
(F-3.0281342022235576
F-2.8165101271409254
tp4239
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p4240
(F-1.7136083704824665
F-2.5714777432955227
tp4241
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4242
(F-2.6676275079900567
F-2.8625705425555887
tp4243
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4244
(F-2.4511010306222096
F-2.873235849233774
tp4245
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            pass"
p4246
(F-3.224847581651476
F-2.729013883150541
tp4247
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4248
(F-2.6800446313274793
F-2.8372139563927283
tp4249
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4250
(F-2.705627241944955
F-2.8403690044696512
tp4251
sS"if (__name__ == '__main__'):\n    pass"
p4252
(F-1.9641915639241536
F-2.632542243370643
tp4253
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4254
(F-2.394925865760216
F-2.6310530442457933
tp4255
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4256
(F-2.202648696079049
F-2.8774915841909556
tp4257
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p4258
(F-2.2311832889629777
F-2.652270096998948
tp4259
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4260
(F-2.469814591890542
F-2.8106463505671573
tp4261
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p4262
(F-2.232951282943267
F-2.669431833120493
tp4263
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4264
(F-2.1715763173204787
F-2.8301121638371396
tp4265
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4266
(F-2.7099116863590655
F-2.6851712740384617
tp4267
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4268
(F-2.422833636090472
F-2.805897052471454
tp4269
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4270
(F-2.5855575518051106
F-2.7680576031024637
tp4271
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4272
(F-2.8801629365380133
F-2.840641902043269
tp4273
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4274
(F-1.8994906065893955
F-2.8318724999061
tp4275
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4276
(F-3.227079911665483
F-2.8552339993990383
tp4277
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4278
(F-2.6034389048315294
F-2.77161378126878
tp4279
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4280
(F-2.993650429755553
F-2.8192725548377404
tp4281
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4282
(F-2.362175918206936
F-2.8115791907677283
tp4283
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4284
(F-2.3196680998999226
F-2.9231417729304385
tp4285
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4286
(F-3.08063440888984
F-2.8451626117412863
tp4287
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4288
(F-2.51055227963979
F-2.8043491656963644
tp4289
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4290
(F-2.986551513671875
F-2.8120299119215746
tp4291
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4292
(F-3.0134593703983965
F-2.8011979323167067
tp4293
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4294
(F-3.1490731588224086
F-2.8158798217773438
tp4295
sS'py = psutil.Process(pid)'
p4296
(F-2.532053756713867
F-2.614501953125
tp4297
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4298
(F-2.5030406230204814
F-2.6475034860464244
tp4299
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4300
(F-2.4901180557204596
F-2.6837689326359677
tp4301
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4302
(F-2.9561421871185303
F-2.824536543626052
tp4303
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4304
(F-2.1123855632855544
F-2.790447235107422
tp4305
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4306
(F-1.8446569333131286
F-2.575994931734525
tp4307
sS'import os\nthis_pid = os.getpid()'
p4308
(F-2.149007116045271
F-2.6384541438176083
tp4309
sS'for proc_name in self.process_name_list:\n    obj_name = objItem.Name'
p4310
(F-3.3058301485501804
F-2.847391275259165
tp4311
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4312
(F-2.6938681640625
F-2.8027064983661356
tp4313
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4314
(F-2.6138533626694276
F-2.7913213876577525
tp4315
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4316
(F-2.8036980523003474
F-2.8507537841796875
tp4317
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4318
(F-2.9225713851604054
F-2.69060310950646
tp4319
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4320
(F-2.931831791715802
F-2.7913841834435096
tp4321
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p4322
(F-3.349753679547991
F-2.8300558236929088
tp4323
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4324
(F-2.678907947860462
F-2.852778801551232
tp4325
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4326
(F-2.051683470260265
F-2.75388189462515
tp4327
sS'pythoncom.CoInitialize()\nproc_results_list = []'
p4328
(F-3.248611898983226
F-2.711710709791917
tp4329
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4330
(F-2.186694304955187
F-2.8525962829589844
tp4331
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4332
(F-2.22140154555508
F-2.736796159010667
tp4333
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4334
(F-3.1934940615179817
F-2.8484893211951623
tp4335
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4336
(F-2.3794803360133496
F-2.662275167611929
tp4337
sS'return this_proc_dict\n\ndef get_stats(self):\n    pass'
p4338
(F-2.4341553774746982
F-2.774740072397085
tp4339
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4340
(F-2.1780370076497397
F-2.8918101970966044
tp4341
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p4342
(F-2.103234427315848
F-2.622096428504357
tp4343
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4344
(F-2.5769383833345763
F-2.7834672194260817
tp4345
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4346
(F-1.4290258104556075
F-2.787103506234976
tp4347
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4348
(F-2.6425986230224
F-2.8269597567044773
tp4349
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4350
(F-1.4813074129764165
F-2.800871335543119
tp4351
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4352
(F-1.561309814453125
F-2.664928436279297
tp4353
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4354
(F-2.021297878689236
F-2.854106609637921
tp4355
sS'this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4356
(F-2.8460803031921387
F-2.5774882389948917
tp4357
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4358
(F-2.121044682521446
F-2.8353118896484375
tp4359
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4360
(F-2.815901841574568
F-2.834715036245493
tp4361
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4362
(F-2.869528517082556
F-2.697712238018329
tp4363
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4364
(F-2.215232586038524
F-2.8083906907301683
tp4365
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4366
(F-2.5643146287955916
F-2.726134960467999
tp4367
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4368
(F-2.706365886487459
F-2.599545112022987
tp4369
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4370
(F-2.972042192731585
F-2.7146685673640323
tp4371
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p4372
(F-1.458556842803955
F-2.8728367732121396
tp4373
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4374
(F-2.4386119079589843
F-2.6828313974233775
tp4375
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4376
(F-3.177005486739309
F-2.9242336566631613
tp4377
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4378
(F-3.13931649630187
F-2.92373041006235
tp4379
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4380
(F-1.8415213139099482
F-2.5624964787409854
tp4381
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4382
(F-2.445991598742103
F-2.810252849872296
tp4383
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4384
(F-2.1630766563808796
F-2.777300321138822
tp4385
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4386
(F-1.303733455324636
F-2.6475824209359975
tp4387
sS"' Returns a dictionary of the system stats'"
p4388
(F-2.6680564880371094
F-2.686055990365835
tp4389
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p4390
(F-2.892939074286099
F-2.72857666015625
tp4391
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4392
(F-2.0713365342881946
F-2.7191549447866588
tp4393
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4394
(F-2.2601720506899823
F-2.845371833214393
tp4395
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4396
(F-2.388662164861506
F-2.875014378474309
tp4397
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p4398
(F-2.6843709531037705
F-2.6584220299353967
tp4399
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4400
(F-2.550060272216797
F-2.799329610971304
tp4401
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4402
(F-2.2506616703597953
F-2.856488741361178
tp4403
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4404
(F-2.1174869746952267
F-2.82903084388146
tp4405
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4406
(F-2.964070264030905
F-2.8331463153545675
tp4407
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p4408
(F-2.9005309074155745
F-2.6885150029109073
tp4409
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4410
(F-2.425871308866914
F-2.8048122112567606
tp4411
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4412
(F-3.14650906119377
F-2.825938885028546
tp4413
sS'from __future__ import print_function\nimport psutil'
p4414
(F-1.9293048565204327
F-2.578125
tp4415
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4416
(F-2.1596421154305405
F-2.6490102914663463
tp4417
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4418
(F-2.6216696796467036
F-2.8398763216458836
tp4419
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4420
(F-2.6470499227335167
F-2.8361631540151744
tp4421
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4422
(F-2.672647545855978
F-2.831938230074369
tp4423
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4424
(F-3.2091226288766572
F-2.7650211040790262
tp4425
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4426
(F-2.9964835427024146
F-2.7868118286132812
tp4427
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4428
(F-3.180999067492951
F-2.8211578956017127
tp4429
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4430
(F-2.5443288904860637
F-2.697069608248197
tp4431
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p4432
(F-2.4487688752258716
F-2.8058656545785756
tp4433
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4434
(F-3.046789057114545
F-2.845674074613131
tp4435
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4436
(F-3.068187255859375
F-2.7870650658240685
tp4437
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4438
(F-2.620403010670732
F-2.8308181762695312
tp4439
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4440
(F-2.5213801864373133
F-2.6626451932466946
tp4441
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4442
(F-2.09619140625
F-2.7892109797551083
tp4443
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p4444
(F-2.729231262207031
F-2.7979648296649637
tp4445
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4446
(F-2.5540491522547186
F-2.6648389376126804
tp4447
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4448
(F-3.032303873697917
F-2.840014237623948
tp4449
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p4450
(F-1.8455033735795454
F-2.565229269174429
tp4451
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4452
(F-2.4853922007035236
F-2.5569320091834435
tp4453
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4454
(F-2.277374605910477
F-2.6458881084735575
tp4455
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4456
(F-2.8735292419906733
F-2.798228043776292
tp4457
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4458
(F-2.3490000219676634
F-2.8061156639686
tp4459
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p4460
(F-1.133101645480381
F-2.6364446786733775
tp4461
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4462
(F-2.4769383954825877
F-2.645631643442007
tp4463
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4464
(F-2.230000764420889
F-2.8433846693772535
tp4465
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4466
(F-2.4691435215836863
F-2.705653557410607
tp4467
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4468
(F-2.5063141386387713
F-2.8846415006197414
tp4469
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4470
(F-3.0134619657324735
F-2.8178939819335938
tp4471
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4472
(F-2.948089901763614
F-2.859251462496244
tp4473
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4474
(F-2.6133357770848344
F-2.7926565317007213
tp4475
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4476
(F-2.3282361619015957
F-2.7983360290527344
tp4477
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4478
(F-2.8514121206183183
F-2.7390823364257812
tp4479
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4480
(F-2.652148711815309
F-2.8054568950946512
tp4481
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3'
p4482
(F-3.922657012939453
F-2.668670654296875
tp4483
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4484
(F-2.964564641316732
F-2.7375077467698317
tp4485
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4486
(F-2.6502381005554834
F-2.8398692791278544
tp4487
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4488
(F-2.4904978918650795
F-2.5970934354341946
tp4489
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4490
(F-2.483833885192871
F-2.817518087533804
tp4491
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4492
(F-2.1397571782956177
F-2.8063430786132812
tp4493
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4494
(F-2.275416056315104
F-2.8563998295710635
tp4495
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4496
(F-2.5184017205090257
F-2.7833677438589244
tp4497
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4498
(F-1.968246812474216
F-2.777346684382512
tp4499
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4500
(F-2.7302296590462007
F-2.8153956486628604
tp4501
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4502
(F-1.0868022245519302
F-2.6277812077448917
tp4503
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4504
(F-2.317119503809401
F-2.833585885854868
tp4505
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4506
(F-2.56656975146161
F-2.762938279371995
tp4507
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4508
(F-2.1567749655926165
F-2.6183976393479567
tp4509
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4510
(F-1.3601971968863775
F-2.6612936166616588
tp4511
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p4512
(F-2.8433037429559427
F-2.9043734623835635
tp4513
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4514
(F-2.4676616093883776
F-2.806499481201172
tp4515
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4516
(F-2.8270584909539473
F-2.902006296011118
tp4517
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4518
(F-2.9311352615836284
F-2.6950994638296275
tp4519
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4520
(F-2.5417868077069863
F-2.779918377216046
tp4521
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p4522
(F-1.854533054517663
F-2.838436713585487
tp4523
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4524
(F-2.5437605770122405
F-2.6575543330265927
tp4525
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4526
(F-2.903191241739471
F-2.6894598740797777
tp4527
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4528
(F-1.8831483981753356
F-2.8104447584885817
tp4529
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4530
(F-3.2707613199064047
F-2.8837820199819713
tp4531
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4532
(F-2.7800370337257925
F-2.830216040978065
tp4533
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4534
(F-2.4043204288354656
F-2.813067216139573
tp4535
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4536
(F-1.9530349359279726
F-2.698900369497446
tp4537
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4538
(F-3.0090692070093046
F-2.786192380464994
tp4539
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p4540
(F-2.055272965204148
F-2.635159125694862
tp4541
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4542
(F-2.33701076755276
F-2.8148662860576925
tp4543
sS"print 'this proc results:'"
p4544
(F-2.4747941493988037
F-2.6232452392578125
tp4545
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4546
(F-2.4101310306125217
F-2.8110568706805887
tp4547
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4548
(F-2.11154510644064
F-2.7349932743952823
tp4549
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4550
(F-3.0340195377316097
F-2.844283177302434
tp4551
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4552
(F-2.440386828254251
F-2.8154684213491588
tp4553
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4554
(F-3.1339952741350445
F-2.914531707763672
tp4555
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4556
(F-3.0265402221679687
F-2.7175997220552883
tp4557
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4558
(F-3.0418307964618387
F-2.7506138728215146
tp4559
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4560
(F-2.4555668293706674
F-2.8059475238506613
tp4561
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4562
(F-2.5802216675142833
F-2.686881138728215
tp4563
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4564
(F-2.5477818754530444
F-2.8334661630483775
tp4565
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4566
(F-2.6612235637626265
F-2.8164602426382213
tp4567
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4568
(F-2.886781494140625
F-2.7053780188927283
tp4569
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4570
(F-2.439207571991219
F-2.807302034818209
tp4571
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4572
(F-2.0045748539608663
F-2.598459683931791
tp4573
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4574
(F-2.8682801293545084
F-2.6769984318659854
tp4575
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4576
(F-2.1593471347349475
F-2.692442673903245
tp4577
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p4578
(F-2.646485579641242
F-2.879861978384165
tp4579
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4580
(F-2.7213376448458475
F-2.844788771409255
tp4581
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4582
(F-3.0784402400889297
F-2.9904386080228367
tp4583
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4584
(F-2.937333634131065
F-2.818910452035757
tp4585
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4586
(F-2.221674886982093
F-2.6527472275954027
tp4587
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p4588
(F-2.4373353322347007
F-2.6097946166992188
tp4589
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4590
(F-1.9902672661675347
F-2.5830553494966946
tp4591
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4592
(F-2.6396902657888988
F-2.810888437124399
tp4593
sS'x = winmem()'
p4594
(F-1.8516905648367745
F-2.6882779048039365
tp4595
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4596
(F-3.075342978200605
F-2.81523191011869
tp4597
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4598
(F-2.675021538367638
F-2.724129603459285
tp4599
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4600
(F-1.9915094877544202
F-2.6324512775127706
tp4601
sS'break\nreturn this_proc_dict'
p4602
(F-4.579376983642578
F-2.850570091834435
tp4603
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4604
(F-2.2269975093373082
F-2.6674420283390927
tp4605
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4606
(F-2.0524717896849243
F-2.575754899245042
tp4607
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4608
(F-2.289352077907986
F-2.8268632155198317
tp4609
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4610
(F-2.6639366149902344
F-2.8740445650540867
tp4611
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4612
(F-2.9965678513652145
F-2.7821138822115383
tp4613
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4614
(F-2.8463834565261315
F-2.8637093764085035
tp4615
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4616
(F-2.907241941437008
F-2.829976301926833
tp4617
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4618
(F-2.1729640282955267
F-2.8369662945087137
tp4619
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4620
(F-2.0902490672950975
F-2.818315946138822
tp4621
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4622
(F-2.9888063224765897
F-2.794205298790565
tp4623
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4624
(F-2.02920512280433
F-2.624578622671274
tp4625
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4626
(F-2.8381034003363714
F-2.5931012080265927
tp4627
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4628
(F-1.9889676425997065
F-2.8021601163423977
tp4629
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4630
(F-3.288413514482214
F-2.920856182391827
tp4631
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4632
(F-3.0417379287474935
F-2.788868243877704
tp4633
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4634
(F-1.8810327600549768
F-2.8819574209359975
tp4635
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4636
(F-2.6716192213155456
F-2.846726344181941
tp4637
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4638
(F-2.817068699428013
F-2.9417730478140025
tp4639
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4640
(F-2.1365219751993814
F-2.827911670391376
tp4641
sS'print psutil.cpu_percent()'
p4642
(F-2.773855972290039
F-2.555806966928335
tp4643
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4644
(F-1.7601918971284907
F-2.571790255033053
tp4645
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4646
(F-3.0169037609565548
F-2.90320792564979
tp4647
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4648
(F-2.620218335967703
F-2.7703587458683896
tp4649
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4650
(F-1.943793190850152
F-2.737682635967548
tp4651
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p4652
(F-2.95301865086411
F-2.638673048753005
tp4653
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4654
(F-2.4221968850255466
F-2.6391463646521935
tp4655
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4656
(F-2.481795566533905
F-2.8641539353590746
tp4657
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4658
(F-2.3271546444650424
F-2.8034084026630106
tp4659
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4660
(F-2.535583887344752
F-2.884509746844952
tp4661
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4662
(F-3.0352011015920928
F-2.861358936016376
tp4663
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4664
(F-2.9298447578403026
F-2.687967740572416
tp4665
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4666
(F-2.433117083649137
F-2.6538411653958836
tp4667
sS'found_flag = True'
p4668
(F-3.7857328142438615
F-2.7051620483398438
tp4669
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4670
(F-2.431354736328125
F-2.830708723801833
tp4671
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4672
(F-2.4687934360621164
F-2.87256592970628
tp4673
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4674
(F-2.4481662888601035
F-2.653531001164363
tp4675
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4676
(F-2.994162647994523
F-2.921887911283053
tp4677
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4678
(F-2.8967746947168256
F-2.7947393564077525
tp4679
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4680
(F-2.6903213800168504
F-2.8791134174053488
tp4681
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4682
(F-1.599964396158854
F-2.563960148737981
tp4683
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4684
(F-2.733215761856294
F-2.8413194509652944
tp4685
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4686
(F-2.4317985867452543
F-2.8127887432391825
tp4687
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4688
(F-3.2165602344577597
F-2.8102939312274637
tp4689
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4690
(F-1.9566632116626124
F-2.79964358990009
tp4691
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4692
(F-2.849630644827178
F-2.680018498347356
tp4693
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4694
(F-3.114495935574384
F-2.9287840036245494
tp4695
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4696
(F-2.9941014397073777
F-2.6924189054048977
tp4697
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4698
(F-1.5699418924622617
F-2.6450430063100963
tp4699
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4700
(F-2.236705141204396
F-2.8232797475961537
tp4701
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p4702
(F-2.533963912572616
F-2.6445867098294773
tp4703
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p4704
(F-1.8843088785807292
F-2.6342518146221456
tp4705
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p4706
(F-2.854097574064047
F-2.8302999643179088
tp4707
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4708
(F-2.528102148146856
F-2.6635108360877404
tp4709
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4710
(F-2.9031436317845394
F-2.719054002028245
tp4711
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4712
(F-1.965132774939904
F-2.6441368689903846
tp4713
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4714
(F-2.102405153471848
F-2.7788432194636417
tp4715
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4716
(F-2.104529256874559
F-2.8339459345890927
tp4717
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4718
(F-2.1555058706142103
F-2.763293926532452
tp4719
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4720
(F-1.8639370787377452
F-2.810031303992638
tp4721
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4722
(F-2.35356187655439
F-2.84209471482497
tp4723
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4724
(F-2.48905879357467
F-2.6469430189866285
tp4725
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4726
(F-2.667712749463122
F-2.837437556340144
tp4727
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4728
(F-2.6682874700996315
F-2.8153354938213644
tp4729
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4730
(F-3.1080733383257773
F-2.8387806232158956
tp4731
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p4732
(F-2.966185349684495
F-2.808287107027494
tp4733
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4734
(F-2.305274998216324
F-2.6301859342134914
tp4735
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4736
(F-2.302431671858342
F-2.635893308199369
tp4737
sS'import win32com.client\nfrom ctypes import *'
p4738
(F-2.596398960460316
F-2.6558468158428488
tp4739
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4740
(F-2.9088557475322
F-2.8722613408015323
tp4741
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4742
(F-2.7815127563476563
F-2.8509990985576925
tp4743
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p4744
(F-1.6723202466964722
F-2.575589106633113
tp4745
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4746
(F-2.634154195553946
F-2.837574005126953
tp4747
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4748
(F-2.6118743757134704
F-2.791303194486178
tp4749
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4750
(F-2.5754639120662914
F-2.691618405855619
tp4751
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4752
(F-3.12928466796875
F-2.7432705805851865
tp4753
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4754
(F-2.5227394343921974
F-2.8312066885141225
tp4755
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4756
(F-2.9967854817708335
F-2.788311298076923
tp4757
sS'class process_stats:\n    pass'
p4758
(F-2.735213366421786
F-2.6688913198617787
tp4759
sS'return x\n\n\nclass process_stats:\n    pass'
p4760
(F-3.243696689605713
F-2.669787186842698
tp4761
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4762
(F-1.1463721519292787
F-2.5208396911621094
tp4763
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4764
(F-2.0418062918526787
F-2.7135890080378604
tp4765
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4766
(F-2.4478561986198826
F-2.837798778827374
tp4767
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p4768
(F-2.4019644218578673
F-2.9191072904146633
tp4769
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4770
(F-3.0016073139529986
F-2.8825968228853664
tp4771
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4772
(F-2.3034429353941617
F-2.7692043597881613
tp4773
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4774
(F-2.749784296209162
F-2.8414591275728664
tp4775
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4776
(F-2.6886786745305646
F-2.7594997699444113
tp4777
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4778
(F-2.6395613606770834
F-2.7781521723820615
tp4779
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4780
(F-1.994183858235677
F-2.5802717942457933
tp4781
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4782
(F-2.4789329176682693
F-2.802747579721304
tp4783
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4784
(F-2.7132801458464195
F-2.8419793935922475
tp4785
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4786
(F-2.119538428660654
F-2.603697263277494
tp4787
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4788
(F-3.065168757268912
F-2.852774693415715
tp4789
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4790
(F-2.6493869075656185
F-2.8411246079664965
tp4791
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4792
(F-2.304233003866793
F-2.638173323411208
tp4793
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        pass"
p4794
(F-3.1955127200564823
F-2.692782475398137
tp4795
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4796
(F-3.1501092596368476
F-2.6999940138596754
tp4797
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4798
(F-2.0210676713423297
F-2.7660255432128906
tp4799
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p4800
(F-2.922420594750381
F-2.738655970646785
tp4801
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4802
(F-2.9559023290648496
F-2.717764927790715
tp4803
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4804
(F-2.254944279508771
F-2.8851878826434794
tp4805
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4806
(F-2.3970740019385492
F-2.8613316462590146
tp4807
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p4808
(F-2.5421379937065973
F-2.725516392634465
tp4809
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p4810
(F-2.8057738084059496
F-2.9154396057128906
tp4811
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4812
(F-2.96798675228851
F-2.8287197993351865
tp4813
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4814
(F-2.6419718952922078
F-2.838293222280649
tp4815
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4816
(F-1.956326711092064
F-2.831888345571665
tp4817
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4818
(F-2.0720328054120465
F-2.6676993736853967
tp4819
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4820
(F-2.7168834552216454
F-2.820518787090595
tp4821
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4822
(F-2.684923881181027
F-2.8104644188514123
tp4823
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4824
(F-2.653606357859142
F-2.793102264404297
tp4825
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4826
(F-2.661529719480994
F-2.843309549184946
tp4827
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4828
(F-2.7507702862774885
F-2.845894740178035
tp4829
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p4830
(F-3.352137011150981
F-2.617584228515625
tp4831
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p4832
(F-2.7994117736816406
F-2.750045189490685
tp4833
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4834
(F-3.303735180435894
F-2.7482085594764123
tp4835
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4836
(F-2.642989262541616
F-2.8359427818885217
tp4837
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4838
(F-2.900635320490057
F-2.8504292414738583
tp4839
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4840
(F-1.0867722674113949
F-2.651645073523888
tp4841
sS'if found_flag:\n    pass'
p4842
(F-2.504188364202326
F-2.654918670654297
tp4843
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4844
(F-2.6981609413612024
F-2.835101787860577
tp4845
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4846
(F-1.921985554245283
F-2.6444329481858473
tp4847
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4848
(F-2.592332663825445
F-2.767964583176833
tp4849
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p4850
(F-1.546193181251993
F-2.58694575383113
tp4851
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4852
(F-2.8026443702587183
F-2.86884513268104
tp4853
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4854
(F-2.565825028852983
F-2.6810672466571512
tp4855
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4856
(F-2.450608964399858
F-2.7879615196814904
tp4857
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4858
(F-2.4870029179039403
F-2.6710868248572717
tp4859
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4860
(F-2.8904111474976504
F-2.789637932410607
tp4861
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4862
(F-2.7260564666947507
F-2.8466063279371996
tp4863
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4864
(F-2.594575492058011
F-2.679951007549579
tp4865
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4866
(F-2.0785419531827847
F-2.593836857722356
tp4867
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p4868
(F-1.9392335255940756
F-2.53672849214994
tp4869
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4870
(F-2.4368075518540935
F-2.753011556772085
tp4871
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4872
(F-2.9654545044348186
F-2.848651885986328
tp4873
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4874
(F-2.2586510251845993
F-2.874065692608173
tp4875
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4876
(F-2.453759970785189
F-2.6679922250600963
tp4877
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4878
(F-2.3770767660701977
F-2.8729283259465146
tp4879
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4880
(F-2.647386633831522
F-2.825169489933894
tp4881
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4882
(F-2.4448931057702614
F-2.7602908794696512
tp4883
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4884
(F-2.9400289516256315
F-2.6866912841796875
tp4885
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p4886
(F-1.9431910551795664
F-2.8664603600135217
tp4887
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4888
(F-2.318129226624259
F-2.8955841064453125
tp4889
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4890
(F-2.956611003350774
F-2.826703878549429
tp4891
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4892
(F-3.0017428694100214
F-2.8052955040564904
tp4893
sS"for attribute in self.supported_types[counter_type]:\n    eval_str = ('objItem.%s' % attribute)"
p4894
(F-4.027747562953404
F-2.9009713392991285
tp4895
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4896
(F-2.2818267379981885
F-2.84507076556866
tp4897
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p4898
(F-2.168614340091937
F-2.8596355731670675
tp4899
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4900
(F-1.9671894334117819
F-2.7173238900991588
tp4901
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4902
(F-2.4685770849351933
F-2.7048700772798977
tp4903
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4904
(F-2.457033826159192
F-2.7637085547814
tp4905
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4906
(F-2.055513641537999
F-2.8245245126577525
tp4907
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4908
(F-2.2827515280926165
F-2.876178448016827
tp4909
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p4910
(F-3.3238814858829273
F-2.5662604111891527
tp4911
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4912
(F-2.877141700600678
F-2.9382908160869894
tp4913
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4914
(F-2.138523032086325
F-2.6166725158691406
tp4915
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4916
(F-3.0276590983072915
F-2.7529593247633715
tp4917
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4918
(F-2.0919660760100776
F-2.866773165189303
tp4919
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4920
(F-2.9061025571052252
F-2.7434569138746996
tp4921
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4922
(F-2.0565778409854047
F-2.842886998103215
tp4923
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4924
(F-2.8889376126802886
F-2.790257380558894
tp4925
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4926
(F-2.6013646032816853
F-2.7836066025954027
tp4927
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4928
(F-2.6614628161414196
F-2.8205818763146033
tp4929
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4930
(F-2.535743200386713
F-2.7697486877441406
tp4931
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4932
(F-2.56342672003716
F-2.7695623544546275
tp4933
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4934
(F-1.1557980989155017
F-2.7836183401254506
tp4935
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4936
(F-2.1459034886853448
F-2.577990311842698
tp4937
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4938
(F-2.6749284985656194
F-2.832923595721905
tp4939
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4940
(F-3.090794881184896
F-2.811343559852013
tp4941
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4942
(F-1.4802281515938895
F-2.6618863619290867
tp4943
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4944
(F-3.0491192373811926
F-2.84738276554988
tp4945
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4946
(F-2.25477663832156
F-2.825877849872296
tp4947
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4948
(F-2.383885343309859
F-2.853564922626202
tp4949
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4950
(F-2.254673369943279
F-2.821732154259315
tp4951
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4952
(F-1.9679408217921401
F-2.6147610591008115
tp4953
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4954
(F-2.64977455585846
F-2.798367133507362
tp4955
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4956
(F-3.1233933971774195
F-2.974141927865835
tp4957
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4958
(F-2.720943127648305
F-2.77015627347506
tp4959
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4960
(F-2.99382373046875
F-2.7956534165602465
tp4961
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4962
(F-2.61093315404123
F-2.7821044921875
tp4963
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4964
(F-2.1066973091352104
F-2.8098414494441104
tp4965
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4966
(F-2.2403799203725963
F-2.873769319974459
tp4967
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4968
(F-2.6829854287129677
F-2.8211934016301083
tp4969
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4970
(F-2.6748690278091156
F-2.82872067964994
tp4971
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4972
(F-2.0187134474850774
F-2.6591500502366285
tp4973
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4974
(F-3.3092527136338497
F-2.8220863342285156
tp4975
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4976
(F-3.027354825877775
F-2.869370387150691
tp4977
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4978
(F-2.161206809423303
F-2.780747340275691
tp4979
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4980
(F-2.161684989929199
F-2.6772149892953725
tp4981
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4982
(F-2.459473352468512
F-2.7100433936485877
tp4983
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4984
(F-2.9138173160389957
F-2.8168502220740685
tp4985
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4986
(F-2.288059435392681
F-2.865666022667518
tp4987
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p4988
(F-2.3379344233760126
F-2.6171012291541467
tp4989
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4990
(F-4.184310186476934
F-3.1730625446026144
tp4991
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4992
(F-3.228583812713623
F-2.553509051983173
tp4993
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4994
(F-2.629025700777897
F-2.7753099294809194
tp4995
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p4996
(F-2.3538455963134766
F-2.57773443368765
tp4997
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4998
(F-1.889142469926314
F-2.5650417621319113
tp4999
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5000
(F-1.1415651620152485
F-2.703375009390024
tp5001
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5002
(F-2.376323758638822
F-2.6468059833233175
tp5003
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p5004
(F-3.140688663464414
F-2.8387415959284854
tp5005
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5006
(F-1.29749291461447
F-2.543382791372446
tp5007
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5008
(F-2.956992885044643
F-2.9322040264423075
tp5009
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5010
(F-2.3468891012257544
F-2.785856687105619
tp5011
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5012
(F-2.608871922348485
F-2.7985669649564304
tp5013
sS'if (proc_name.lower() in obj_name.lower()):\n    pass'
p5014
(F-2.3700001525878904
F-2.69870846088116
tp5015
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5016
(F-2.036047171547775
F-2.8984339787409854
tp5017
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5018
(F-2.860900711686644
F-2.7117720383864183
tp5019
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5020
(F-3.0242276509602863
F-2.837854238656851
tp5021
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5022
(F-2.4560162660886915
F-2.808926215538612
tp5023
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5024
(F-2.137370008103391
F-2.697559063251202
tp5025
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5026
(F-2.1032494296546744
F-2.803975618802584
tp5027
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5028
(F-2.6393794569858287
F-2.7954254150390625
tp5029
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5030
(F-2.026803670368138
F-2.6933805025540867
tp5031
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5032
(F-2.4896078304368623
F-2.7575178879957933
tp5033
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5034
(F-2.9789310802112925
F-2.646555680495042
tp5035
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5036
(F-2.79458374908005
F-2.8459091186523438
tp5037
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5038
(F-2.5054783226871202
F-2.7704684917743387
tp5039
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p5040
(F-1.9441464742024739
F-2.649309598482572
tp5041
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5042
(F-2.5520676238627376
F-2.6218910217285156
tp5043
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5044
(F-2.5037609281994047
F-2.7966461181640625
tp5045
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5046
(F-2.636440894717262
F-2.807149446927584
tp5047
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5048
(F-2.9404428655450996
F-2.886670626126803
tp5049
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5050
(F-2.327350378036499
F-2.6445782001201925
tp5051
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5052
(F-2.66184848692359
F-2.8343124389648438
tp5053
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5054
(F-2.5508071899414064
F-2.847410642183744
tp5055
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5056
(F-3.010502077498526
F-2.8666537358210635
tp5057
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5058
(F-3.2525670369466146
F-2.903805365929237
tp5059
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'"
p5060
(F-4.680985190651634
F-2.83026123046875
tp5061
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5062
(F-2.6565069631368172
F-2.808201716496394
tp5063
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p5064
(F-2.7975257873535155
F-2.7556064312274637
tp5065
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p5066
(F-1.8362296644107317
F-2.65249751164363
tp5067
sS'if (len(colItems) > 0):\n    pass'
p5068
(F-2.5299848668715534
F-2.7384414672851562
tp5069
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5070
(F-2.522919778262868
F-2.8705482482910156
tp5071
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5072
(F-2.8788740738578467
F-2.71282958984375
tp5073
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5074
(F-2.911205530166626
F-2.7004996079664965
tp5075
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5076
(F-2.6919698693082945
F-2.826618194580078
tp5077
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5078
(F-3.0259444778029985
F-2.7920702420748196
tp5079
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5080
(F-2.700062676248849
F-2.8405098548302283
tp5081
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5082
(F-2.222836044599425
F-2.807981637807993
tp5083
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5084
(F-2.6309302814457576
F-2.839844923753005
tp5085
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5086
(F-2.6296299525669644
F-2.835110591008113
tp5087
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5088
(F-1.9031737503732087
F-2.701343242938702
tp5089
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5090
(F-2.6572563769081223
F-2.797992706298828
tp5091
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5092
(F-2.0060948785745873
F-2.7467190669133115
tp5093
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5094
(F-2.256349836077009
F-2.822332528921274
tp5095
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5096
(F-2.695139300760798
F-2.8132799588716946
tp5097
sS'memoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5098
(F-4.250567892323369
F-2.7536553602952223
tp5099
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5100
(F-2.345260197937253
F-2.843373812161959
tp5101
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5102
(F-2.2240611948865525
F-2.877809084378756
tp5103
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5104
(F-2.483064991752762
F-2.670808645395132
tp5105
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5106
(F-2.9062061494993934
F-2.6925348135141225
tp5107
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5108
(F-3.031349116920406
F-2.8136444091796875
tp5109
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5110
(F-2.29275911318924
F-2.8071658794696512
tp5111
sS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5112
(F-2.4861286899499726
F-3.0486925565279446
tp5113
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5114
(F-1.843464460529265
F-2.8439865112304688
tp5115
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p5116
(F-1.5988291331699915
F-2.7015034602238583
tp5117
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5118
(F-2.987386403990186
F-2.8112525939941406
tp5119
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5120
(F-2.4752668317731796
F-2.7999484722430887
tp5121
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5122
(F-2.2685383087998137
F-2.8239986713115988
tp5123
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5124
(F-2.2245113896388635
F-2.8554036067082333
tp5125
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5126
(F-2.4966257880715763
F-2.63948733990009
tp5127
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5128
(F-1.9251744038349874
F-2.7628106337327223
tp5129
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5130
(F-2.9623231051260963
F-2.8255081176757812
tp5131
sS'pythoncom.CoInitialize()\nx = winmem()'
p5132
(F-2.5273143223353793
F-2.7169635479266825
tp5133
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5134
(F-2.6782159895097695
F-2.862791794996995
tp5135
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5136
(F-2.05123127559651
F-2.704061361459585
tp5137
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5138
(F-2.6728221136308368
F-2.8095488915076623
tp5139
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5140
(F-2.851646794972242
F-2.7075650141789365
tp5141
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5142
(F-2.1629442377905153
F-2.692414797269381
tp5143
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5144
(F-3.0510204347789798
F-2.767682882455679
tp5145
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5146
(F-3.048750983344184
F-3.03220455463116
tp5147
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5148
(F-2.0304421914590374
F-2.60602540236253
tp5149
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5150
(F-2.5635015869140627
F-2.557940263014573
tp5151
sS'import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p5152
(F-2.616719055175781
F-2.600826850304237
tp5153
sS'perf_object_list = self.supported_types.keys()'
p5154
(F-2.637668385225184
F-3.02452146089994
tp5155
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5156
(F-1.912118338204764
F-2.699544173020583
tp5157
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5158
(F-2.4525250575339146
F-2.779119931734525
tp5159
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5160
(F-2.9638936630147974
F-2.8240438608022838
tp5161
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5162
(F-2.6726897483648258
F-2.783428192138672
tp5163
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5164
(F-3.183581316912616
F-2.8129395705003004
tp5165
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5166
(F-2.487952181824252
F-2.644977569580078
tp5167
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5168
(F-2.5097638910466973
F-2.803656064547025
tp5169
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5170
(F-3.345652510480183
F-2.886066436767578
tp5171
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5172
(F-2.538637056632384
F-2.7810880220853367
tp5173
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5174
(F-2.9004694452348923
F-2.6916753328763523
tp5175
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5176
(F-2.9825477451665856
F-2.7830845759465146
tp5177
sS'print result_dict'
p5178
(F-3.822204271952311
F-2.8172953679011417
tp5179
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5180
(F-1.9042675863176384
F-2.653856717623197
tp5181
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5182
(F-2.6593306821034135
F-2.8514483525202823
tp5183
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5184
(F-2.981026427386558
F-2.84894767174354
tp5185
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5186
(F-2.092633056640625
F-2.636310870830829
tp5187
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5188
(F-2.515071303971851
F-2.6527325556828427
tp5189
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5190
(F-2.042961830316588
F-2.777545928955078
tp5191
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5192
(F-1.9090867741092754
F-2.697832547701322
tp5193
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5194
(F-1.9224352299772351
F-2.7615121694711537
tp5195
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5196
(F-3.144180118336397
F-2.8485679626464844
tp5197
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5198
(F-2.6270500138138506
F-2.7953544029822717
tp5199
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5200
(F-2.4805775311649496
F-2.784990750826322
tp5201
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5202
(F-2.6601591671214386
F-2.8561201829176683
tp5203
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5204
(F-2.4340195860406353
F-2.830140920785757
tp5205
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p5206
(F-1.0981410435267858
F-2.8182015052208533
tp5207
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5208
(F-2.136069542723275
F-2.876591609074519
tp5209
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5210
(F-2.6618871554522445
F-2.8023367661696215
tp5211
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5212
(F-1.6927706763857886
F-2.6209766681377706
tp5213
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5214
(F-2.739512794896176
F-2.5846334604116588
tp5215
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5216
(F-2.24341932635441
F-2.7760097797100363
tp5217
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p5218
(F-3.109598913858103
F-2.820247063269982
tp5219
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5220
(F-2.2251617365441976
F-2.650225419264573
tp5221
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5222
(F-1.5702393546937004
F-2.5829297579251804
tp5223
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p5224
(F-2.7675914978713134
F-2.85820066011869
tp5225
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5226
(F-2.746185009296124
F-2.680460709791917
tp5227
sS"'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5228
(F-2.668055852254232
F-2.686055990365835
tp5229
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5230
(F-2.392784318673923
F-2.746474339411809
tp5231
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5232
(F-2.4929167918669872
F-2.6397162217360277
tp5233
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5234
(F-3.0407011041230563
F-2.8033077533428488
tp5235
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5236
(F-2.49395165429101
F-2.6719818115234375
tp5237
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5238
(F-2.278701945596895
F-2.642589862530048
tp5239
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5240
(F-2.709073301938934
F-2.841512533334585
tp5241
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5242
(F-2.2404182211866654
F-2.8586258521446815
tp5243
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5244
(F-2.0906923208663715
F-2.584995856651893
tp5245
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5246
(F-2.164564510024983
F-2.817052987905649
tp5247
sS'from ctypes import *\nfrom ctypes.wintypes import *'
p5248
(F-2.2194508772629957
F-2.5846114525428185
tp5249
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5250
(F-2.962652798356681
F-2.8350472083458533
tp5251
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5252
(F-2.671707411943856
F-2.801412142240084
tp5253
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p5254
(F-3.004439609502655
F-2.7483602670522838
tp5255
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5256
(F-2.8453072684151786
F-2.8004203209510217
tp5257
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]'
p5258
(F-1.6170891655815973
F-2.5637603172889123
tp5259
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5260
(F-2.6886582485465116
F-2.8372418330265927
tp5261
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5262
(F-2.909580115116004
F-2.9619630666879506
tp5263
sS'print psutil.virtual_memory()'
p5264
(F-4.7575828552246096
F-2.6280103830190806
tp5265
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5266
(F-3.8807132427509012
F-2.640386728140024
tp5267
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5268
(F-3.066260060956401
F-2.6227073669433594
tp5269
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5270
(F-2.230445174188573
F-2.7722804729755106
tp5271
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5272
(F-2.626312632619599
F-2.798328399658203
tp5273
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5274
(F-2.3298573390501724
F-2.6599256075345554
tp5275
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5276
(F-2.3528233258372757
F-2.7008884136493387
tp5277
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5278
(F-2.0302924638913002
F-2.811971224271334
tp5279
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())\nprint(psutil.virtual_memory())'
p5280
(F-2.7672193254743305
F-2.5662501408503604
tp5281
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5282
(F-2.7233376406393877
F-2.8158079294057994
tp5283
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5284
(F-2.5226563570792213
F-2.709840627817007
tp5285
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5286
(F-2.686574078988338
F-2.593247340275691
tp5287
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5288
(F-2.9735823600522933
F-2.8956821148212137
tp5289
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p5290
(F-3.6603467217807113
F-2.8737000685471754
tp5291
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p5292
(F-2.6370778577081087
F-2.658691699688251
tp5293
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5294
(F-2.4342967649886265
F-2.6544309762807994
tp5295
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5296
(F-2.6264051649305555
F-2.7186660766601562
tp5297
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5298
(F-2.9246624668249104
F-2.7356573251577525
tp5299
sS'from ctypes.wintypes import *\nimport pythoncom'
p5300
(F-3.447778181596236
F-2.570058382474459
tp5301
sS'break\nif found_flag:\n    pass'
p5302
(F-3.296528155987079
F-2.5939190204326925
tp5303
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5304
(F-2.4695286260587035
F-2.85537837101863
tp5305
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5306
(F-2.5752416892808685
F-2.693910158597506
tp5307
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5308
(F-2.467309454606043
F-2.6607756981482873
tp5309
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5310
(F-2.959880383486675
F-2.825029813326322
tp5311
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5312
(F-2.4517022705078126
F-2.656084794264573
tp5313
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5314
(F-3.1812776077625364
F-2.8439862177922177
tp5315
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5316
(F-2.6708119165718682
F-2.8454355093149037
tp5317
sS'pid = os.getpid()'
p5318
(F-1.8059185875786676
F-2.6098163311298075
tp5319
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5320
(F-3.1335814980899586
F-2.6797872690054088
tp5321
sS'continue'
p5322
(F-4.67288875579834
F-2.7974495520958533
tp5323
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5324
(F-2.311990028570506
F-2.8097179119403544
tp5325
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5326
(F-3.123658165564904
F-2.8154974717360277
tp5327
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5328
(F-2.937261647191541
F-2.6940633333646336
tp5329
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p5330
(F-2.547093031141493
F-2.7103271484375
tp5331
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5332
(F-2.6378320004759717
F-2.832551516019381
tp5333
sS'import pythoncom'
p5334
(F-3.666597604751587
F-2.5794554490309496
tp5335
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5336
(F-2.771580746299342
F-2.9427836491511417
tp5337
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5338
(F-2.0569935892964457
F-2.573194063626803
tp5339
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5340
(F-2.6546638855246996
F-2.8441053537222056
tp5341
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5342
(F-2.578233446393694
F-2.871551220233624
tp5343
sS'self.filter_list = filter_list'
p5344
(F-3.730566544966264
F-3.2928211505596456
tp5345
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5346
(F-2.8961337107532428
F-2.800724616417518
tp5347
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5348
(F-2.6688958313239453
F-2.8267522958608775
tp5349
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5350
(F-2.7423294915093317
F-2.9252891540527344
tp5351
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5352
(F-1.5875928438626803
F-2.5404845017653246
tp5353
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5354
(F-2.6349241693335843
F-2.818110539362981
tp5355
sS'pythoncom.CoInitialize()'
p5356
(F-1.3966916799545288
F-2.7043944138746996
tp5357
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p5358
(F-3.2904586791992188
F-2.765909928541917
tp5359
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5360
(F-2.3875523903191724
F-2.822637998140775
tp5361
sS'import pythoncom\nimport pywintypes\nimport datetime'
p5362
(F-3.1690303802490236
F-2.5514403123121996
tp5363
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5364
(F-2.618843211794732
F-2.8435469407301683
tp5365
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5366
(F-2.7182468204047736
F-2.840861100416917
tp5367
sS'x = MEMORYSTATUS()'
p5368
(F-1.8516908373151506
F-2.6882779048039365
tp5369
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5370
(F-2.406788712840969
F-2.862804412841797
tp5371
sS"'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p5372
(F-2.668055852254232
F-2.686055990365835
tp5373
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5374
(F-2.9279356260557434
F-2.684461446908804
tp5375
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5376
(F-2.4745704297545026
F-2.64578129695012
tp5377
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5378
(F-2.8889793539946935
F-2.9160904517540565
tp5379
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5380
(F-1.3783051924272016
F-2.574903048001803
tp5381
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5382
(F-2.9712325386379077
F-2.9480772752028246
tp5383
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5384
(F-2.3774249241824896
F-2.8504439133864183
tp5385
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5386
(F-2.459096687340811
F-2.8158619220440206
tp5387
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5388
(F-3.0987884047117875
F-2.83479983990009
tp5389
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5390
(F-1.998177045657311
F-2.5838100726787863
tp5391
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5392
(F-3.048925080367823
F-2.8070734464205227
tp5393
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5394
(F-2.0173395330255683
F-2.7723362262432394
tp5395
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5396
(F-2.7820116678873696
F-2.97085688664363
tp5397
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5398
(F-2.2547750608615966
F-2.825645740215595
tp5399
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5400
(F-2.920432479293258
F-2.6445641150841346
tp5401
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5402
(F-2.5486349370275625
F-2.7887329688439
tp5403
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5404
(F-2.436737462850165
F-2.6696859506460338
tp5405
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5406
(F-2.9298277849926375
F-2.6875850970928488
tp5407
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5408
(F-2.3523200181667914
F-2.6312511150653544
tp5409
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5410
(F-3.0801248301630433
F-2.809744908259465
tp5411
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5412
(F-2.617573250969537
F-2.80604494535006
tp5413
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5414
(F-2.4988548197023355
F-2.6586834834172177
tp5415
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5416
(F-2.8346092299659653
F-2.8963473393366885
tp5417
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5418
(F-2.258542273928959
F-2.7136465219350963
tp5419
sS'windll.kernel32.GlobalMemoryStatus(byref(x))'
p5420
(F-1.9566070556640625
F-2.770201462965745
tp5421
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5422
(F-0.8549948511896907
F-2.793545356163612
tp5423
sS'if (not self.process_name_list):\n    pass'
p5424
(F-2.6751700507269964
F-2.680629143348107
tp5425
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5426
(F-1.666955810546875
F-2.5693846482496996
tp5427
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5428
(F-3.387069300601357
F-2.7067284217247596
tp5429
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5430
(F-2.9695731026785714
F-2.575318556565505
tp5431
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5432
(F-2.186028706658747
F-2.61246578509991
tp5433
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5434
(F-2.4575521316301927
F-2.853804661677434
tp5435
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p5436
(F-2.4625528372970282
F-2.703393789438101
tp5437
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5438
(F-2.2119327374358675
F-2.832499284010667
tp5439
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list"
p5440
(F-2.794650309794658
F-2.8869552612304688
tp5441
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5442
(F-2.4635858084599307
F-2.7753061147836537
tp5443
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5444
(F-2.951938348067434
F-2.7818899888258715
tp5445
sS'from ctypes import *'
p5446
(F-2.9157158533732095
F-2.592381110558143
tp5447
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5448
(F-2.3948583108970367
F-2.8627163813664365
tp5449
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5450
(F-2.43648187233983
F-2.8090424170860877
tp5451
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5452
(F-1.4561711064091436
F-2.564972217266376
tp5453
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5454
(F-2.617017814911992
F-2.72059572660006
tp5455
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5456
(F-1.8017125772246232
F-2.576456510103666
tp5457
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5458
(F-2.6642279373972038
F-2.8321207486666164
tp5459
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5460
(F-2.5007399890395594
F-2.648838923527644
tp5461
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5462
(F-2.4580963652012713
F-2.759746844951923
tp5463
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5464
(F-2.0988183249889967
F-2.5956315260667067
tp5465
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5466
(F-2.6044746167732007
F-2.836122366098257
tp5467
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5468
(F-2.887097123740376
F-2.746217580942007
tp5469
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5470
(F-3.2612146650041853
F-2.5659719613882213
tp5471
sS'print psutil.cpu_percent()\nprint psutil.virtual_memory()'
p5472
(F-4.040936921772204
F-2.5553597670335035
tp5473
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"'
p5474
(F-2.668055852254232
F-2.686055990365835
tp5475
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p5476
(F-2.4919634501139325
F-2.6385753338153544
tp5477
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5478
(F-2.9778209867931547
F-2.8680326021634617
tp5479
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5480
(F-2.3185197518959204
F-2.753113966721755
tp5481
sS'__revision__ = 3\nimport win32com.client'
p5482
(F-3.511378606160482
F-2.738415938157302
tp5483
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5484
(F-2.6496534734634456
F-2.827122614933894
tp5485
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5486
(F-2.490001917672236
F-2.647649911733774
tp5487
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5488
(F-2.6415431431361607
F-2.808499262883113
tp5489
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5490
(F-2.3893330891927085
F-2.851209200345553
tp5491
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5492
(F-1.8810177573674842
F-2.602176079383263
tp5493
sS'if (len(colItems) > 0):\n    for objItem in colItems:\n        found_flag = False'
p5494
(F-2.7937454715851815
F-2.8229942321777344
tp5495
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client'
p5496
(F-4.00154413495745
F-2.7177628737229567
tp5497
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5498
(F-2.8247631072998045
F-2.840892791748047
tp5499
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5500
(F-2.633012568486201
F-2.851944850041316
tp5501
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5502
(F-2.4971476914121595
F-2.68455564058744
tp5503
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5504
(F-2.9844858917124544
F-2.8396629920372596
tp5505
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p5506
(F-2.8544352604792667
F-2.707174154428335
tp5507
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5508
(F-3.19862233037534
F-2.626090123103215
tp5509
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5510
(F-2.64130376459478
F-2.843494708721454
tp5511
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5512
(F-2.5066578513697575
F-2.6409049400916467
tp5513
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5514
(F-2.9431605868869357
F-2.693073272705078
tp5515
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5516
(F-2.5431746143405722
F-2.8128890991210938
tp5517
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5518
(F-2.12633504547198
F-2.64981930072491
tp5519
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5520
(F-1.1050281524658203
F-2.7957209073580227
tp5521
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p5522
(F-2.787329640107996
F-2.8558402428260217
tp5523
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p5524
(F-2.9067471737893213
F-2.8162369361290565
tp5525
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p5526
(F-3.0177018185879323
F-2.878763639009916
tp5527
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p5528
(F-3.0416843045142388
F-2.6895235501802883
tp5529
sS"print 'this proc results:'\nprint this_proc_results"
p5530
(F-3.531865206631747
F-2.6668055607722354
tp5531
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5532
(F-2.4519106296819095
F-2.7725243201622596
tp5533
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5534
(F-2.569788067157452
F-2.8530496450570912
tp5535
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5536
(F-1.7723117914414943
F-2.7675352830153246
tp5537
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5538
(F-2.9387600999006724
F-2.8283039973332333
tp5539
sS'this_proc_dict[attribute] = eval(eval_str)'
p5540
(F-4.047181073357077
F-3.0790170522836537
tp5541
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5542
(F-2.7077783203125
F-2.8124929574819713
tp5543
sS'proc_results_list = []'
p5544
(F-3.1651065826416014
F-2.7866671635554385
tp5545
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5546
(F-2.466424009138921
F-2.6798260028545675
tp5547
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True'
p5548
(F-2.871309834141885
F-2.9195277874286356
tp5549
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5550
(F-2.131259693818934
F-2.6271702693058896
tp5551
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5552
(F-2.908082265702505
F-2.8427822406475363
tp5553
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5554
(F-3.060087203979492
F-3.007364419790415
tp5555
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5556
(F-2.940332645992581
F-2.7794840886042667
tp5557
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5558
(F-2.4648993933579946
F-2.7746473459097056
tp5559
sS'proc_results = stats_processor.get_stats()'
p5560
(F-1.810340118408203
F-2.720995389498197
tp5561
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5562
(F-2.6649806939282463
F-2.845703418438251
tp5563
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5564
(F-2.509828893149771
F-2.7206817040076623
tp5565
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5566
(F-2.826304210316051
F-2.9463107769305887
tp5567
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5568
(F-2.4911605342741936
F-2.8752508897047777
tp5569
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5570
(F-2.9236238292841246
F-2.8056617149939904
tp5571
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5572
(F-2.24393470008094
F-2.7728148240309496
tp5573
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5574
(F-2.8145279857993786
F-2.8703067486102762
tp5575
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5576
(F-1.7534576143537248
F-2.6218314537635217
tp5577
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5578
(F-2.5097152124815634
F-2.672803438626803
tp5579
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5580
(F-2.25118095584032
F-2.7901939978966346
tp5581
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5582
(F-2.9271271216687818
F-2.9376185490534854
tp5583
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5584
(F-2.444901365305877
F-2.766705733079177
tp5585
sS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5586
(F-2.544956922531128
F-2.9521108774038463
tp5587
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5588
(F-2.422259233129306
F-2.816679147573618
tp5589
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5590
(F-2.6574782921523643
F-2.8320817213792067
tp5591
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5592
(F-1.5101432800292969
F-2.554188948411208
tp5593
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5594
(F-1.4661265781947546
F-2.5683643634502706
tp5595
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p5596
(F-2.9041732788085937
F-2.720733349139874
tp5597
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5598
(F-2.6632080078125
F-2.856417729304387
tp5599
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5600
(F-1.6314009956691575
F-2.673990689791166
tp5601
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5602
(F-2.8209449029737903
F-2.8134677593524637
tp5603
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5604
(F-2.602402687072754
F-2.8927571223332333
tp5605
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5606
(F-2.335031789499563
F-2.841612302339994
tp5607
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5608
(F-2.514915846150427
F-2.80951896080604
tp5609
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5610
(F-2.283168320885744
F-2.6442137498121996
tp5611
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5612
(F-2.9084961502640336
F-2.8238868713378906
tp5613
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5614
(F-2.6343215630978953
F-2.8276302631084738
tp5615
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5616
(F-2.464213274527287
F-2.8391791123610277
tp5617
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5618
(F-2.8658581437735724
F-2.7714256873497596
tp5619
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p5620
(F-3.0377016934481533
F-2.7303120539738583
tp5621
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5622
(F-2.0078950068073085
F-2.8091366107647238
tp5623
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    pass'
p5624
(F-1.5704421997070312
F-2.558452312762921
tp5625
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5626
(F-2.7709841918945313
F-2.84567378117488
tp5627
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5628
(F-3.149195620888158
F-2.8183021545410156
tp5629
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5630
(F-3.0216355935121193
F-2.743128849909856
tp5631
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5632
(F-2.0676112374859654
F-2.8705321091871996
tp5633
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5634
(F-2.1236050992398647
F-2.711793752817007
tp5635
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5636
(F-2.218408667522928
F-2.615468245286208
tp5637
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5638
(F-2.470168581434116
F-2.6733316274789662
tp5639
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5640
(F-2.443706237617075
F-2.8549085763784556
tp5641
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5642
(F-2.3064231405452804
F-2.653441209059495
tp5643
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5644
(F-2.465648967958368
F-2.6690022395207333
tp5645
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5646
(F-3.0055146650834517
F-2.6907119750976562
tp5647
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5648
(F-2.4653848521347954
F-2.7714911240797777
tp5649
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5650
(F-2.454777155002626
F-2.668773944561298
tp5651
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5652
(F-2.395199973366477
F-2.873522538405198
tp5653
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5654
(F-2.028507532698385
F-2.6958624032827525
tp5655
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5656
(F-2.4702570511122883
F-2.706638923058143
tp5657
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5658
(F-2.049201674475348
F-2.7920614389272838
tp5659
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5660
(F-1.0984958199893726
F-2.7242058974045973
tp5661
sS'proc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5662
(F-2.3860840974030673
F-2.9520313556377706
tp5663
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5664
(F-2.6616506865530303
F-2.8213782677283654
tp5665
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5666
(F-2.1192902971984475
F-2.796187474177434
tp5667
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p5668
(F-1.9553106275655456
F-2.9398404634915867
tp5669
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5670
(F-2.685717438998288
F-2.818266061636118
tp5671
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5672
(F-2.817579650878906
F-2.9518007131723256
tp5673
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5674
(F-2.4553201127094355
F-2.7060077373798075
tp5675
sS"_fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5676
(F-1.2337804723668981
F-2.8631424537071815
tp5677
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5678
(F-2.189067591374843
F-2.61420411330003
tp5679
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5680
(F-2.454964621025219
F-2.814644740178035
tp5681
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5682
(F-2.8659581502278644
F-2.641540820782001
tp5683
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5684
(F-2.327120304107666
F-2.8526215186485877
tp5685
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5686
(F-2.0885821350263964
F-2.609576885516827
tp5687
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5688
(F-2.4562359667199805
F-2.8153434166541467
tp5689
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5690
(F-2.4819601486746414
F-2.8075637817382812
tp5691
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5692
(F-1.2129518260126528
F-2.5267894451434794
tp5693
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p5694
(F-2.934486037034255
F-2.7233411348783054
tp5695
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5696
(F-0.890141120323768
F-2.8039386455829325
tp5697
sS'def get_sys_stats():\n    pass'
p5698
(F-1.8298851013183595
F-2.6064878610464244
tp5699
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5700
(F-2.36213304169324
F-2.9233052180363583
tp5701
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5702
(F-2.999968584846048
F-2.8174080481896033
tp5703
sS'import psutil\nprint psutil.cpu_percent()\nprint psutil.virtual_memory()'
p5704
(F-3.5318645130504263
F-2.5402025076059194
tp5705
sS'this_proc_dict = {}'
p5706
(F-3.7437564849853517
F-3.089820568378155
tp5707
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5708
(F-2.657349255620217
F-2.840724064753606
tp5709
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5710
(F-2.956594310087316
F-2.9135636549729567
tp5711
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5712
(F-1.4748469302528784
F-2.6648712158203125
tp5713
sS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5714
(F-2.641986687978109
F-2.93455564058744
tp5715
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5716
(F-1.924942797768238
F-2.7974759615384617
tp5717
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5718
(F-1.1834012545072115
F-2.5519564701960635
tp5719
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5720
(F-2.4834747314453125
F-2.7077677800105167
tp5721
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5722
(F-2.0012382058536304
F-2.574109297532302
tp5723
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5724
(F-2.125981077855947
F-2.624315408559946
tp5725
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5726
(F-2.876775799375592
F-2.6527073199932394
tp5727
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5728
(F-2.894249922392384
F-2.6902615473820615
tp5729
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5730
(F-1.9151910921422446
F-2.6046905517578125
tp5731
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5732
(F-2.6646712764616933
F-2.8480958205003004
tp5733
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5734
(F-2.8954764146071215
F-2.811952150785006
tp5735
sS'return this_proc_dict'
p5736
(F-3.6175084114074707
F-3.0290069580078125
tp5737
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5738
(F-2.543088321797332
F-2.6700518681452823
tp5739
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p5740
(F-3.3687790851203765
F-2.998212667611929
tp5741
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5742
(F-2.177366256713867
F-2.6211539048414965
tp5743
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5744
(F-2.559842727386009
F-2.731268075796274
tp5745
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5746
(F-3.0548442544972323
F-2.838537362905649
tp5747
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5748
(F-2.9986562093098956
F-2.857721182016226
tp5749
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5750
(F-3.361969596461246
F-2.9399199852576623
tp5751
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5752
(F-2.6592872256324407
F-2.8381453294020433
tp5753
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5754
(F-2.872366315367594
F-2.766132648174579
tp5755
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5756
(F-2.654063995473939
F-2.8495442317082333
tp5757
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5758
(F-2.1655241500499636
F-2.86823478111854
tp5759
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5760
(F-2.9990575292088963
F-2.8517511807955227
tp5761
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5762
(F-2.9574344648301394
F-2.8444973872258115
tp5763
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5764
(F-2.374328734623509
F-2.6251561091496396
tp5765
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p5766
(F-2.6236974928114147
F-2.6419786306527944
tp5767
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5768
(F-1.901139920075192
F-2.6803811880258412
tp5769
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p5770
(F-3.0827324761284722
F-2.8073161198542667
tp5771
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5772
(F-1.9792870914234835
F-2.8596446697528544
tp5773
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5774
(F-2.060645751953125
F-2.8119744520920973
tp5775
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5776
(F-2.6559749275311084
F-2.8523468604454627
tp5777
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5778
(F-1.9630192985311585
F-2.6074705857496996
tp5779
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5780
(F-2.2170118713378906
F-2.607613490178035
tp5781
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5782
(F-2.9987571433738425
F-2.832317058856671
tp5783
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5784
(F-2.535104433695475
F-2.886608417217548
tp5785
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5786
(F-1.0966932079460048
F-2.693849416879507
tp5787
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5788
(F-3.1690493265787762
F-2.674589597261869
tp5789
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5790
(F-2.9105892181396484
F-2.65902827336238
tp5791
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5792
(F-2.877745799529247
F-2.8763917776254506
tp5793
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5794
(F-2.7144661633344533
F-2.816854330209585
tp5795
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5796
(F-2.1648902723524306
F-2.6237772428072414
tp5797
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5798
(F-2.167971445058847
F-2.610748584453876
tp5799
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5800
(F-2.92969970703125
F-2.698465494009165
tp5801
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5802
(F-2.54880204014272
F-2.690426459679237
tp5803
sS'sys_dict = get_sys_stats()'
p5804
(F-3.753117194542518
F-2.7307903583233175
tp5805
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p5806
(F-2.0148611068725586
F-2.7038201552170973
tp5807
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5808
(F-2.640042947645506
F-2.8378562927246094
tp5809
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5810
(F-2.3629712266612137
F-2.8558329068697414
tp5811
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p5812
(F-3.047928704155816
F-2.897296905517578
tp5813
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5814
(F-2.6465396148989897
F-2.799336653489333
tp5815
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5816
(F-2.007428326764264
F-2.839088146503155
tp5817
sS'found_flag = False'
p5818
(F-3.7857328142438615
F-2.7051620483398438
tp5819
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()"
p5820
(F-2.6634073672087295
F-2.8894935021033654
tp5821
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5822
(F-3.649377610948351
F-2.8749471811147838
tp5823
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5824
(F-1.960238033209365
F-2.691632784329928
tp5825
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5826
(F-2.1211125424033717
F-2.8243191058819113
tp5827
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5828
(F-2.2220679111168034
F-2.806817568265475
tp5829
sS'self.perf_object_list = perf_object_list'
p5830
(F-2.9780784606933595
F-2.804858867938702
tp5831
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5832
(F-2.2192277174729567
F-2.6115573002741885
tp5833
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5834
(F-1.2456244009512443
F-2.533482184776893
tp5835
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5836
(F-3.227605885472791
F-2.635883037860577
tp5837
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5838
(F-2.52716064453125
F-2.711183401254507
tp5839
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5840
(F-1.9184392718567098
F-2.7482534555288463
tp5841
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5842
(F-2.710768684068739
F-2.823132735032302
tp5843
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5844
(F-1.2750262347134678
F-2.5988200261042667
tp5845
sS'return sys_dict'
p5846
(F-5.303182601928711
F-2.8384713392991285
tp5847
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5848
(F-1.9785223216472374
F-2.83086424607497
tp5849
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5850
(F-1.3680144519340702
F-2.56546137883113
tp5851
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5852
(F-2.0939556884765627
F-2.8000637934758115
tp5853
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5854
(F-2.647628039848514
F-2.8492061908428488
tp5855
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p5856
(F-2.8898640508237095
F-2.7256898146409254
tp5857
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5858
(F-2.9396168859929985
F-2.932413247915415
tp5859
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5860
(F-2.9175818593878495
F-2.7941812368539662
tp5861
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5862
(F-2.5074101498252466
F-2.6416109525240383
tp5863
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5864
(F-2.58169916624664
F-2.768433790940505
tp5865
sS'py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5866
(F-3.869373083114624
F-2.60911618746244
tp5867
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5868
(F-1.9455538169344972
F-2.8045020470252404
tp5869
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p5870
(F-2.9425179910339767
F-2.80754881638747
tp5871
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5872
(F-2.668380073879076
F-2.8104893611027646
tp5873
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5874
(F-2.463448337277821
F-2.6669672452486477
tp5875
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5876
(F-2.5761456233198925
F-2.7669889009915867
tp5877
sS'"process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5878
(F-2.6680564880371094
F-2.686055990365835
tp5879
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5880
(F-2.900821261935764
F-2.920683347261869
tp5881
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p5882
(F-2.5909652709960938
F-2.9412049513596754
tp5883
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5884
(F-2.59514019845546
F-2.790576934814453
tp5885
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5886
(F-2.1903922689619977
F-2.8466796875
tp5887
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5888
(F-2.839432475722839
F-2.6794556837815504
tp5889
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5890
(F-1.3183446667858005
F-2.7151407095102162
tp5891
sS'for attribute in self.supported_types[counter_type]:\n    pass'
p5892
(F-3.4291221618652346
F-2.8329373873197117
tp5893
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5894
(F-1.9487770774147728
F-2.8550192025991588
tp5895
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5896
(F-2.3858929925767827
F-2.824416233943059
tp5897
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5898
(F-2.77687913544324
F-2.7154370821439304
tp5899
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5900
(F-3.0463672984730112
F-2.770634577824519
tp5901
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5902
(F-2.673111099380631
F-2.8508981557992787
tp5903
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5904
(F-1.9700545298902294
F-2.7587145291841946
tp5905
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5906
(F-2.2511529181985295
F-2.788938669057993
tp5907
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5908
(F-2.717673896943163
F-2.8158111572265625
tp5909
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5910
(F-3.013392857142857
F-2.802324735201322
tp5911
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5912
(F-2.62769721707696
F-2.843416067270132
tp5913
sS'for objItem in colItems:\n    pass'
p5914
(F-2.4027874286358175
F-2.833315922663762
tp5915
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5916
(F-2.5208444306344697
F-2.6414369436410756
tp5917
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5918
(F-2.5064479157285664
F-2.6742688692533054
tp5919
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5920
(F-2.439522487923683
F-2.8050076411320615
tp5921
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5922
(F-2.7913848414565576
F-2.8731856712928185
tp5923
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5924
(F-2.73959765625
F-2.931783529428335
tp5925
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5926
(F-2.664314332047129
F-2.8344095670259914
tp5927
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5928
(F-1.954030428001349
F-2.8189747150127706
tp5929
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5930
(F-2.0773802966606327
F-2.7513639009915867
tp5931
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5932
(F-3.0315398087738252
F-2.8007736206054688
tp5933
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p5934
(F-3.747867785002056
F-2.659086374136118
tp5935
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5936
(F-2.6418922928604744
F-2.851056905893179
tp5937
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5938
(F-2.947219958408273
F-2.7815272991473856
tp5939
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5940
(F-2.4884553502817623
F-2.8354729872483473
tp5941
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5942
(F-3.154116675967262
F-2.805377666766827
tp5943
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5944
(F-2.8651076982606134
F-2.7621829693134012
tp5945
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5946
(F-2.2447748598845108
F-2.8388313880333533
tp5947
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5948
(F-1.352612333477668
F-2.6403738168569713
tp5949
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5950
(F-2.916186665379724
F-2.7957044748159556
tp5951
sS'break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p5952
(F-3.354034423828125
F-2.6935052138108473
tp5953
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5954
(F-2.450473167782738
F-2.769185286301833
tp5955
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5956
(F-2.474278689168924
F-2.7734031677246094
tp5957
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5958
(F-2.967323953791182
F-2.831525655893179
tp5959
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5960
(F-2.4581010148331925
F-2.812566903921274
tp5961
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5962
(F-2.6973958488639074
F-2.896636669452374
tp5963
sS'from ctypes.wintypes import *'
p5964
(F-3.829901695251465
F-2.5827290461613583
tp5965
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5966
(F-2.6525242430690663
F-2.844844231238732
tp5967
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5968
(F-1.9612843631918913
F-2.7630591759314904
tp5969
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5970
(F-2.898155842352351
F-2.8081571138822117
tp5971
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5972
(F-2.592635827561829
F-2.8345052278958836
tp5973
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5974
(F-2.153521484375
F-2.7664252061110277
tp5975
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5976
(F-2.1754693530854725
F-2.6243984515850363
tp5977
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p5978
(F-3.0248392039331895
F-2.9291141216571512
tp5979
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5980
(F-2.6869258880615234
F-2.80287845318134
tp5981
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5982
(F-2.497682275551774
F-2.708370795616737
tp5983
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5984
(F-1.095306396484375
F-2.6789166377140927
tp5985
sS'class MEMORYSTATUS(Structure):\n    pass'
p5986
(F-1.289842923482259
F-2.688449272742638
tp5987
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5988
(F-2.223237219522166
F-2.6465066763070912
tp5989
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5990
(F-2.421604477878892
F-2.870518611027644
tp5991
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5992
(F-3.0090439740349266
F-2.696079841026893
tp5993
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5994
(F-2.3633626302083335
F-2.8550743689903846
tp5995
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5996
(F-1.3636032104492188
F-2.7050452599158654
tp5997
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5998
(F-2.251351354343821
F-2.7858053354116588
tp5999
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p6000
(F-2.602491850011489
F-2.8054046630859375
tp6001
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6002
(F-2.665973531788793
F-2.816202897291917
tp6003
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p6004
(F-3.032819664996603
F-2.864198244535006
tp6005
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6006
(F-2.122651703503667
F-2.8610379145695615
tp6007
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p6008
(F-2.5818501036844137
F-2.7753771268404446
tp6009
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p6010
(F-2.5171755437981593
F-2.7579759451059194
tp6011
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p6012
(F-2.526985929340044
F-2.8305109464205227
tp6013
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p6014
(F-1.906396484375
F-2.8346757155198317
tp6015
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p6016
(F-2.9911627789589925
F-2.828353001521184
tp6017
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p6018
(F-1.3214003245035808
F-2.571941375732422
tp6019
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6020
(F-2.513006383207188
F-2.6766116802509012
tp6021
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p6022
(F-2.6577259683843906
F-2.798624185415415
tp6023
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p6024
(F-2.306639350779619
F-2.637564732478215
tp6025
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6026
(F-2.6783369946617084
F-2.802220271183894
tp6027
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p6028
(F-2.6738637390750752
F-2.841631375826322
tp6029
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p6030
(F-2.194037426477191
F-2.898327167217548
tp6031
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6032
(F-3.035435711895978
F-2.887056203988882
tp6033
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6034
(F-2.5391439383370535
F-2.6721549400916467
tp6035
sS'def get_stats(self):\n    pass'
p6036
(F-1.383709226335798
F-2.62322264451247
tp6037
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6038
(F-2.684233270974523
F-2.8124454204852762
tp6039
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6040
(F-2.301938896937086
F-2.638959444486178
tp6041
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6042
(F-3.1483154296875
F-3.1895423302283654
tp6043
sS'this_pid = os.getpid()'
p6044
(F-2.6795387268066406
F-2.5877324617826023
tp6045
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p6046
(F-2.974364997804627
F-2.8718995314378004
tp6047
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6048
(F-2.747175852457682
F-2.8645395132211537
tp6049
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p6050
(F-2.4426974672259707
F-2.6330035283015323
tp6051
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6052
(F-2.678838444852281
F-2.838714306171124
tp6053
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p6054
(F-2.4436793438622084
F-2.773753826434796
tp6055
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6056
(F-2.768407393474968
F-2.871562664325421
tp6057
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p6058
(F-2.8448050362723216
F-2.7082123389610877
tp6059
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6060
(F-2.874829319545201
F-2.8370305574857273
tp6061
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6062
(F-2.467382226286635
F-2.817067659818209
tp6063
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6064
(F-2.167883782637747
F-2.7245013897235575
tp6065
sS'for objItem in colItems:\n    found_flag = False'
p6066
(F-2.860467798569623
F-2.8735377971942606
tp6067
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p6068
(F-2.678971290588379
F-2.836114443265475
tp6069
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6070
(F-3.013431987695993
F-2.832165057842548
tp6071
sS'for result_dict in proc_results:\n    pass'
p6072
(F-2.7971338907877605
F-2.885197566105769
tp6073
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p6074
(F-3.200537248091264
F-2.7625101529634914
tp6075
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6076
(F-2.3534825051477712
F-2.9059454110952525
tp6077
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p6078
(F-2.9965758147063077
F-2.7169964130108175
tp6079
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6080
(F-2.66113044984879
F-2.84685310950646
tp6081
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6082
(F-1.6319999694824219
F-2.549417642446665
tp6083
sS'for result_dict in proc_results:\n    print result_dict\nimport os'
p6084
(F-3.653001694452195
F-2.847469916710487
tp6085
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p6086
(F-2.780165113844313
F-2.677761958195613
tp6087
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6088
(F-2.670077853732639
F-2.8325656010554385
tp6089
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p6090
(F-1.9639293181590545
F-2.5780340341421275
tp6091
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p6092
(F-2.404391334170387
F-2.759319305419922
tp6093
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6094
(F-2.764613820545709
F-2.9450196486253004
tp6095
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6096
(F-2.2517898033405173
F-2.7176055908203125
tp6097
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6098
(F-2.6539894571109692
F-2.81562012892503
tp6099
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p6100
(F-2.479355744701727
F-2.717077401968149
tp6101
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p6102
(F-2.480044693896995
F-2.8148472125713644
tp6103
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p6104
(F-2.6372110733133276
F-2.812846844012921
tp6105
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p6106
(F-2.6522886753082275
F-2.8568270756648135
tp6107
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6108
(F-2.4543100794929473
F-2.8189236567570615
tp6109
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p6110
(F-2.6682793112362133
F-2.828653775728666
tp6111
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p6112
(F-3.1590209007263184
F-2.6333896930401144
tp6113
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6114
(F-2.8929209768036266
F-2.9141916128305287
tp6115
sS'self.process_name_list = process_name_list'
p6116
(F-3.2400914510091146
F-2.658354245699369
tp6117
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6118
(F-2.2267424639533546
F-2.8437913747934194
tp6119
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p6120
(F-3.2682107778695912
F-2.639476776123047
tp6121
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p6122
(F-2.437512804578234
F-2.6668551518366885
tp6123
sS"import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p6124
(F-3.3212827794692097
F-2.6217997624323917
tp6125
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6126
(F-2.387526840065556
F-2.8076180678147535
tp6127
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6128
(F-2.9648504511892617
F-2.8838624220628004
tp6129
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6130
(F-2.8109899593304983
F-2.8517708411583533
tp6131
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    pass"
p6132
(F-3.644288804796007
F-2.557329324575571
tp6133
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p6134
(F-2.9558492993551586
F-2.875010270338792
tp6135
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6136
(F-2.7299777374004948
F-2.8468105609600363
tp6137
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    pass'
p6138
(F-2.8191830670392073
F-2.9267211327186
tp6139
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6140
(F-2.4791182648786596
F-2.774060762845553
tp6141
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p6142
(F-3.0759493699714318
F-2.9407119750976562
tp6143
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p6144
(F-2.091335559017444
F-2.579586615929237
tp6145
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p6146
(F-3.001667785644531
F-2.8253631591796875
tp6147
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6148
(F-2.879487317017835
F-2.7170639038085938
tp6149
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p6150
(F-2.4515660779229527
F-2.772107931283804
tp6151
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p6152
(F-2.6493394480935306
F-2.807970487154447
tp6153
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6154
(F-1.6782264709472656
F-2.646982633150541
tp6155
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p6156
(F-1.618197295625331
F-2.6549415588378906
tp6157
sS'proc_results_list.append(this_proc_dict)'
p6158
(F-2.9789724349975586
F-3.0830213106595554
tp6159
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p6160
(F-3.415229028509569
F-2.8567364032451925
tp6161
sS"py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint ('memory use:', memoryUse)"
p6162
(F-3.7370033264160156
F-2.597669161283053
tp6163
ssI5137497
(dp6164
S"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6165
(F-1.4391397094726563
F-3.6415695190429687
tp6166
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6167
(F-2.6680369657628678
F-3.5392635345458983
tp6168
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')"
p6169
(F-1.924542956882053
F-3.642903518676758
tp6170
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6171
(F-3.1252431869506836
F-3.562023162841797
tp6172
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6173
(F-2.157031368899655
F-3.5159400939941405
tp6174
sS"print 'This file directory and name'"
p6175
(F-2.838855504989624
F-3.9485309600830076
tp6176
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6177
(F-2.400282302705368
F-3.538720703125
tp6178
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6179
(F-1.9529977613879788
F-3.6031837463378906
tp6180
sS"print 'This file path, relative to os.getcwd()'"
p6181
(F-2.838855504989624
F-3.9485309600830076
tp6182
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6183
(F-2.5426005045572917
F-3.5345222473144533
tp6184
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p6185
(F-2.3016390119280135
F-3.6570674896240236
tp6186
sS'import os'
p6187
(F-3.833404064178467
F-3.626966857910156
tp6188
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6189
(F-2.4232664320203994
F-3.5401565551757814
tp6190
sS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6191
(F-3.1571502685546875
F-3.5577186584472655
tp6192
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6193
(F-2.2009254589415432
F-3.5797725677490235
tp6194
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6195
(F-2.6388094463045637
F-3.5598190307617186
tp6196
sS'dir_path = os.path.dirname(os.path.realpath(__file__))'
p6197
(F-0.7877948595129926
F-3.5813926696777343
tp6198
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6199
(F-2.391044334129051
F-3.7196510314941404
tp6200
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6201
(F-3.0250176323784723
F-3.5565635681152346
tp6202
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6203
(F-2.5727820763221154
F-3.8079811096191407
tp6204
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6205
(F-1.6325200733385588
F-3.596399688720703
tp6206
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6207
(F-2.515207354942065
F-3.5336509704589845
tp6208
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')"
p6209
(F-2.1565948486328126
F-3.7220176696777343
tp6210
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6211
(F-2.6402802643952548
F-3.7173091888427736
tp6212
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6213
(F-2.2082968698420995
F-3.519307327270508
tp6214
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6215
(F-1.683199337550572
F-3.596710968017578
tp6216
sS"import os\nprint 'Path at terminal when executing this file'"
p6217
(F-2.952539716448103
F-3.6556957244873045
tp6218
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6219
(F-2.464864557439631
F-3.673197555541992
tp6220
sS"print (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6221
(F-2.7672850085842993
F-3.640543746948242
tp6222
sS"print (((path + ' --> ') + filename) + '\\n')"
p6223
(F-3.624741554260254
F-3.8038166046142576
tp6224
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6225
(F-1.9969040720086348
F-3.567926025390625
tp6226
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6227
(F-2.239410146077474
F-3.668475341796875
tp6228
sS"print 'This file full path (following symlinks)'"
p6229
(F-2.838855504989624
F-3.9485309600830076
tp6230
sS"print (os.getcwd() + '\\n')"
p6231
(F-1.7622963587443035
F-3.735057067871094
tp6232
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6233
(F-2.0272579193115234
F-3.5135292053222655
tp6234
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6235
(F-2.1363624572753905
F-3.5761016845703124
tp6236
sS'import os\ncwd = os.getcwd()'
p6237
(F-1.1724552313486736
F-3.587493896484375
tp6238
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6239
(F-2.1318895249139693
F-3.5743900299072267
tp6240
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6241
(F-2.0286323547363283
F-3.57493896484375
tp6242
sS'import os\ndir_path = os.path.dirname(os.path.realpath(__file__))'
p6243
(F-0.6968157841609075
F-3.5012508392333985
tp6244
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6245
(F-2.0658912658691406
F-3.5722988128662108
tp6246
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6247
(F-2.4224195934477306
F-3.4622428894042967
tp6248
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6249
(F-2.534631601969401
F-3.556036376953125
tp6250
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6251
(F-3.078531689114041
F-3.5160842895507813
tp6252
sS"print (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6253
(F-2.6889739990234376
F-3.5363800048828127
tp6254
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6255
(F-1.8457395008632116
F-3.6393512725830077
tp6256
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6257
(F-2.07198158899943
F-3.5678642272949217
tp6258
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6259
(F-2.2149715939083614
F-3.5188961029052734
tp6260
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6261
(F-2.415873735800557
F-3.5363784790039063
tp6262
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6263
(F-2.3689095052083333
F-3.5542491912841796
tp6264
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6265
(F-2.5968063816879736
F-3.540563201904297
tp6266
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6267
(F-2.503289843362475
F-3.5355472564697266
tp6268
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6269
(F-1.978640011378697
F-3.554055023193359
tp6270
sS'print os.path.dirname(full_path)'
p6271
(F-1.3481531876784105
F-3.6866039276123046
tp6272
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6273
(F-2.215592956542969
F-3.5180438995361327
tp6274
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6275
(F-2.646429239908854
F-3.537628173828125
tp6276
sS"print 'Path at terminal when executing this file'"
p6277
(F-2.838855504989624
F-3.9485309600830076
tp6278
sS"print (__file__ + '\\n')"
p6279
(F-2.0798828125
F-3.7779064178466797
tp6280
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6281
(F-2.3450137699875877
F-3.5311138153076174
tp6282
sS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6283
(F-2.708094278971354
F-3.5653240203857424
tp6284
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6285
(F-2.1905496385362415
F-3.579356384277344
tp6286
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6287
(F-2.9974892139434814
F-3.788629150390625
tp6288
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6289
(F-2.2038325819858287
F-3.584309387207031
tp6290
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6291
(F-2.5705990261501737
F-3.533054733276367
tp6292
sS"print 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6293
(F-3.1997152475210338
F-3.5262596130371096
tp6294
sS'(path, filename) = os.path.split(full_path)'
p6295
(F-2.2533397674560547
F-3.5245800018310547
tp6296
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6297
(F-2.862590496356671
F-3.7595272064208984
tp6298
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')"
p6299
(F-2.348066488901774
F-3.720214080810547
tp6300
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6301
(F-2.1558284144247732
F-3.569217300415039
tp6302
sS"print 'This file directory only'\nprint os.path.dirname(full_path)"
p6303
(F-1.5541969537734985
F-3.685363006591797
tp6304
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6305
(F-1.9222764711122255
F-3.5658123016357424
tp6306
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'"
p6307
(F-2.125630823771159
F-3.575069808959961
tp6308
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6309
(F-2.165125189887153
F-3.5769683837890627
tp6310
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p6311
(F-2.4377260843912762
F-3.7288707733154296
tp6312
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'"
p6313
(F-2.567088656955295
F-3.722528076171875
tp6314
sS'cwd = os.getcwd()'
p6315
(F-1.553885989718967
F-3.7038715362548826
tp6316
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6317
(F-2.5185162995990953
F-3.53404541015625
tp6318
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')"
p6319
(F-2.0382856481215534
F-3.5718204498291017
tp6320
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6321
(F-2.3420441456330128
F-3.534211349487305
tp6322
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'"
p6323
(F-2.6341425577799478
F-3.7170677185058594
tp6324
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6325
(F-2.5268776472224745
F-3.5350502014160154
tp6326
sS"print (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6327
(F-3.8897078664679277
F-3.7945175170898438
tp6328
sS"import os\nprint 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6329
(F-2.4576737777046533
F-3.5298606872558596
tp6330
sS"print (full_path + '\\n')\nprint 'This file directory and name'"
p6331
(F-2.9294715294471154
F-4.044554901123047
tp6332
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6333
(F-2.578366486922554
F-3.537371063232422
tp6334
sS"(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6335
(F-3.2958585951063366
F-3.5632198333740233
tp6336
sS'full_path = os.path.realpath(__file__)'
p6337
(F-1.0559087991714478
F-3.6739322662353517
tp6338
sS"print (full_path + '\\n')"
p6339
(F-2.2134376525878907
F-4.12708625793457
tp6340
sS"print 'This file directory only'"
p6341
(F-2.838855504989624
F-3.9485309600830076
tp6342
sS"print (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6343
(F-2.1739630448190788
F-3.5115684509277343
tp6344
sS"full_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)"
p6345
(F-2.007030232747396
F-3.5409217834472657
tp6346
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')"
p6347
(F-2.57478759765625
F-3.537185287475586
tp6348
sS"print 'Path at terminal when executing this file'\nprint (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6349
(F-2.3930548154390774
F-3.536726379394531
tp6350
sS"print 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6351
(F-2.646888928535657
F-3.541387939453125
tp6352
sS"print (os.getcwd() + '\\n')\nprint 'This file path, relative to os.getcwd()'\nprint (__file__ + '\\n')\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint (full_path + '\\n')\nprint 'This file directory and name'\n(path, filename) = os.path.split(full_path)\nprint (((path + ' --> ') + filename) + '\\n')\nprint 'This file directory only'"
p6353
(F-2.5930256361372015
F-3.538756561279297
tp6354
ssI930397
(dp6355
S"alist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6356
(F-3.6955416279454387
F-1.6385576074773616
tp6357
sS"alist[(-1):]\nastr = ''"
p6358
(F-4.089888436453683
F-1.5474036823619495
tp6359
sS'some_list[(-2)] = 3'
p6360
(F-3.3590228740985575
F-1.5219997059215198
tp6361
sS'alist[(-1)]\nalist[(-1):]'
p6362
(F-3.6937048170301647
F-1.67561166936701
tp6363
sS'alist[(-1):]'
p6364
(F-4.055081939697265
F-1.61107722195712
tp6365
sS'astr[(-1)]\nastr[(-1):]'
p6366
(F-3.6937048170301647
F-1.67561166936701
tp6367
sS'some_list = [1, 2, 3]'
p6368
(F-2.355036368736854
F-1.5134428197687322
tp6369
sS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p6370
(F-3.5816724141438803
F-1.657360770485618
tp6371
sS'alist.pop()'
p6372
(F-1.6220861162458147
F-1.438560052351518
tp6373
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p6374
(F-3.3206274850027904
F-1.5971880826083096
tp6375
sS'alist = []\nalist[(-1)]\nalist[(-1):]'
p6376
(F-3.310442053753397
F-1.6024296500466086
tp6377
sS'alist = []\nalist[(-1)]'
p6378
(F-3.0831546783447266
F-1.5584987293590198
tp6379
sS'some_list[(-2)] = 3\nsome_list'
p6380
(F-4.459592033835018
F-1.505828163840554
tp6381
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''"
p6382
(F-3.3536642569082753
F-1.5730094909667969
tp6383
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p6384
(F-3.2856114085127666
F-1.5782120444557883
tp6385
sS"astr = ''\nastr[(-1)]\nastr[(-1):]"
p6386
(F-3.3719641945578833
F-1.6086703213778408
tp6387
sS"astr = ''"
p6388
(F-2.446661186218262
F-1.6641290838068181
tp6389
sS'some_list'
p6390
(F-6.085112380981445
F-1.4124212265014648
tp6391
sS"alist[(-1)]\nalist[(-1):]\nastr = ''"
p6392
(F-3.749069560657848
F-1.631396553733132
tp6393
sS'alist = []'
p6394
(F-3.056455612182617
F-1.467912500554865
tp6395
sS'astr[(-1)]'
p6396
(F-4.001888275146484
F-1.619883277199485
tp6397
sS"alist[(-1):]\nastr = ''\nastr[(-1)]"
p6398
(F-3.7328792918812144
F-1.6091015555641868
tp6399
sS'alist[(-1)]'
p6400
(F-4.001888275146484
F-1.6198831038041548
tp6401
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5'
p6402
(F-2.546025695800781
F-1.5470060868696733
tp6403
sS'some_list[(-1)] = 5'
p6404
(F-3.26268064058744
F-1.5102216547185725
tp6405
sS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6406
(F-3.5870165702624197
F-1.6700101332231
tp6407
sS'some_list[(-1)] = 5\nsome_list[(-2)] = 3'
p6408
(F-3.386105651855469
F-1.5733855854381213
tp6409
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6410
(F-3.4041297219016333
F-1.6119700345126065
tp6411
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3'
p6412
(F-2.841279107171136
F-1.5776765996759587
tp6413
sS"astr = ''\nastr[(-1)]"
p6414
(F-3.3603251530573917
F-1.5266342163085938
tp6415
sS'astr[(-1):]'
p6416
(F-4.055081939697265
F-1.61107722195712
tp6417
sS'some_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p6418
(F-4.006327661974677
F-1.564735239202326
tp6419
ssI961632
(dp6420
S"str(10)\nint('10')"
p6421
(F-3.1572574268687856
F-1.8782143063015408
tp6422
sS'str(a)'
p6423
(F-2.117515246073405
F-1.8632134331597223
tp6424
sS'str(10)'
p6425
(F-3.4757162729899087
F-1.8786029815673828
tp6426
sS'str(i)'
p6427
(F-2.083497683207194
F-1.9231618245442708
tp6428
sS"int('10')"
p6429
(F-1.814480145772298
F-1.9363967047797308
tp6430
sS'a.__str__()'
p6431
(F-2.2080101437038846
F-2.015268325805664
tp6432
ssI1712227
(dp6433
S"items.append('apple')\nitems.append('orange')"
p6434
(F-2.1694674173990887
F-1.711606216430664
tp6435
sS"items = []\nitems.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6436
(F-1.998160750777633
F-1.7031343460083008
tp6437
sS"items.append('apple')"
p6438
(F-2.078270435333252
F-1.7072479248046875
tp6439
sS'l.length'
p6440
(F-4.002908325195312
F-1.6700048446655273
tp6441
sS"items.append('banana')"
p6442
(F-2.078270435333252
F-1.7072479248046875
tp6443
sS'len(items)'
p6444
(F-2.263507525126139
F-1.6140979766845702
tp6445
sS'print l'
p6446
(F-5.0741286277771
F-1.8037097930908204
tp6447
sS'l = slist(range(10))\nl.length\nprint l'
p6448
(F-3.060579087999132
F-1.6777822494506835
tp6449
sS"items = []\nitems.append('apple')\nitems.append('orange')"
p6450
(F-2.1142789840698244
F-1.6943214416503907
tp6451
sS'items.__len__()'
p6452
(F-4.298953586154514
F-1.6603899002075195
tp6453
sS"items.append('orange')\nitems.append('banana')"
p6454
(F-2.1694674173990887
F-1.7116060256958008
tp6455
sS'True'
p6456
(F-7.012896219889323
F-1.7735774993896485
tp6457
sS'len([1, 2, 3])'
p6458
(F-2.4845242500305176
F-1.6019861221313476
tp6459
sS'def length(self):\n    pass'
p6460
(F-2.198836167653402
F-1.7063917160034179
tp6461
sS'def length(self):\n    return len(self)'
p6462
(F-2.2272427082061768
F-1.6719791412353515
tp6463
sS"items.append('orange')"
p6464
(F-2.078270435333252
F-1.7072479248046875
tp6465
sS'l.length\nprint l'
p6466
(F-4.368623733520508
F-1.7498069763183595
tp6467
sS'l = slist(range(10))\nl.length'
p6468
(F-3.421033732096354
F-1.6622533798217773
tp6469
sS'items = []'
p6470
(F-3.6931565602620444
F-1.65692195892334
tp6471
sS'return len(self)'
p6472
(F-2.780120304652623
F-1.6662931442260742
tp6473
sS'class slist(list):\n    pass'
p6474
(F-1.3618787129720051
F-1.6539094924926758
tp6475
sS'l = slist(range(10))'
p6476
(F-2.1906502463600854
F-1.6678224563598634
tp6477
sS"items = []\nitems.append('apple')"
p6478
(F-2.3890286959134617
F-1.6801801681518556
tp6479
sS"items.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6480
(F-2.160835959694602
F-1.7172706604003907
tp6481
ssI1720421
(dp6482
S'for item in itertools.chain(listone, listtwo):\n    pass'
p6483
(F-1.40252505408393
F-3.061322725736178
tp6484
sS'mergedlist = list(set((listone + listtwo)))'
p6485
(F-1.967003631591797
F-3.206409747783954
tp6486
sS'pass'
p6487
(F-4.564347585042317
F-3.6487142122708836
tp6488
sS'import itertools\nfor item in itertools.chain(listone, listtwo):\n    pass'
p6489
(F-1.3596553802490234
F-3.0701690086951623
tp6490
sS'mergedlist = (listone + listtwo)'
p6491
(F-1.828825208875868
F-3.302420689509465
tp6492
sS'import itertools'
p6493
(F-4.891462802886963
F-3.2595992455115685
tp6494
ssI209513
(dp6495
S"x = int('deadbeef', 16)"
p6496
(F-2.498551940917969
F-1.837537129720052
tp6497
sS'int(s, 16)'
p6498
(F-2.8660426139831543
F-1.775568962097168
tp6499
sS"int('a', 16)\nint('0xa', 16)"
p6500
(F-2.971100107828776
F-1.8175358242458768
tp6501
sS"int('0xa', 16)"
p6502
(F-2.6261396408081055
F-1.8248630099826388
tp6503
sS"print int('10', 0)"
p6504
(F-2.5201583438449435
F-1.7525902854071722
tp6505
sS"print int('0xdeadbeef', 0)"
p6506
(F-2.5201583438449435
F-1.7525902854071722
tp6507
sS"print int('0xdeadbeef', 0)\nprint int('10', 0)"
p6508
(F-2.7918234432444855
F-1.7466244167751737
tp6509
sS"int('a', 16)"
p6510
(F-2.6261398792266846
F-1.8248630099826388
tp6511
ssI642154
(dp6512
S'T2 = [[int(column) for column in row] for row in T1]'
p6513
(F-2.143790435791016
F-2.041907223788175
tp6514
sS'[[int(y) for y in x] for x in T1]'
p6515
(F-2.0130880143907337
F-1.897736982865767
tp6516
sS'T2 = [parse_a_row_of_T1(row) for row in T1]'
p6517
(F-2.5859425284645776
F-1.9540682705965908
tp6518
sS"print (int('1') + 1)"
p6519
(F-2.516585263338956
F-1.6288424405184658
tp6520
sS'T2 = [map(int, x) for x in T1]'
p6521
(F-1.465275764465332
F-1.891606244173917
tp6522
ssI2269827
(dp6523
S"(chr(101) == 'e')\nhex(65)"
p6524
(F-3.003736368815104
F-1.9797004063924153
tp6525
sS"hex(65)\n(chr(65) == 'A')"
p6526
(F-3.1550328572591146
F-1.9593626658121746
tp6527
sS"('0x%x' % 255)"
p6528
(F-4.440991810389927
F-1.943966547648112
tp6529
sS"(chr(101) == 'e')\nhex(65)\n(chr(65) == 'A')"
p6530
(F-3.4108492533365884
F-1.98759921391805
tp6531
sS"(chr(101) == 'e')"
p6532
(F-2.6910247802734375
F-2.0336132049560547
tp6533
sS"strHex = ('0x%0.2X' % 255)"
p6534
(F-4.685396194458008
F-1.9752000172932942
tp6535
sS"('0x%X' % 255)"
p6536
(F-4.440991810389927
F-1.943966547648112
tp6537
sS'hex(65)'
p6538
(F-2.501898924509684
F-1.9459889729817708
tp6539
sS"(chr(65) == 'A')"
p6540
(F-2.6910247802734375
F-2.0336132049560547
tp6541
ssI6996603
(dp6542
S'shutil.rmtree(path, ignore_errors=False, onerror=None)'
p6543
(F-1.9538423750135634
F-2.7522527906629772
tp6544
sS'os.removedirs(name)'
p6545
(F-1.3767410516738892
F-2.452408684624566
tp6546
sS'os.rmdir'
p6547
(F-1.847775650024414
F-2.5072655147976346
tp6548
sS'os.remove'
p6549
(F-3.452677917480469
F-2.517042795817057
tp6550
ssI227459
(dp6551
S'chr(97)'
p6552
(F-2.074530919392904
F-3.147694057888455
tp6553
sS'ord()'
p6554
(F-2.2842308044433595
F-3.162200503879123
tp6555
sS"ord('a')\nchr(97)"
p6556
(F-1.7909148823131213
F-3.104116015964084
tp6557
sS'unichr(1234)'
p6558
(F-2.074530919392904
F-3.147694057888455
tp6559
sS"ord('a')\nchr(97)\nchr((ord('a') + 3))"
p6560
(F-2.3137054443359375
F-3.0599871741400824
tp6561
sS'unichr(97)'
p6562
(F-2.074530919392904
F-3.147694057888455
tp6563
sS"chr((ord('a') + 3))"
p6564
(F-2.7498221764197717
F-3.030390845404731
tp6565
sS"ord('a')"
p6566
(F-1.5199348131815593
F-3.1309276156955295
tp6567
sS'unichr(97)\nunichr(1234)'
p6568
(F-2.0034793506969106
F-3.1537874009874134
tp6569
sS"ord(u'\\u3042')"
p6570
(F-1.5199348131815593
F-3.1309276156955295
tp6571
sS"chr(97)\nchr((ord('a') + 3))"
p6572
(F-2.5940541161431208
F-3.067010667588976
tp6573
ssI9257094
(dp6574
S"lower = raw_input('type in the same thing caps lock.')"
p6575
(F-2.1942373275756837
F-2.9749103122287326
tp6576
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p6577
(F-2.0653482583852916
F-3.0062921312120228
tp6578
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p6579
(F-2.2813195621266082
F-2.960042953491211
tp6580
sS'print upper.upper()\nprint lower.lower()'
p6581
(F-2.947936757405599
F-2.92661370171441
tp6582
sS'print s.upper()'
p6583
(F-2.1404731273651123
F-2.9326532151963978
tp6584
sS'string.ascii_uppercase'
p6585
(F-2.490996769496373
F-2.97983890109592
tp6586
sS"upper = raw_input('type in something lowercase.')"
p6587
(F-2.24622802734375
F-3.0157597859700522
tp6588
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')"
p6589
(F-1.9908658077842312
F-3.027584923638238
tp6590
sS's.upper()'
p6591
(F-2.0784718649727956
F-2.9258497026231556
tp6592
sS"s = 'sdsd'\ns.upper()"
p6593
(F-1.7169449546120383
F-2.9814571804470487
tp6594
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p6595
(F-2.1512021151455967
F-2.9709462059868708
tp6596
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p6597
(F-2.3662233352661133
F-2.935959074232313
tp6598
sS"s = 'sdsd'\nprint s.upper()"
p6599
(F-1.561795711517334
F-2.989447911580404
tp6600
sS"s = 'sdsd'"
p6601
(F-2.558798599243164
F-2.9490189022488065
tp6602
sS'print lower.lower()'
p6603
(F-2.6902427673339844
F-2.9028193155924478
tp6604
sS'import string'
p6605
(F-5.354738235473633
F-2.938160154554579
tp6606
sS'import string\nstring.ascii_uppercase'
p6607
(F-3.325267791748047
F-2.9591619703504772
tp6608
sS'print upper.upper()'
p6609
(F-2.8970024585723877
F-2.9509025149875217
tp6610
ssI730764
(dp6611
S'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    raise'
p6612
(F-1.9012926678324855
F-3.3952896118164064
tp6613
sS'try:\n    doSomething()\nexcept Exception:\n    pass'
p6614
(F-1.8397010000128495
F-3.3626258850097654
tp6615
sS'try:\n    sys.exit(1)\nexcept Exception:\n    pass'
p6616
(F-1.2079869224911643
F-3.330744425455729
tp6617
sS'try:\n    doSomething()\nexcept:\n    pass'
p6618
(F-1.725486119588216
F-3.358611806233724
tp6619
sS'pass'
p6620
(F-3.104832967122396
F-3.4027694702148437
tp6621
sS"shutil.rmtree('/fake/dir')"
p6622
(F-1.6246273517608643
F-3.531005096435547
tp6623
sS'try:\n    do_something()\nexcept:\n    pass'
p6624
(F-1.194419459292763
F-3.3608380635579427
tp6625
sS'raise'
p6626
(F-9.012409210205078
F-3.4198928833007813
tp6627
sS'shutil.rmtree(2)'
p6628
(F-1.8953680992126465
F-3.627429453531901
tp6629
sS'shutil.rmtree(path)'
p6630
(F-2.3479299545288086
F-3.4710055033365887
tp6631
sS'if (e.errno == 2):\n    pass'
p6632
(F-2.6272117614746096
F-3.393029276529948
tp6633
sS'handle_exception()'
p6634
(F-3.8379287719726562
F-3.36454340616862
tp6635
sS'try:\n    do_something()\nexcept:\n    handle_exception()'
p6636
(F-1.9029229205587637
F-3.349634043375651
tp6637
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    pass'
p6638
(F-1.7755304380904797
F-3.39356689453125
tp6639
sS'sys.exit(1)'
p6640
(F-1.4698833227157593
F-3.3014628092447915
tp6641
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    pass'
p6642
(F-1.3546481132507324
F-3.4056678771972657
tp6643
sS'try:\n    shutil.rmtree(path)\nexcept OSError:\n    pass'
p6644
(F-1.0849437713623047
F-3.40895512898763
tp6645
sS'try:\n    sys.exit(1)\nexcept:\n    pass'
p6646
(F-1.0513946533203125
F-3.3288663228352866
tp6647
sS'do_something()'
p6648
(F-1.5393597739083427
F-3.360609944661458
tp6649
sS'doSomething()'
p6650
(F-2.942925771077474
F-3.394054667154948
tp6651
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass'
p6652
(F-1.7907115088568792
F-3.4019241333007812
tp6653
sS'try:\n    do_something()\nexcept:\n    handle_exception()\nraise'
p6654
(F-2.6005780029296877
F-3.3514312744140624
tp6655
ssI70797
(dp6656
S"var = raw_input('Please enter something: ')"
p6657
(F-1.5910816192626953
F-3.8595657348632812
tp6658
sS'import sys'
p6659
(F-5.091712951660156
F-4.058472527398004
tp6660
sS"print ('you entered ' + input_var)"
p6661
(F-2.7363710403442383
F-3.8507037692599826
tp6662
sS'import sys\nprint sys.argv'
p6663
(F-2.457019805908203
F-4.133173200819227
tp6664
sS"print 'you entered', var"
p6665
(F-3.0457045237223306
F-3.8312776353624134
tp6666
sS"input_var = input('Enter something: ')"
p6667
(F-2.4110929489135744
F-3.857183668348524
tp6668
sS"input_var = input('Enter something: ')\nprint ('you entered ' + input_var)"
p6669
(F-2.195960797761616
F-3.857527838812934
tp6670
sS'print sys.argv'
p6671
(F-3.154109001159668
F-4.110934363471137
tp6672
sS"var = raw_input('Please enter something: ')\nprint 'you entered', var"
p6673
(F-1.9128622690836588
F-3.8269865247938366
tp6674
ssI4706499
(dp6675
S"f.write('hi')"
p6676
(F-1.2077374458312988
F-1.34078582127889
tp6677
sS'f.seek(0)'
p6678
(F-1.5188952684402466
F-1.499166488647461
tp6679
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6680
(F-1.4146787370954241
F-1.3517193794250488
tp6681
sS'f.seek(0)\nf.read()'
p6682
(F-1.6543652670724052
F-1.3677832285563152
tp6683
sS"f.write('hi')\nf.seek(0)"
p6684
(F-1.3121025085449218
F-1.3449614842732747
tp6685
sS"open('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p6686
(F-1.14141845703125
F-1.3090156714121501
tp6687
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6688
(F-1.2970323835100446
F-1.3292249043782551
tp6689
sS"open('test', 'rb').read()"
p6690
(F-1.0031565030415852
F-1.3186206022898357
tp6691
sS"f.seek(0)\nf.write('bye')"
p6692
(F-1.5826517740885417
F-1.3482708930969238
tp6693
sS"with open('foo', 'a') as f:\n    pass"
p6694
(F-0.8966616988182068
F-1.3083897431691487
tp6695
sS"f.write('bye')\nf.seek(0)\nf.read()"
p6696
(F-1.3041212899344308
F-1.3409196535746257
tp6697
sS"myfile.write('appended text')"
p6698
(F-1.2077374458312988
F-1.34078582127889
tp6699
sS"f = open('test', 'a+')"
p6700
(F-0.9234857559204102
F-1.308769702911377
tp6701
sS"with open('test.txt', 'a') as myfile:\n    myfile.write('appended text')"
p6702
(F-0.5015573047456288
F-1.298885981241862
tp6703
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6704
(F-1.0267432819713245
F-1.2995850245157878
tp6705
sS"f.read()\nf.seek(0)\nf.write('bye')"
p6706
(F-1.5675154186430431
F-1.3327744801839192
tp6707
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6708
(F-1.3976607904201601
F-1.3483904202779133
tp6709
sS"f.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6710
(F-1.4253654479980469
F-1.3522222836812336
tp6711
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6712
(F-0.994418227881716
F-1.3009120623270671
tp6713
sS"f.seek(0)\nf.write('bye')\nf.seek(0)"
p6714
(F-1.4658286354758523
F-1.3614794413248699
tp6715
sS'f.seek(0)\nf.read()\nf.seek(0)'
p6716
(F-1.6813981192452567
F-1.3737281163533528
tp6717
sS"f.write('hi')\nf.seek(0)\nf.read()"
p6718
(F-1.3041212899344308
F-1.3409194946289062
tp6719
sS"open('test', 'a+b').write('koko')"
p6720
(F-1.004785684438852
F-1.3091920216878254
tp6721
sS"f.write('cool beans...')"
p6722
(F-1.2077374458312988
F-1.34078582127889
tp6723
sS"with open('foo', 'a') as f:\n    f.write('cool beans...')"
p6724
(F-0.5015573047456288
F-1.298885981241862
tp6725
sS'f.read()\nf.seek(0)'
p6726
(F-1.7913930075509208
F-1.3538799285888672
tp6727
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6728
(F-1.4315834045410156
F-1.3390695254007976
tp6729
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6730
(F-1.2236068362281436
F-1.3343572616577148
tp6731
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p6732
(F-1.3605808530535017
F-1.3419016202290852
tp6733
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()"
p6734
(F-0.9829426447550456
F-1.3013922373453777
tp6735
sS"f.write('bye')"
p6736
(F-1.2077374458312988
F-1.34078582127889
tp6737
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p6738
(F-1.16716554429796
F-1.3054659366607666
tp6739
sS"'testkoko'"
p6740
(F-3.2743183771769204
F-1.499524434407552
tp6741
sS"f = open('test', 'a+')\nf.write('hi')"
p6742
(F-0.7861056047327378
F-1.299435297648112
tp6743
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6744
(F-1.2281945546468098
F-1.33323868115743
tp6745
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6746
(F-1.4002959307502298
F-1.3392572402954102
tp6747
sS"f.write('koko')"
p6748
(F-1.2077374458312988
F-1.34078582127889
tp6749
sS"with open('test.txt', 'a') as myfile:\n    pass"
p6750
(F-0.8966616988182068
F-1.3083898226420085
tp6751
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6752
(F-0.9933425304936427
F-1.3007802963256836
tp6753
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)"
p6754
(F-0.9519701798756918
F-1.300857384999593
tp6755
sS'f.read()'
p6756
(F-1.2000397273472376
F-1.3721334139506023
tp6757
sS"open('test', 'wb').write('test')"
p6758
(F-1.004785684438852
F-1.3091920216878254
tp6759
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p6760
(F-1.058683137635927
F-1.302201509475708
tp6761
sS"f.write('test')"
p6762
(F-1.2077374458312988
F-1.34078582127889
tp6763
sS'fseek(stream, 0, SEEK_END)'
p6764
(F-3.3670374552408853
F-1.5685594876607258
tp6765
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')"
p6766
(F-1.1131264495849609
F-1.3025875091552734
tp6767
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6768
(F-1.546152114868164
F-1.344195048014323
tp6769
sS"f.write('bye')\nf.seek(0)"
p6770
(F-1.3121025085449218
F-1.3449613253275554
tp6771
ssI22676
(dp6772
S"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6773
(F-2.448872375488281
F-1.7247599088228667
tp6774
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6775
(F-2.4832763671875
F-1.6863338763897235
tp6776
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p6777
(F-1.2737207866850353
F-1.65936646094689
tp6778
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p6779
(F-2.120555877685547
F-1.6981431520902193
tp6780
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6781
(F-2.853496940768495
F-1.911825913649339
tp6782
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p6783
(F-1.4161808805645637
F-1.6477728623610277
tp6784
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6785
(F-2.86830827666492
F-1.8351217416616588
tp6786
sS"file_name = url.split('/')[(-1)]"
p6787
(F-2.641733169555664
F-1.8010679391714244
tp6788
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')"
p6789
(F-1.5791972233698919
F-1.6536667163555439
tp6790
sS'f.close()'
p6791
(F-1.0765303203037806
F-1.8760992196890025
tp6792
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6793
(F-2.5372039794921877
F-1.8284891568697417
tp6794
sS"urllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p6795
(F-1.4128546714782715
F-1.7770215548001802
tp6796
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6797
(F-3.2300707499186196
F-1.9313438122089093
tp6798
sS'import urllib'
p6799
(F-3.830172061920166
F-1.7198109259972205
tp6800
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6801
(F-2.412967088487413
F-1.6998424530029297
tp6802
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p6803
(F-1.4178846951188713
F-1.6750296079195464
tp6804
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p6805
(F-2.466702117919922
F-1.6730327606201172
tp6806
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6807
(F-2.7689402429132515
F-1.7521327092097356
tp6808
sS"url = 'http://download.thinkbroadband.com/10MB.zip'"
p6809
(F-2.715199279785156
F-1.8654488783616285
tp6810
sS'if (not buffer):\n    break\nfile_size_dl += len(buffer)'
p6811
(F-3.4698907603388247
F-1.957461430476262
tp6812
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6813
(F-2.419611069762591
F-1.7140516134408803
tp6814
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6815
(F-3.0362705838853032
F-1.8900027641883264
tp6816
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p6817
(F-2.056880549380654
F-1.7157453390268178
tp6818
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6819
(F-3.4870237024818977
F-1.905637447650616
tp6820
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6821
(F-2.544403076171875
F-1.8310089111328125
tp6822
sS"f = open(file_name, 'wb')"
p6823
(F-1.5469365119934082
F-1.9132942786583533
tp6824
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p6825
(F-2.7455925941467285
F-1.8031124701866736
tp6826
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6827
(F-3.4103058750189623
F-1.8406803424541767
tp6828
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6829
(F-3.367341831752232
F-1.8689469557542067
tp6830
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6831
(F-2.5754203190879217
F-1.9507565131554236
tp6832
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6833
(F-2.4477164528586646
F-1.913256131685697
tp6834
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6835
(F-2.593995884486607
F-1.8269736950214093
tp6836
sS'print status,\nf.close()'
p6837
(F-2.6829403963955967
F-1.9580044379601111
tp6838
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p6839
(F-3.7900388163904988
F-1.8642812875600963
tp6840
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p6841
(F-2.8578623787301485
F-1.8569353543795073
tp6842
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6843
(F-2.2522939521575642
F-1.6748073284442608
tp6844
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6845
(F-3.3003897618765783
F-1.8392284099872296
tp6846
sS'break'
p6847
(F-3.6425857543945312
F-1.954864501953125
tp6848
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6849
(F-3.3695118755375573
F-1.8259303753192608
tp6850
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p6851
(F-2.5729920069376626
F-1.804665785569411
tp6852
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6853
(F-2.470556554659991
F-1.7101518190824068
tp6854
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p6855
(F-1.4208505803888494
F-1.6723524240347056
tp6856
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p6857
(F-1.4777063830145474
F-1.6560723231388972
tp6858
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6859
(F-2.4536408523033404
F-1.690057901235727
tp6860
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6861
(F-3.2661638532366073
F-1.8255632840670073
tp6862
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p6863
(F-1.2498709360758464
F-1.6262576763446515
tp6864
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6865
(F-2.162811279296875
F-1.8217463860144982
tp6866
sS'import requests'
p6867
(F-4.6490325927734375
F-1.702154746422401
tp6868
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6869
(F-2.3828727147912465
F-1.6730525677020733
tp6870
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p6871
(F-1.591045957623106
F-1.7140259375939002
tp6872
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6873
(F-2.7740207947406574
F-1.7254128089317908
tp6874
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p6875
(F-1.6502916245233445
F-1.6710739135742188
tp6876
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6877
(F-2.2351248264312744
F-1.9330671750582182
tp6878
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p6879
(F-2.716227348277111
F-1.7313424623929536
tp6880
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6881
(F-2.318419647216797
F-1.7227877103365385
tp6882
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p6883
(F-1.5051261356898717
F-1.7467134915865385
tp6884
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p6885
(F-1.4863132677580182
F-1.709038807795598
tp6886
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p6887
(F-2.064800334426592
F-1.660586430476262
tp6888
sS'handle.write(data)'
p6889
(F-2.3079288005828857
F-1.7953095069298377
tp6890
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p6891
(F-2.7735189884266953
F-1.8493540837214544
tp6892
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6893
(F-2.32250316722973
F-1.8370374532846303
tp6894
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6895
(F-2.4946612846560594
F-1.907250477717473
tp6896
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6897
(F-2.812721515523976
F-1.8368012354924128
tp6898
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6899
(F-2.3947623379259224
F-1.8104673532339244
tp6900
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6901
(F-2.734747054729056
F-1.8786987891564002
tp6902
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6903
(F-2.4814906018845577
F-1.8219782022329478
tp6904
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6905
(F-2.56577467918396
F-1.8397078880896935
tp6906
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6907
(F-2.72306051598974
F-1.9046184833233173
tp6908
sS'file_size_dl = 0\nblock_sz = 8192'
p6909
(F-3.7597803751627605
F-1.8427550976093
tp6910
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p6911
(F-2.9744518114172895
F-1.8432557032658503
tp6912
sS"f = open(file_name, 'wb')\nmeta = u.info()"
p6913
(F-2.1290855407714844
F-1.8634251814622145
tp6914
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6915
(F-2.970443070300518
F-1.8702380840594952
tp6916
sS'print status,'
p6917
(F-5.892285537719727
F-1.9944073603703425
tp6918
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6919
(F-2.6546138509114585
F-1.8733184521014874
tp6920
sS'status = (status + (chr(8) * (len(status) + 1)))'
p6921
(F-3.825770834217901
F-2.35721676166241
tp6922
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p6923
(F-2.7701124781884516
F-1.7098519251896784
tp6924
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6925
(F-2.2505266594164297
F-1.8427835611196666
tp6926
sS'u = urllib2.urlopen(url)'
p6927
(F-1.8723190307617188
F-1.7897010216346154
tp6928
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p6929
(F-2.3618557453155518
F-1.6680809901310847
tp6930
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p6931
(F-1.3433223817406632
F-1.6279810391939604
tp6932
sS'for data in tqdm(response.iter_content()):\n    handle.write(data)'
p6933
(F-1.8515982055664062
F-1.8127362177922175
tp6934
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6935
(F-2.6178084925601355
F-1.9996370168832631
tp6936
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6937
(F-2.7087904407132055
F-1.872392360980694
tp6938
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6939
(F-2.1250509823069854
F-1.6685664837176983
tp6940
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p6941
(F-2.4528629557291666
F-1.7145731999323919
tp6942
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6943
(F-2.5316188879180372
F-1.7199881627009466
tp6944
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p6945
(F-2.374770698197391
F-1.7214738405667818
tp6946
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p6947
(F-2.2184409525857043
F-1.70075196486253
tp6948
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6949
(F-3.6089864331622454
F-1.906962174635667
tp6950
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6951
(F-2.9096644304800723
F-1.9172983903151293
tp6952
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p6953
(F-2.4894815240024535
F-1.724948002741887
tp6954
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6955
(F-3.1755156083540483
F-1.890027559720553
tp6956
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p6957
(F-2.1497066331946333
F-1.7151267711932843
tp6958
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6959
(F-3.188008980129076
F-1.828372075007512
tp6960
sS'if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p6961
(F-3.1881113688151044
F-1.9396230257474458
tp6962
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p6963
(F-1.371222215540269
F-1.6734630878155048
tp6964
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p6965
(F-2.3862220583938236
F-1.6820944272554839
tp6966
sS'response = requests.get(url, stream=True)'
p6967
(F-1.358445712498256
F-1.7680567227877104
tp6968
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p6969
(F-2.199740483210637
F-1.7192064431997447
tp6970
sS'if (not buffer):\n    break'
p6971
(F-2.9798946380615234
F-2.041698455810547
tp6972
sS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()'
p6973
(F-3.4580209905450996
F-2.1477769704965444
tp6974
sS"import urllib\nurllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p6975
(F-1.0645957359900842
F-1.6907339829664965
tp6976
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p6977
(F-3.5560435946025546
F-1.9286663348858173
tp6978
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p6979
(F-2.7282592029106327
F-1.8510489830603967
tp6980
sS'meta = u.info()'
p6981
(F-3.3216241200764975
F-2.1942611107459435
tp6982
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p6983
(F-2.416897681451613
F-1.7078766456017127
tp6984
sS'from tqdm import tqdm'
p6985
(F-3.011894861857096
F-1.9932708740234375
tp6986
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p6987
(F-2.897420129110647
F-1.8484969505896935
tp6988
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p6989
(F-2.4267021814982095
F-1.7019827916071966
tp6990
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p6991
(F-2.2609782391283884
F-1.7109492375300481
tp6992
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p6993
(F-3.081558125131082
F-1.862694080059345
tp6994
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6995
(F-2.503859230324074
F-1.70782470703125
tp6996
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p6997
(F-2.81827918519365
F-1.8983042790339544
tp6998
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p6999
(F-2.745082073901073
F-1.9058050008920522
tp7000
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7001
(F-1.5471098526664402
F-1.6899026724008412
tp7002
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7003
(F-3.295287303435497
F-1.8459214430588942
tp7004
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p7005
(F-2.4369166277456973
F-1.711204822246845
tp7006
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7007
(F-3.12731195806147
F-1.8246057950533354
tp7008
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7009
(F-2.803988530085637
F-2.0473653353177586
tp7010
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7011
(F-2.8106947561994713
F-1.71037351168119
tp7012
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7013
(F-2.3952093650036907
F-1.6838681147648737
tp7014
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7015
(F-3.460099872789885
F-1.8214084918682392
tp7016
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7017
(F-3.235736004717938
F-1.8141099489652193
tp7018
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7019
(F-2.769286577091661
F-1.8754386901855469
tp7020
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7021
(F-3.192992401123047
F-1.9221546466533954
tp7022
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7023
(F-2.1868266230044155
F-1.7166790595421424
tp7024
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7025
(F-2.959684310420867
F-1.8633707486666167
tp7026
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7027
(F-1.1839900243849981
F-1.668595974261944
tp7028
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p7029
(F-2.1533861858088796
F-1.6972854320819561
tp7030
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7031
(F-2.9630409523292824
F-1.8582850236159105
tp7032
sS"with open('10MB', 'wb') as handle:\n    pass"
p7033
(F-1.3014390468597412
F-1.924210181603065
tp7034
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7035
(F-2.3332919230503317
F-1.7007928994985728
tp7036
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p7037
(F-2.7876708984375
F-1.8476056319016676
tp7038
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7039
(F-2.3565577845419607
F-1.7706006857065053
tp7040
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7041
(F-2.9148207164946056
F-1.8348755469689002
tp7042
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7043
(F-2.4092458909557712
F-1.7056058736947866
tp7044
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7045
(F-2.278187091533954
F-1.689610848060021
tp7046
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7047
(F-2.833952278926455
F-1.9113414470966046
tp7048
sS'r = requests.get(url)\nprint len(r.content)'
p7049
(F-1.6147239473130968
F-1.7274344517634466
tp7050
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7051
(F-2.813182228489926
F-1.9142927023080678
tp7052
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7053
(F-3.0231289567618536
F-1.8624314528245192
tp7054
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7055
(F-2.819697385578486
F-1.7486099830040565
tp7056
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7057
(F-2.2763470869797926
F-1.7002607492300181
tp7058
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7059
(F-2.242920819450827
F-1.6831732529860277
tp7060
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7061
(F-3.738697843731574
F-1.9439610701340895
tp7062
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7063
(F-2.659007602267795
F-1.8876237135667067
tp7064
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7065
(F-2.3982890735973013
F-1.6755714416503906
tp7066
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7067
(F-3.1301770714240345
F-1.848093766432542
tp7068
sS'import urllib2'
p7069
(F-4.436728477478027
F-1.7057005075307994
tp7070
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7071
(F-2.4569740295410156
F-1.7275954026442308
tp7072
sS'while True:\n    buffer = u.read(block_sz)'
p7073
(F-2.631686952379015
F-1.7725428067720854
tp7074
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7075
(F-3.454018147786458
F-1.8757071861853967
tp7076
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7077
(F-2.0212020874023438
F-1.7044117267315204
tp7078
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7079
(F-1.9633056640625
F-1.6485961033747747
tp7080
sS"response = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p7081
(F-1.2984398735894098
F-1.7282597468449519
tp7082
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7083
(F-2.846531189594072
F-1.743963388296274
tp7084
sS'f.write(buffer)'
p7085
(F-2.1900181770324707
F-1.8105424734262319
tp7086
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7087
(F-2.6781013997395835
F-1.8702694819523737
tp7088
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7089
(F-3.2095928360930586
F-1.8451539553128755
tp7090
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7091
(F-2.7306730980966605
F-1.7281673137958233
tp7092
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7093
(F-2.6746022424032523
F-1.7129868727463942
tp7094
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7095
(F-3.4909263610839845
F-1.8711756192720854
tp7096
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7097
(F-2.707384018670945
F-1.7316606961763823
tp7098
sS"file_size = int(meta.getheaders('Content-Length')[0])"
p7099
(F-2.521945741441515
F-1.900197249192458
tp7100
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p7101
(F-2.5380366932262075
F-1.7810090871957631
tp7102
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0"
p7103
(F-2.4666341737259265
F-1.7229549701397235
tp7104
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7105
(F-1.5237265500155361
F-1.7186270493727465
tp7106
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7107
(F-3.699242115020752
F-1.86659182035006
tp7108
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7109
(F-3.1855112098785767
F-1.804214330819937
tp7110
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7111
(F-3.7129947916666666
F-1.8815967853252704
tp7112
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7113
(F-2.330805073613706
F-1.709153101994441
tp7114
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7115
(F-3.022136760207842
F-1.8756768153263972
tp7116
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7117
(F-2.2889082625105575
F-1.8474305959848256
tp7118
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7119
(F-2.8759066023916566
F-1.836386460524339
tp7120
sS'for data in tqdm(response.iter_content()):\n    pass'
p7121
(F-2.0119428634643555
F-1.885552479670598
tp7122
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7123
(F-3.4269322524836032
F-1.8838807619535005
tp7124
sS'buffer = u.read(block_sz)'
p7125
(F-3.663574536641439
F-1.795724135178786
tp7126
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7127
(F-3.0867828563520106
F-1.8702703622671275
tp7128
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7129
(F-3.0908397674560546
F-1.8345652360182543
tp7130
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7131
(F-2.429506468541414
F-1.7168364891639123
tp7132
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7133
(F-2.803674105940194
F-1.9194057171161358
tp7134
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7135
(F-2.183518327985491
F-1.670141366811899
tp7136
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7137
(F-3.0321639316533906
F-1.8721087529109075
tp7138
sS'print len(r.content)'
p7139
(F-2.451263851589627
F-1.7996641305776744
tp7140
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass'
p7141
(F-2.560408882472826
F-2.0062201573298526
tp7142
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7143
(F-1.4054609026227678
F-1.650606448833759
tp7144
sS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,'
p7145
(F-4.252135100188078
F-2.318827409010667
tp7146
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7147
(F-2.5057370835456294
F-1.7303939232459435
tp7148
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7149
(F-1.278823004828559
F-1.7292310274564302
tp7150
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7151
(F-1.3592788696289062
F-1.665525876558744
tp7152
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7153
(F-2.471465587615967
F-1.664572495680589
tp7154
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7155
(F-2.8694876930930397
F-1.9043956169715295
tp7156
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7157
(F-2.7592095947265625
F-1.7466351435734675
tp7158
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7159
(F-1.37142377911192
F-1.6558812948373647
tp7160
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7161
(F-3.2150302152021215
F-1.8427316225492036
tp7162
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7163
(F-2.763195169383082
F-1.823805882380559
tp7164
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7165
(F-3.5514053559639085
F-1.8835609142596905
tp7166
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7167
(F-2.8562210437863373
F-1.856538332425631
tp7168
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7169
(F-2.4709871080186634
F-1.7712406745323768
tp7170
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7171
(F-1.4579225427964155
F-1.6806976611797626
tp7172
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7173
(F-2.7690900345923195
F-1.8186663114107573
tp7174
sS'from tqdm import tqdm\nimport requests'
p7175
(F-3.028338326348199
F-1.834638155423678
tp7176
sS"print ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7177
(F-3.103339672088623
F-1.8885107774000902
tp7178
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7179
(F-2.74405517578125
F-1.85333251953125
tp7180
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7181
(F-2.754800022238552
F-1.8876047867995043
tp7182
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7183
(F-1.5061053466796874
F-1.6792332575871394
tp7184
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7185
(F-3.3664195848547895
F-1.9063484485332782
tp7186
sS'file_size_dl += len(buffer)'
p7187
(F-3.7108465830485025
F-1.8693822713998647
tp7188
sS'if (not buffer):\n    pass'
p7189
(F-3.0226109822591147
F-2.070927693293645
tp7190
sS"response = urllib2.urlopen('http://www.example.com/')"
p7191
(F-1.5972660064697266
F-1.7545089721679688
tp7192
sS'file_size_dl = 0'
p7193
(F-4.254913330078125
F-1.8616450383112981
tp7194
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7195
(F-2.4789194853409477
F-1.7252112168532152
tp7196
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7197
(F-2.8049033717105263
F-1.744799834031325
tp7198
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7199
(F-2.9490822362535782
F-1.857908689058744
tp7200
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))"
p7201
(F-2.0850407334624745
F-1.7050113677978516
tp7202
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7203
(F-2.93069557251969
F-1.8464905665471003
tp7204
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7205
(F-2.6659803989955355
F-1.6955821697528546
tp7206
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7207
(F-1.953112635119208
F-1.7044598506047175
tp7208
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7209
(F-2.2761085146949407
F-1.7251620659461389
tp7210
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7211
(F-1.4174726926363432
F-1.6654252272385817
tp7212
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192"
p7213
(F-2.5482672489050664
F-1.8293970548189604
tp7214
sS'file_size_dl += len(buffer)\nf.write(buffer)'
p7215
(F-3.270259054083573
F-1.8706666506253755
tp7216
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7217
(F-2.945850453478225
F-1.8357825646033654
tp7218
sS'block_sz = 8192'
p7219
(F-3.3698452540806363
F-1.859066889836238
tp7220
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7221
(F-2.7247111002604165
F-1.7131412212665265
tp7222
sS'html = response.read()'
p7223
(F-1.4970459408230252
F-1.739571057833158
tp7224
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7225
(F-3.953579015899123
F-1.944330362173227
tp7226
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7227
(F-2.815200343276515
F-1.7256369957557092
tp7228
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7229
(F-2.5418822310353053
F-1.7268995138315053
tp7230
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7231
(F-2.864777128575212
F-1.7490246112530048
tp7232
sS'while True:\n    pass'
p7233
(F-1.6172531975640192
F-2.307806895329402
tp7234
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7235
(F-2.4934844970703125
F-1.8228350419264574
tp7236
sS'block_sz = 8192\nwhile True:\n    pass'
p7237
(F-2.1242780049641925
F-2.29793328505296
tp7238
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint ('Downloading: %s Bytes: %s' % (file_name, file_size))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7239
(F-2.31079233103785
F-1.676034193772536
tp7240
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7241
(F-3.5344331702407525
F-1.8411564460167518
tp7242
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p7243
(F-2.82550048828125
F-1.8174883035513072
tp7244
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7245
(F-1.3484153747558594
F-1.6458707956167369
tp7246
sS'r = requests.get(url)'
p7247
(F-1.600538444519043
F-1.7652576153094952
tp7248
ssI739993
(dp7249
S'import pip\ninstalled_packages = pip.get_installed_distributions()'
p7250
(F-4.86327404446072
F-2.8315767560686385
tp7251
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p7252
(F-3.6956953568892046
F-2.8121937343052457
tp7253
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p7254
(F-3.9059278215680804
F-2.9004838126046315
tp7255
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p7256
(F-4.177745216771176
F-2.85363279070173
tp7257
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7258
(F-3.58091402053833
F-3.081233160836356
tp7259
sS'(iterpipes == 0.4)'
p7260
(F-2.5813565935407365
F-2.814770289829799
tp7261
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7262
(F-4.161163330078125
F-2.826413018362863
tp7263
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p7264
(F-3.6421114293540398
F-2.8927078247070312
tp7265
sS'(cd / tmp)'
p7266
(F-2.73279299054827
F-2.813122340611049
tp7267
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p7268
(F-3.735687647110377
F-3.0754852294921875
tp7269
sS"['behave==1.2.4', 'enum34==1.0', 'flask==0.10.1', 'itsdangerous==0.24', 'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3', 'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2', 'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1', 'vioozer-users-server==0.1', 'werkzeug==0.9.4']"
p7270
(F-0.6306319100516183
F-2.837703432355608
tp7271
sS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7272
(F-4.132747816002888
F-2.9130197252546037
tp7273
sS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p7274
(F-4.146298102612765
F-2.910161699567522
tp7275
sS'import os'
p7276
(F-3.8474791049957275
F-2.8538428715297153
tp7277
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint installed_packages_list"
p7278
(F-4.131951195853097
F-2.829648426600865
tp7279
sS'os.getcwd()'
p7280
(F-1.4599075317382812
F-2.825943265642439
tp7281
sS'(docutils == 0.7)'
p7282
(F-2.5813565935407365
F-2.814770289829799
tp7283
sS"help('modules')"
p7284
(F-1.9769555727640789
F-2.7824690682547435
tp7285
sS'print installed_packages_list'
p7286
(F-4.543577194213867
F-2.8743008204868863
tp7287
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p7288
(F-3.7916452884674072
F-3.0351164681570872
tp7289
sS'import pip'
p7290
(F-6.4659318923950195
F-2.812335968017578
tp7291
sS'import os\nos.getcwd()'
p7292
(F-1.4376705169677735
F-2.8962304251534596
tp7293
sS'installed_packages = pip.get_installed_distributions()'
p7294
(F-4.885384114583333
F-2.8895653315952847
tp7295
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p7296
(F-4.138552420479911
F-2.9692557198660716
tp7297
ssI6797984
(dp7298
S"raw_input('Type Something').lower()"
p7299
(F-1.7800715764363606
F-1.5747600902210583
tp7300
sS"s = 'Kilometer'"
p7301
(F-2.620566558837891
F-1.5177197889848189
tp7302
sS"print s.lower()\nprint s.decode('utf-8').lower()"
p7303
(F-1.807426643371582
F-1.445774425159801
tp7304
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'"
p7305
(F-2.620566558837891
F-1.5177197889848189
tp7306
sS"s = 'Kilometer'\nprint s.lower()"
p7307
(F-1.3697295188903809
F-1.4674283807927913
tp7308
sS"print s.decode('utf-8').lower()"
p7309
(F-1.7183978740985577
F-1.5124303644353694
tp7310
sS'print s.lower()'
p7311
(F-1.951991081237793
F-1.4220475283536045
tp7312
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()\nprint s.decode('utf-8').lower()"
p7313
(F-1.479200045267741
F-1.461879383433949
tp7314
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()"
p7315
(F-1.3697295188903809
F-1.4674283807927913
tp7316
ssI1207457
(dp7317
S'import codecs'
p7318
(F-5.08041524887085
F-3.000262975692749
tp7319
sS"type(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7320
(F-2.5382372538248696
F-2.8891096115112305
tp7321
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')"
p7322
(F-2.4996347929302014
F-2.9140963554382324
tp7323
sS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7324
(F-2.3360851287841795
F-2.9182491302490234
tp7325
sS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7326
(F-2.709774218107525
F-2.937633514404297
tp7327
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata"
p7328
(F-3.471160888671875
F-3.018868923187256
tp7329
sS'f.write(my_unicode_string)'
p7330
(F-3.137486457824707
F-2.8885107040405273
tp7331
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)"
p7332
(F-2.615167808532715
F-2.970978260040283
tp7333
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7334
(F-2.380983625139509
F-2.9052529335021973
tp7335
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7336
(F-2.308455505371094
F-2.9873690605163574
tp7337
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7338
(F-2.4543625513712564
F-2.9437546730041504
tp7339
sS"s = u'\\xa310'"
p7340
(F-2.830389404296875
F-2.9245662689208984
tp7341
sS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7342
(F-2.5252761840820312
F-2.918470859527588
tp7343
sS"s.encode('utf16')"
p7344
(F-1.494842767715454
F-2.927386522293091
tp7345
sS"a.encode('ascii', 'ignore')"
p7346
(F-1.9001750946044922
F-2.902214288711548
tp7347
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'"
p7348
(F-3.6411811828613283
F-3.1321942806243896
tp7349
sS"s.encode('utf8')"
p7350
(F-1.494842767715454
F-2.927386522293091
tp7351
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'"
p7352
(F-3.327156829833984
F-2.931283950805664
tp7353
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7354
(F-1.1491230235380285
F-3.003025770187378
tp7355
sS'type(a)'
p7356
(F-2.850708325703939
F-3.0321238040924072
tp7357
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7358
(F-1.8048291887555803
F-2.940279006958008
tp7359
sS"s = u'\\xa310'\ns.encode('utf8')\ns.encode('utf16')"
p7360
(F-1.3828105926513672
F-2.94616961479187
tp7361
sS"a.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7362
(F-2.078630146227385
F-2.9013736248016357
tp7363
sS"s.encode('utf8')\ns.encode('utf16')"
p7364
(F-1.596808369954427
F-2.92645263671875
tp7365
sS'import unicodedata'
p7366
(F-5.08041524887085
F-3.000262975692749
tp7367
sS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7368
(F-2.4443915872012867
F-2.940247058868408
tp7369
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7370
(F-1.6034022739955358
F-3.0578293800354004
tp7371
sS"a.encode('ascii', 'replace')"
p7372
(F-1.9001750946044922
F-2.902214288711548
tp7373
sS"type(a)\na.encode('ascii', 'ignore')"
p7374
(F-2.7448460896809896
F-2.893967628479004
tp7375
sS"s = u'\\xa310'\ns.encode('utf8')"
p7376
(F-1.5051906903584797
F-2.9522194862365723
tp7377
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7378
(F-2.6168609032264123
F-2.9431443214416504
tp7379
sS"'Kluft skrams infor pa federal electoral groe'"
p7380
(F-3.666754404703776
F-2.919717311859131
tp7381
ssI3294889
(dp7382
S'for (key, value) in d.iteritems():\n    pass'
p7383
(F-1.6689981159410978
F-2.3071788787841796
tp7384
sS'd.keys()'
p7385
(F-1.7032157352992467
F-2.36456356048584
tp7386
sS'for key in d:\n    pass'
p7387
(F-1.6674454428932883
F-2.3329183578491213
tp7388
sS"print k, 'corresponds to', v"
p7389
(F-4.084383010864258
F-2.6064502716064455
tp7390
sS'for (key, value) in d.items():\n    pass'
p7391
(F-1.6063045702482526
F-2.318260383605957
tp7392
sS'd.items()'
p7393
(F-1.7983597346714564
F-2.365213966369629
tp7394
sS"print letter, 'corresponds to', number"
p7395
(F-4.837695121765137
F-2.97735710144043
tp7396
sS'list(d)'
p7397
(F-2.199019114176432
F-2.2796796798706054
tp7398
sS'for (letter, number) in d.items():\n    pass'
p7399
(F-2.100385967053865
F-2.4695335388183595
tp7400
sS'for (k, v) in d.items():\n    pass'
p7401
(F-1.5594514545641447
F-2.2796100616455077
tp7402
sS"d = {'x': 1, 'y': 2, 'z': 3, }"
p7403
(F-2.1053629981146917
F-2.4098127365112303
tp7404
sS"print '{0} corresponds to {1}'.format(letter, number)"
p7405
(F-2.4988127621737393
F-2.962453079223633
tp7406
sS'pass'
p7407
(F-4.921422640482585
F-2.9883499145507812
tp7408
sS"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)"
p7409
(F-1.9040368121603262
F-2.2488729476928713
tp7410
sS'list(d)\nd.keys()'
p7411
(F-2.4828532536824546
F-2.360500717163086
tp7412
sS"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)\nd.keys()"
p7413
(F-2.0197976211021684
F-2.2323814392089845
tp7414
ssI7571635
(dp7415
S"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7416
(F-1.88361278333162
F-1.7946109771728516
tp7417
sS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7418
(F-2.1030609753667093
F-1.809698985173152
tp7419
sS"print 'Not found'"
p7420
(F-4.1694769859313965
F-2.2899554325984073
tp7421
sS"print 'found'"
p7422
(F-4.1694769859313965
F-2.2899554325984073
tp7423
sS'(7 in a)'
p7424
(F-5.295168195452009
F-1.8205330188457782
tp7425
sS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7426
(F-1.9613253729684013
F-1.7986702552208533
tp7427
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7428
(F-2.017119891826923
F-1.8485287886399488
tp7429
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7430
(F-1.6201801300048828
F-1.9326343536376953
tp7431
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']"
p7432
(F-2.4730224609375
F-1.880189455472506
tp7433
sS'index = dict(((y, x) for (x, y) in enumerate(a)))'
p7434
(F-2.10393798828125
F-1.872892086322491
tp7435
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7436
(F-1.823625030517578
F-1.930280245267428
tp7437
sS'a_index = index[7]'
p7438
(F-4.066397094726563
F-1.893677491408128
tp7439
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7440
(F-2.040851593017578
F-1.8551854353684645
tp7441
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))'
p7442
(F-1.9765952505716464
F-1.9099655151367188
tp7443
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7444
(F-1.486660119258996
F-1.930888689481295
tp7445
sS'a = [4, 2, 3, 1, 5, 6]'
p7446
(F-2.1395097620346966
F-1.8844492985652044
tp7447
sS'try:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7448
(F-1.9160788853963215
F-1.9284268892728365
tp7449
sS"return ('a' in a)"
p7450
(F-3.2989635467529297
F-1.9395567087026744
tp7451
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7452
(F-1.920717027452257
F-1.833398965688852
tp7453
sS'index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7454
(F-2.1422179539998374
F-1.8163251143235426
tp7455
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7456
(F-1.8595384571650257
F-1.8285961151123047
tp7457
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']\nreturn ('a' in a)"
p7458
(F-2.535140110896184
F-1.8274674048790565
tp7459
ssI1093322
(dp7460
S"import sys\nsys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7461
(F-3.2049840291341147
F-2.2303194681803387
tp7462
sS"import sys\nsys.hexversion\n('%x' % sys.hexversion)"
p7463
(F-2.989551067352295
F-2.184215799967448
tp7464
sS'import sys'
p7465
(F-4.1840057373046875
F-2.1261146545410154
tp7466
sS"('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7467
(F-3.5422686408547794
F-2.3531504313151044
tp7468
sS'sys.hexversion'
p7469
(F-1.9497604370117188
F-2.2137537638346356
tp7470
sS'sys.version_info'
p7471
(F-2.309793472290039
F-2.2049329121907553
tp7472
sS'print sys.version'
p7473
(F-3.08100954691569
F-2.1414899190266925
tp7474
sS"('%x' % sys.hexversion)"
p7475
(F-2.9807010226779513
F-2.3442982991536456
tp7476
sS'sys.version_info\nsys.hexversion'
p7477
(F-3.662351434881037
F-2.1867904663085938
tp7478
sS'import sys\nsys.hexversion'
p7479
(F-2.888937473297119
F-2.156457265218099
tp7480
sS'(python - V)'
p7481
(F-4.257905687604632
F-2.4216588338216147
tp7482
sS"sys.hexversion\n('%x' % sys.hexversion)"
p7483
(F-3.1254454392653246
F-2.2272928873697917
tp7484
sS"sys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7485
(F-3.356873285202753
F-2.272694396972656
tp7486
sS'(sys.hexversion < 33947648)'
p7487
(F-3.5986095004611545
F-2.4453664143880207
tp7488
sS'assert (sys.version_info >= (2, 5))'
p7489
(F-3.414649724960327
F-2.2891494750976564
tp7490
ssI5618878
(dp7491
S"list1 = ['1', '2', '3']"
p7492
(F-1.8169018138538708
F-2.047264814376831
tp7493
sS"list1 = ['1', '2', '3']\nstr1 = ''.join(list1)"
p7494
(F-1.3526528358459473
F-1.9696567058563232
tp7495
sS"L = ['L', 'O', 'L']\nmakeitastring = ''.join(map(str, L))"
p7496
(F-0.9974334716796875
F-1.9414784908294678
tp7497
sS"makeitastring = ''.join(map(str, L))"
p7498
(F-1.1651509602864583
F-1.9165399074554443
tp7499
sS"L = [1, 2, 3]\n' '.join((str(x) for x in L))\n'1 2 3'"
p7500
(F-1.7048000467234645
F-1.9693481922149658
tp7501
sS'L = [1, 2, 3]'
p7502
(F-2.172690998424183
F-2.1403450965881348
tp7503
sS"str1 = ''.join(list1)"
p7504
(F-1.6296257019042968
F-1.9452763795852661
tp7505
sS"' '.join((str(x) for x in L))"
p7506
(F-1.184337952557732
F-1.9155263900756836
tp7507
sS"str1 = ''.join((str(e) for e in list1))"
p7508
(F-1.7749320582339638
F-1.948366641998291
tp7509
sS"list1 = [1, 2, 3]\nstr1 = ''.join((str(e) for e in list1))"
p7510
(F-1.975849283152613
F-1.9524028301239014
tp7511
sS'list1 = [1, 2, 3]'
p7512
(F-2.4653680974786933
F-2.053091287612915
tp7513
sS"L = ['L', 'O', 'L']"
p7514
(F-1.4976102655584163
F-2.107490062713623
tp7515
sS"L = [1, 2, 3]\n' '.join((str(x) for x in L))"
p7516
(F-1.4974052994339555
F-1.9749975204467773
tp7517
sS"' '.join((str(x) for x in L))\n'1 2 3'"
p7518
(F-1.5781430696186267
F-1.9151880741119385
tp7519
sS"'1 2 3'"
p7520
(F-3.975982983907064
F-2.1100921630859375
tp7521
ssI3277503
(dp7522
S'array.append(line)'
p7523
(F-2.242502450942993
F-2.9797162373860675
tp7524
sS"with open('filename') as f:\n    lines = f.readlines()"
p7525
(F-0.5001070976257325
F-2.5993006388346354
tp7526
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    pass"
p7527
(F-1.2220787837587554
F-2.57928466796875
tp7528
sS'with open(fname) as f:\n    pass'
p7529
(F-1.212364741734096
F-2.7748764038085936
tp7530
sS"with open('file.txt', 'r') as ins:\n    pass"
p7531
(F-0.8906539082527161
F-2.777740224202474
tp7532
sS"with open('file.txt', 'r') as ins:\n    array = []"
p7533
(F-1.143917485287315
F-2.6733729044596353
tp7534
sS'for line in ins:\n    array.append(line)'
p7535
(F-0.9667084217071533
F-2.736006164550781
tp7536
sS'array = []'
p7537
(F-3.830625851949056
F-3.229436747233073
tp7538
sS'content = f.readlines()'
p7539
(F-1.4729849497477214
F-2.942650858561198
tp7540
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    array.append(line)"
p7541
(F-1.1179253073299633
F-2.567803955078125
tp7542
sS'lines = f.readlines()'
p7543
(F-1.486013306511773
F-2.598302714029948
tp7544
sS'with open(fname) as f:\n    content = f.readlines()'
p7545
(F-0.7523337364196777
F-2.676643880208333
tp7546
sS"lines = [line.rstrip('\\n') for line in open('filename')]"
p7547
(F-1.3106758719996403
F-2.533568572998047
tp7548
sS'for line in ins:\n    pass'
p7549
(F-1.1467168981378728
F-2.7249295552571615
tp7550
sS"with open('filename') as f:\n    pass"
p7551
(F-0.9909789221627372
F-2.777818552652995
tp7552
ssI5844672
(dp7553
S'def removekey(d, key):\n    r = dict(d)\ndel r[key]\nreturn r'
p7554
(F-2.6456666673932756
F-1.8915355205535889
tp7555
sS'a'
p7556
(F-8.164070129394531
F-2.0826518535614014
tp7557
sS'del d[key]'
p7558
(F-3.2991425650460378
F-1.8163528442382812
tp7559
sS'del r[key]\nreturn r'
p7560
(F-3.9312297821044924
F-1.9207944869995117
tp7561
sS'{i: a[i] for i in a if (i != 0)}'
p7562
(F-2.8637271881103517
F-1.8851113319396973
tp7563
sS'def removekey(d, key):\n    pass'
p7564
(F-1.4112179619925362
F-2.0385003089904785
tp7565
sS'return r'
p7566
(F-4.562613487243652
F-2.2225117683410645
tp7567
sS'a\n{i: a[i] for i in a if (i != 0)}'
p7568
(F-3.430154627019709
F-1.9049110412597656
tp7569
sS'def removekey(d, key):\n    r = dict(d)'
p7570
(F-1.6102357161672491
F-1.9189515113830566
tp7571
sS'{}'
p7572
(F-5.2245378494262695
F-2.258765459060669
tp7573
sS'def removekey(d, key):\n    r = dict(d)\ndel r[key]'
p7574
(F-2.5068719482421873
F-1.8829295635223389
tp7575
sS'del r[key]'
p7576
(F-3.1701047079903737
F-1.8752977848052979
tp7577
sS'r = dict(d)'
p7578
(F-2.4146971702575684
F-1.8432202339172363
tp7579
sS"'gdbye'"
p7580
(F-4.34937858581543
F-2.3338167667388916
tp7581
ssI16296643
(dp7582
S'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)\na[x][y] = 1'
p7583
(F-2.832428296407064
F-3.5590038299560547
tp7584
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl\ntuple(l)"
p7585
(F-2.0478416789661753
F-3.3178865909576416
tp7586
sS"t = ('my', 'name', 'is', 'mr', 'tuple')"
p7587
(F-1.555120086669922
F-3.5043015480041504
tp7588
sS'y = ((mousex + cameraX) // 60)\na[x][y] = 1'
p7589
(F-2.421117533808169
F-3.46071195602417
tp7590
sS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)'
p7591
(F-3.036102897242496
F-3.5903518199920654
tp7592
sS'tuple((tuple(i) for i in edited))'
p7593
(F-1.8783058166503905
F-3.236400842666626
tp7594
sS'if (clicked[0] == 1):\n    pass'
p7595
(F-2.587941884994507
F-3.6334824562072754
tp7596
sS'tuple(itertools.imap(tuple, edited))'
p7597
(F-2.125863735492413
F-3.5924477577209473
tp7598
sS'map(list, level)'
p7599
(F-2.8794667720794678
F-3.406967878341675
tp7600
sS'l\ntuple(l)'
p7601
(F-4.630420684814453
F-3.245084762573242
tp7602
sS"l = ['my', 'name', 'is', 'mr', 'list']"
p7603
(F-1.406167221069336
F-3.3671984672546387
tp7604
sS'a[x][y] = 1'
p7605
(F-2.4040164947509766
F-3.4476428031921387
tp7606
sS'level1 = [list(row) for row in level1]'
p7607
(F-1.2670905249459403
F-3.4046497344970703
tp7608
sS'a = numpy.array(level1)'
p7609
(F-2.1969398498535155
F-3.749995708465576
tp7610
sS'list(t)'
p7611
(F-2.422038714090983
F-3.348863124847412
tp7612
sS'level1 = map(list, level1)'
p7613
(F-1.7990262985229493
F-3.47288179397583
tp7614
sS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt"
p7615
(F-2.544909757726333
F-3.4733211994171143
tp7616
sS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)'
p7617
(F-2.9188446631798377
F-3.539790153503418
tp7618
sS't\nlist(t)'
p7619
(F-4.567893028259277
F-3.347132682800293
tp7620
sS'tuple(l)'
p7621
(F-2.2745747566223145
F-3.2134876251220703
tp7622
sS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt\nlist(t)"
p7623
(F-2.3052760037508877
F-3.3433456420898438
tp7624
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl"
p7625
(F-2.229732737821691
F-3.350045680999756
tp7626
sS'a'
p7627
(F-8.304997126261393
F-3.4662771224975586
tp7628
sS'a = numpy.array(level1)\na'
p7629
(F-3.771635055541992
F-3.7198381423950195
tp7630
sS'[list(i) for i in level]'
p7631
(F-2.4046680132548013
F-3.3009581565856934
tp7632
sS'x = ((mousey + cameraY) // 60)'
p7633
(F-2.6075826791616588
F-3.3403334617614746
tp7634
sS'l'
p7635
(F-8.974748611450195
F-3.3425707817077637
tp7636
sS'y = ((mousex + cameraX) // 60)'
p7637
(F-2.714025644155649
F-3.4669978618621826
tp7638
sS't'
p7639
(F-9.097792307535807
F-3.597097873687744
tp7640
ssI4004550
(dp7641
S'floats = map(float, s.split())'
p7642
(F-2.2749364035470143
F-2.6262887954711913
tp7643
sS"s = '5.2 5.6 5.3'"
p7644
(F-3.208383560180664
F-2.7525985717773436
tp7645
sS'floats = [float(x) for x in s.split()]'
p7646
(F-1.7538311216566298
F-2.6760927200317384
tp7647
sS"s = '5.2 5.6 5.3'\nfloats = [float(x) for x in s.split()]"
p7648
(F-1.7995974800803445
F-2.6232566833496094
tp7649
ssI10543303
(dp7650
S'j = [4, 5, 6, 7, 1, 3, 7, 5]'
p7651
(F-1.9291320074172247
F-2.4169622567983775
tp7652
sS'j = np.array(j)'
p7653
(F-1.7634485244750977
F-2.770305926983173
tp7654
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nsum(((i > 5) for i in j))'
p7655
(F-2.2069905598958335
F-2.4194561884953427
tp7656
sS'sum((j > i))'
p7657
(F-3.7161041259765626
F-2.446106690626878
tp7658
sS'len([1 for i in j if (i > 5)])'
p7659
(F-3.5111211140950522
F-2.462591611422025
tp7660
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nlen([1 for i in j if (i > 5)])'
p7661
(F-2.5578129417017887
F-2.4132860623873196
tp7662
sS'import numpy as np\nj = np.array(j)'
p7663
(F-1.4041133880615235
F-2.768469003530649
tp7664
sS'sum(((i > 5) for i in j))'
p7665
(F-2.5184481143951416
F-2.422686063326322
tp7666
sS'import numpy as np'
p7667
(F-3.821366310119629
F-2.8067626953125
tp7668
sS'issubclass(bool, int)'
p7669
(F-3.3032875061035156
F-3.2771747295673075
tp7670
sS'import numpy as np\nj = np.array(j)\nsum((j > i))'
p7671
(F-2.3543790181477866
F-2.7171043982872596
tp7672
sS'j = np.array(j)\nsum((j > i))'
p7673
(F-2.957541214792352
F-2.704930232121394
tp7674
ssI432842
(dp7675
S'return (bool(str1) ^ bool(str2))'
p7676
(F-3.4733992985316684
F-2.5860244750976564
tp7677
sS'from operator import xor\nxor(bool(a), bool(b))'
p7678
(F-4.334697522615132
F-2.056995900472005
tp7679
sS'(bool(a) ^ bool(b))'
p7680
(F-4.071761204646184
F-2.3173922220865886
tp7681
sS'xor(bool(a), bool(b))'
p7682
(F-4.038315636771066
F-2.300738525390625
tp7683
sS'(bool(a) != bool(b))'
p7684
(F-3.8077964782714844
F-2.3607945760091145
tp7685
sS'((a and (not b)) or ((not a) and b))'
p7686
(F-5.3332708449590776
F-2.1659581502278646
tp7687
sS'def logical_xor(str1, str2):\n    pass'
p7688
(F-2.1630916595458984
F-2.0896939595540363
tp7689
sS'def logical_xor(str1, str2):\n    return (bool(str1) ^ bool(str2))'
p7690
(F-2.7454636185257524
F-2.219257100423177
tp7691
sS'from operator import xor'
p7692
(F-6.253157297770183
F-2.002887471516927
tp7693
ssI1303243
(dp7694
S'(type(o) is str)'
p7695
(F-4.28321533203125
F-2.1239870616367886
tp7696
sS'isinstance(o, str)'
p7697
(F-2.7272679805755615
F-2.0531463623046875
tp7698
sS'isinstance(o, basestring)'
p7699
(F-2.4070041179656982
F-2.069826126098633
tp7700
sS'isinstance(obj_to_test, str)'
p7701
(F-3.055055618286133
F-2.1278939928327287
tp7702
ssI163542
(dp7703
S'p.stdin.close()'
p7704
(F-1.4299031363593206
F-3.151507786342076
tp7705
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p7706
(F-1.5655061227303964
F-3.1528701782226562
tp7707
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7708
(F-1.8145713027642698
F-3.183701651436942
tp7709
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p7710
(F-0.9351252931537051
F-3.191075642903646
tp7711
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)"
p7712
(F-0.6152981244600736
F-3.2005716959635415
tp7713
sS'print grep_stdout.decode()'
p7714
(F-4.282793426513672
F-3.13385009765625
tp7715
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p7716
(F-1.4846816062927246
F-3.1471470424107144
tp7717
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p7718
(F-0.9350490570068359
F-3.1908707391648066
tp7719
sS'from subprocess import Popen, PIPE, STDOUT'
p7720
(F-2.0451967239379885
F-3.1902738298688615
tp7721
sS"pipe = os.popen(cmd, 'w', bufsize)\npipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin"
p7722
(F-2.53013916015625
F-3.166465395972842
tp7723
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p7724
(F-2.066858225855334
F-3.1779654366629466
tp7725
sS'p.communicate()[0]'
p7726
(F-2.063005065917969
F-3.1562100365048362
tp7727
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p7728
(F-1.106280247370402
F-3.178519839332217
tp7729
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p7730
(F-0.7159805297851562
F-3.1921077909923734
tp7731
sS"pipe = os.popen(cmd, 'w', bufsize)"
p7732
(F-2.828169958932059
F-3.216371082124256
tp7733
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p7734
(F-2.4031753540039062
F-3.1670321509951638
tp7735
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p7736
(F-1.6600588748329563
F-3.1545933314732144
tp7737
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7738
(F-2.1100536346435548
F-3.1730746314639138
tp7739
sS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7740
(F-3.2679075353285847
F-3.1630565098353793
tp7741
sS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint grep_stdout.decode()"
p7742
(F-3.446575164794922
F-3.151558285667783
tp7743
sS'p.communicate()[0]\np.stdin.close()'
p7744
(F-1.7685879601372614
F-3.1514576503208707
tp7745
sS'pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin'
p7746
(F-2.248727625066584
F-3.1707298642113093
tp7747
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p7748
(F-1.00292785351093
F-3.1879980904715404
tp7749
ssI306400
(dp7750
S'second_random_item = list_of_random_items[1]'
p7751
(F-3.42605103386773
F-1.745568084716797
tp7752
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7753
(F-3.0694076183230377
F-1.7543436686197917
tp7754
sS'random_index = randrange(0, len(foo))\nprint foo[random_index]'
p7755
(F-2.906851395316746
F-1.782824961344401
tp7756
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7757
(F-3.0035302461083258
F-1.740112050374349
tp7758
sS'first_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7759
(F-3.0632010323660714
F-1.7405890146891276
tp7760
sS'from random import randrange'
p7761
(F-3.604523022969564
F-1.8070037841796875
tp7762
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7763
(F-2.9454794384184337
F-1.7445515950520833
tp7764
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7765
(F-2.9436052695088004
F-1.7610858917236327
tp7766
sS'print foo[random_index]'
p7767
(F-2.680473963419596
F-1.7777488708496094
tp7768
sS'first_random_item = list_of_random_items[0]'
p7769
(F-3.3104390038384333
F-1.7359298706054687
tp7770
sS'import random'
p7771
(F-5.221081733703613
F-1.8763622283935546
tp7772
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p7773
(F-2.9838550495651535
F-1.7465615590413412
tp7774
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))"
p7775
(F-1.7740866717170267
F-1.7767454783121746
tp7776
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7777
(F-3.001210021972656
F-1.7562697092692057
tp7778
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p7779
(F-3.3267144775390625
F-1.7666257222493489
tp7780
sS"foo = ['a', 'b', 'c', 'd', 'e']"
p7781
(F-1.2569302876790365
F-1.901022974650065
tp7782
sS'group_of_items = {1, 2, 3, 4}'
p7783
(F-3.1337051391601562
F-1.7710399627685547
tp7784
sS'list_of_random_items = random.sample(group_of_items, num_to_select)'
p7785
(F-3.033678494966947
F-1.7467503865559897
tp7786
sS"foo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p7787
(F-0.8470094100288723
F-1.7760581970214844
tp7788
sS'num_to_select = 2'
p7789
(F-4.350520239935981
F-2.2829615275065103
tp7790
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p7791
(F-0.856989493736854
F-1.7815728505452475
tp7792
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange"
p7793
(F-1.7407052993774415
F-1.7804904937744142
tp7794
sS'from random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]'
p7795
(F-2.4174401419503346
F-1.7793529510498047
tp7796
sS'import random\ngroup_of_items = {1, 2, 3, 4}'
p7797
(F-3.2170944213867188
F-1.7226170857747396
tp7798
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p7799
(F-2.974436950683594
F-1.7347157796223958
tp7800
sS'from random import randrange\nrandom_index = randrange(0, len(foo))'
p7801
(F-2.2878654479980467
F-1.7913405100504558
tp7802
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p7803
(F-3.319036211286272
F-1.7308672587076823
tp7804
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]"
p7805
(F-1.955046154203869
F-1.773218282063802
tp7806
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7807
(F-3.088884241440717
F-1.7643811543782553
tp7808
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']"
p7809
(F-1.3098759121365018
F-1.8191034952799479
tp7810
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p7811
(F-3.2023369284237133
F-1.7625517527262369
tp7812
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p7813
(F-2.9594187418619793
F-1.7584676106770833
tp7814
sS'print random.choice(foo)'
p7815
(F-1.6170742246839735
F-1.8272164662679036
tp7816
sS'random_index = randrange(0, len(foo))'
p7817
(F-2.9381060282389324
F-1.8089162190755208
tp7818
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p7819
(F-3.226328457103056
F-1.7598796844482423
tp7820
ssI3996904
(dp7821
S'print random.randint(0, 9)'
p7822
(F-1.6384145563299006
F-4.024521721733941
tp7823
sS'frand = uniform(0, 10)'
p7824
(F-2.5696216583251954
F-4.584778679741754
tp7825
sS'irand = randrange(0, 10)'
p7826
(F-1.8261825561523437
F-4.431640625
tp7827
sS'import random'
p7828
(F-4.962852478027344
F-4.107741885715061
tp7829
sS'import random\nprint random.randint(0, 9)'
p7830
(F-1.402336801801409
F-4.029936048719618
tp7831
sS'from random import randrange, uniform'
p7832
(F-3.895902633666992
F-4.097921159532335
tp7833
sS'from random import randint\nprint randint(0, 9)'
p7834
(F-1.8173697335379464
F-4.110198126898871
tp7835
sS'from random import randrange, uniform\nirand = randrange(0, 10)'
p7836
(F-2.315240747788373
F-4.137085808648004
tp7837
sS'print randint(0, 9)'
p7838
(F-2.2684644063313804
F-4.208888583713108
tp7839
sS'from random import randint'
p7840
(F-3.3731091817220054
F-4.081321716308594
tp7841
sS'random.randint(a, b)'
p7842
(F-2.111716079711914
F-4.003483666314019
tp7843
sS'irand = randrange(0, 10)\nfrand = uniform(0, 10)'
p7844
(F-2.059854607833059
F-4.595856136745876
tp7845
sS'from random import randrange, uniform\nirand = randrange(0, 10)\nfrand = uniform(0, 10)'
p7846
(F-2.247820780827449
F-4.203588273790148
tp7847
ssI627435
(dp7848
S'global index\na.pop(index)'
p7849
(F-3.482421181418679
F-1.6269329071044922
tp7850
sS'def __init__(self, items):\n    pass'
p7851
(F-1.645770788192749
F-1.9257443745930989
tp7852
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p7853
(F-1.3219087627572073
F-1.7717580159505208
tp7854
sS'def del_method():\n    global a'
p7855
(F-2.5702661786760603
F-2.014780044555664
tp7856
sS'a = range(10)\nindex = 3'
p7857
(F-3.101084073384603
F-1.7287050882975261
tp7858
sS'def pop_method():\n    global a\nglobal index\na.pop(index)'
p7859
(F-3.4919541676839194
F-1.7115928649902343
tp7860
sS'del a[index]'
p7861
(F-3.3545379638671875
F-1.6576276143391928
tp7862
sS'global index\na = (a[:index] + a[(index + 1):])'
p7863
(F-3.4453035990397134
F-1.6738301595052083
tp7864
sS'def del_method():\n    global a\nglobal index'
p7865
(F-3.6769099516027115
F-2.0398943583170572
tp7866
sS'index = 3\na = (a[:index] + a[(index + 1):])'
p7867
(F-3.1468890380859373
F-1.6651842753092447
tp7868
sS'def slice_method():\n    global a\nglobal index\na = (a[:index] + a[(index + 1):])'
p7869
(F-3.464790138038429
F-1.6612258911132813
tp7870
sS'a\ndel a[(-1)]\na'
p7871
(F-5.16840090070452
F-1.7030934651692708
tp7872
sS'return foo((self.items + right.items))'
p7873
(F-3.5868932088216146
F-1.6608167012532553
tp7874
sS'a.pop(index)'
p7875
(F-2.4646267890930176
F-1.6072069803873699
tp7876
sS'a.pop()'
p7877
(F-2.169510705130441
F-1.6159910837809244
tp7878
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])'
p7879
(F-1.2775590376420454
F-1.7761983235677083
tp7880
sS'a = range(10)\na\ndel a[(-1)]'
p7881
(F-3.8498490986071134
F-1.7143707275390625
tp7882
sS'a = [1, 2, 3, 4, 5, 6]\nindex = 3'
p7883
(F-2.10610108148484
F-1.6503454844156902
tp7884
sS'return foo(self.items[index])'
p7885
(F-2.7872034708658853
F-1.7640589396158854
tp7886
sS'a = [1, 2, 3, 4, 5, 6]\nindex = 3\na = (a[:index] + a[(index + 1):])'
p7887
(F-2.2370862263004954
F-1.642132822672526
tp7888
sS'a = (a[:index] + a[(index + 1):])'
p7889
(F-2.9447571890694753
F-1.6617632548014323
tp7890
sS'class foo(object):\n    pass'
p7891
(F-1.2429324785868328
F-1.847833760579427
tp7892
sS'a = range(10)\na\ndel a[(-1)]\na'
p7893
(F-4.314662388392857
F-1.709362538655599
tp7894
sS'class foo(object):\n\n    def __init__(self, items):\n        pass'
p7895
(F-1.1318200184748723
F-1.847796885172526
tp7896
sS'def slice_method():\n    global a\nglobal index'
p7897
(F-3.9383930879480697
F-1.663897450764974
tp7898
sS'index = 3'
p7899
(F-5.251175308227539
F-1.6992080688476563
tp7900
sS'a\ndel a[(-1)]'
p7901
(F-4.502402623494466
F-1.7194066365559897
tp7902
sS'def del_method():\n    pass'
p7903
(F-2.433232380793645
F-2.061170705159505
tp7904
sS'a = range(10)\na'
p7905
(F-3.6322952270507813
F-1.7381573994954427
tp7906
sS'a'
p7907
(F-8.270444869995117
F-1.7577550252278646
tp7908
sS'a.pop(1)'
p7909
(F-1.686151385307312
F-1.618146006266276
tp7910
sS'def slice_method():\n    global a'
p7911
(F-2.900924955095564
F-1.6543075561523437
tp7912
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p7913
(F-1.9519248818451505
F-1.693670399983724
tp7914
sS'def pop_method():\n    global a'
p7915
(F-2.7177401951381137
F-1.8499440511067708
tp7916
sS'def del_method():\n    global a\nglobal index\ndel a[index]'
p7917
(F-3.892928413722826
F-1.8779136657714843
tp7918
sS'a = range(10)'
p7919
(F-2.508331537246704
F-1.7557075500488282
tp7920
sS'self.items = items'
p7921
(F-3.400251933506557
F-1.7807432810465496
tp7922
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    pass'
p7923
(F-1.2065358369246773
F-1.8058387756347656
tp7924
sS'global index\ndel a[index]'
p7925
(F-4.598849487304688
F-1.6864542643229166
tp7926
sS'def __init__(self, items):\n    self.items = items'
p7927
(F-1.7163257598876953
F-1.8363154093424479
tp7928
sS'def pop_method():\n    pass'
p7929
(F-2.57797123835637
F-1.8950845082600911
tp7930
sS'del a[(-1)]\na'
p7931
(F-5.142610232035319
F-1.6915096282958983
tp7932
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items'
p7933
(F-1.121985880533854
F-1.8047403971354166
tp7934
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p7935
(F-1.5607913833066642
F-1.732732391357422
tp7936
sS"a = ['a', 'b', 'c', 'd']\na.pop(1)"
p7937
(F-1.3774405479431153
F-1.5997889200846354
tp7938
sS'del a[(-1)]'
p7939
(F-4.265907287597656
F-1.7085985819498697
tp7940
sS'global index'
p7941
(F-5.821079254150391
F-1.9208684285481772
tp7942
sS'def __getitem__(self, index):\n    return foo(self.items[index])'
p7943
(F-1.7674700927734375
F-1.805627950032552
tp7944
sS'def __add__(self, right):\n    pass'
p7945
(F-1.9570621252059937
F-1.847266387939453
tp7946
sS"a = ['a', 'b', 'c', 'd']\na.pop()"
p7947
(F-1.565262844688014
F-1.6015282948811849
tp7948
sS'def slice_method():\n    pass'
p7949
(F-2.7806783822866588
F-1.6715787251790364
tp7950
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p7951
(F-1.642165579446932
F-1.7772872924804688
tp7952
sS"a = ['a', 'b', 'c', 'd']"
p7953
(F-1.6840692666860728
F-1.6764755249023438
tp7954
sS'def __add__(self, right):\n    return foo((self.items + right.items))'
p7955
(F-2.4820567539760043
F-1.705194854736328
tp7956
sS'def pop_method():\n    global a\nglobal index'
p7957
(F-3.779374964096967
F-1.8756674448649089
tp7958
sS'global a'
p7959
(F-5.9687700271606445
F-1.9173894246419272
tp7960
sS'a = [1, 2, 3, 4, 5, 6]'
p7961
(F-1.6662425994873047
F-1.6585552215576171
tp7962
sS'def __getitem__(self, index):\n    pass'
p7963
(F-1.7557520866394043
F-1.9296526590983072
tp7964
ssI1773805
(dp7965
S"with open('example.yaml') as stream:\n    pass"
p7966
(F-1.5574289049421037
F-1.7045506564053623
tp7967
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7968
(F-2.3976661612134462
F-1.7060040560635654
tp7969
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7970
(F-2.429722528872283
F-1.7116153023459695
tp7971
sS"with open('example.yaml', 'r') as stream:\n    pass"
p7972
(F-1.302227258682251
F-1.7073922590775923
tp7973
sS'data_loaded = yaml.load(stream)'
p7974
(F-3.7607905069986978
F-1.821080294522372
tp7975
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p7976
(F-2.380134845602101
F-1.6979709972034802
tp7977
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p7978
(F-2.4311852888627485
F-1.734858599576083
tp7979
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p7980
(F-2.06187744140625
F-1.695613514293324
tp7981
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7982
(F-2.4046807970319475
F-1.7099767164750532
tp7983
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p7984
(F-1.5658903988924893
F-1.7106545188210227
tp7985
sS'print exc'
p7986
(F-3.683718681335449
F-1.7051700245250354
tp7987
sS'import yaml'
p7988
(F-5.856811046600342
F-1.6889964017001065
tp7989
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p7990
(F-2.5917450754266036
F-1.6951609524813565
tp7991
sS"with open('data.yaml', 'r') as stream:\n    pass"
p7992
(F-1.302227258682251
F-1.7073922590775923
tp7993
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p7994
(F-1.996497310809235
F-1.713410117409446
tp7995
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p7996
(F-2.4741375830865677
F-1.7048988342285156
tp7997
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p7998
(F-2.5468583747522153
F-1.7037467956542969
tp7999
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8000
(F-2.3407718010668486
F-1.706505688753995
tp8001
sS'import ruamel.yaml as yaml'
p8002
(F-5.610107421875
F-1.7060902335427024
tp8003
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p8004
(F-2.448112046423037
F-1.7032104838978162
tp8005
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8006
(F-2.306795435044372
F-1.7051362124356357
tp8007
sS'print (data == data_loaded)'
p8008
(F-3.4982536315917967
F-1.6629395918412642
tp8009
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8010
(F-2.6583308730014537
F-1.7578537680886008
tp8011
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8012
(F-1.9601258039474487
F-1.7129936218261719
tp8013
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8014
(F-2.468529837472098
F-1.735503456809304
tp8015
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p8016
(F-2.404765858369715
F-1.6396054354580967
tp8017
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8018
(F-2.1902255249023437
F-1.6449541612104936
tp8019
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint (data == data_loaded)"
p8020
(F-2.4401511499437234
F-1.700793526389382
tp8021
sS"import yaml\nwith open('example.yaml', 'r') as stream:\n    pass"
p8022
(F-1.5275841763145046
F-1.6327906521883877
tp8023
sS'yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)'
p8024
(F-3.4644851684570312
F-1.9150019558993252
tp8025
sS'import io'
p8026
(F-6.013164520263672
F-1.721386649391868
tp8027
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8028
(F-2.196167987325917
F-1.7379465970126065
tp8029
sS'print yaml.load(stream)'
p8030
(F-3.001410802205404
F-1.6686051108620383
tp8031
sS'import yaml\nimport io'
p8032
(F-4.619287763323102
F-1.6279791051691228
tp8033
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8034
(F-2.2895043820750955
F-1.7219179326837712
tp8035
sS"import ruamel.yaml as yaml\nwith open('example.yaml') as stream:\n    pass"
p8036
(F-2.5226137070428756
F-1.6397982510653408
tp8037
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8038
(F-2.1063512757767078
F-1.8575508811257102
tp8039
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8040
(F-2.416213271197151
F-1.7350384105335583
tp8041
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8042
(F-2.29218994140625
F-1.7037988142533735
tp8043
ssI663171
(dp8044
S"x = 'Hello World!'"
p8045
(F-3.412755584716797
F-1.9479179382324219
tp8046
sS'x[:2]\nx[:(-2)]\nx[(-2):]'
p8047
(F-4.349446411132813
F-2.0309983766995945
tp8048
sS'x[:(-2)]\nx[(-2):]'
p8049
(F-4.5954943205180925
F-2.0351169292743387
tp8050
sS'x[:2]'
p8051
(F-3.6772193908691406
F-1.9756453587458684
tp8052
sS'x[(-2):]\nx[2:(-2)]'
p8053
(F-4.633389282226562
F-2.0227262056790867
tp8054
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]"
p8055
(F-3.619752938406808
F-1.9805359473595252
tp8056
sS'x[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8057
(F-4.365181232320851
F-2.0389490861159105
tp8058
sS'x[:(-2)]'
p8059
(F-4.160770416259766
F-2.0177415701059194
tp8060
sS'x[2:]\nx[:2]'
p8061
(F-3.3207784799429088
F-1.9598812690147986
tp8062
sS'x[:2]\nx[:(-2)]'
p8063
(F-3.9633350372314453
F-2.0076222052940955
tp8064
sS"x = 'Hello World!'\nx[2:]\nx[:2]"
p8065
(F-2.8287472444422104
F-1.908206059382512
tp8066
sS'x[2:]'
p8067
(F-2.747338431222098
F-1.9474386068490834
tp8068
sS"'H-e-l-l-o- -W-o-r-l-d'[::2]"
p8069
(F-3.4797942638397217
F-1.8454164358285756
tp8070
sS'x[(-2):]'
p8071
(F-5.250286865234375
F-2.0174429966853213
tp8072
sS's = Substr(s, beginning, LENGTH)'
p8073
(F-2.197873115539551
F-1.84674439063439
tp8074
sS'x[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8075
(F-4.217078944614955
F-2.0386490455040565
tp8076
sS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8077
(F-4.012402418183117
F-2.017719562237079
tp8078
sS'some_string[::(-1)]'
p8079
(F-4.153219956618089
F-1.8273987403282752
tp8080
sS"x = 'Hello World!'\nx[2:]"
p8081
(F-2.2548273259943183
F-1.8930681668795073
tp8082
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]"
p8083
(F-3.698300509982639
F-1.9978507115290716
tp8084
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]"
p8085
(F-3.1981201171875
F-1.9484974787785456
tp8086
sS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]'
p8087
(F-4.062398356776083
F-2.0068497290978065
tp8088
sS'x[2:]\nx[:2]\nx[:(-2)]'
p8089
(F-3.668948086825284
F-1.9823075808011568
tp8090
sS'x[2:(-2)]'
p8091
(F-3.911203211004084
F-1.9866451850304236
tp8092
sS's = s[beginning:(beginning + LENGTH)]'
p8093
(F-3.6591102055140903
F-1.8101959228515625
tp8094
ssI1185524
(dp8095
S'str.lstrip()'
p8096
(F-1.6578050340924944
F-4.416524713689631
tp8097
sS'str.strip()\nstr.lstrip()'
p8098
(F-2.0227989783653846
F-4.311646201393821
tp8099
sS"s = '   foo    \\t   '"
p8100
(F-2.854117584228516
F-4.3227105574174365
tp8101
sS"s = s.strip(' \\t\\n\\r')"
p8102
(F-1.798605728149414
F-4.257845098322088
tp8103
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8104
(F-1.4323043823242188
F-4.222574407404119
tp8105
sS"print pat.sub('', s)"
p8106
(F-1.7370007254860618
F-4.276747616854581
tp8107
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8108
(F-1.2306933403015137
F-4.269230929287997
tp8109
sS"import re\nprint re.sub('[\\\\s+]', '', s)"
p8110
(F-0.7863902449607849
F-4.176150928844105
tp8111
sS"print re.sub('[\\\\s+]', '', s)"
p8112
(F-0.9337594692523663
F-4.204835718328303
tp8113
sS's = s.lstrip()'
p8114
(F-1.9271757337782118
F-4.324583573774858
tp8115
sS'str.strip()'
p8116
(F-1.6319125039236886
F-4.26616807417436
tp8117
sS"pat = re.compile('\\\\s+')"
p8118
(F-1.0827960968017578
F-4.283436168323863
tp8119
sS"s = '  \\t a string example\\t  '"
p8120
(F-2.854117584228516
F-4.3227105574174365
tp8121
sS'str.rstrip()'
p8122
(F-1.6578053065708704
F-4.416524713689631
tp8123
sS'print s.strip()'
p8124
(F-2.0932905673980713
F-4.231809789484197
tp8125
sS'import re'
p8126
(F-4.681537628173828
F-4.166338833895597
tp8127
sS'str.lstrip()\nstr.rstrip()'
p8128
(F-2.0459315960223856
F-4.415001262318004
tp8129
sS's = s.strip()'
p8130
(F-2.0390781826443143
F-4.252577694979581
tp8131
sS"s = '   foo    \\t   '\nprint s.strip()"
p8132
(F-1.5270665486653645
F-4.2365805886008525
tp8133
sS"s = '  \\t a string example\\t  '\ns = s.strip()"
p8134
(F-1.7635628626896784
F-4.254569660533559
tp8135
sS's = s.rstrip()'
p8136
(F-1.9271757337782118
F-4.324583573774858
tp8137
sS'str.strip()\nstr.lstrip()\nstr.rstrip()'
p8138
(F-2.1494740937885486
F-4.331686540083452
tp8139
sS'astringexample'
p8140
(F-6.6962534586588545
F-4.453984000466087
tp8141
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8142
(F-1.0142396291097004
F-4.227955904873935
tp8143
sS"s = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8144
(F-1.342198944091797
F-4.264678955078125
tp8145
sS"import re\npat = re.compile('\\\\s+')"
p8146
(F-0.9760686434232272
F-4.217885450883345
tp8147
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8148
(F-1.8310699462890625
F-4.27620419588956
tp8149
sS"s = '  \\t  foo   \\t   bar \\t  '"
p8150
(F-2.854117584228516
F-4.3227105574174365
tp8151
ssI354038
(dp8152
S"b = '963spam'\nb.isdigit()"
p8153
(F-2.1683869795365767
F-1.8901930914984808
tp8154
sS"a = '03523'\na.isdigit()\nb = '963spam'\nb.isdigit()"
p8155
(F-2.140578860328311
F-1.876832538180881
tp8156
sS'a.isdigit()'
p8157
(F-1.9315948486328125
F-1.9162491692437067
tp8158
sS"a = '03523'"
p8159
(F-3.4557456970214844
F-1.838944329155816
tp8160
sS"a = '03523'\na.isdigit()\nb = '963spam'"
p8161
(F-2.7104209899902343
F-1.848631329006619
tp8162
sS"a.isdigit()\nb = '963spam'"
p8163
(F-3.32497822154652
F-1.8870247734917536
tp8164
sS'b.isdigit()'
p8165
(F-2.3747561318533763
F-1.9891690148247614
tp8166
sS"b = '963spam'"
p8167
(F-3.5802902221679687
F-1.8586900499131944
tp8168
sS"a.isdigit()\nb = '963spam'\nb.isdigit()"
p8169
(F-2.4982764300178077
F-1.9142095777723525
tp8170
sS"float('NaN')"
p8171
(F-1.9541209538777669
F-1.8561358981662326
tp8172
sS"a = '03523'\na.isdigit()"
p8173
(F-1.934061050415039
F-1.8627276950412326
tp8174
ssI2600191
(dp8175
S'[1, 2, 3, 4, 1, 4, 1].count(1)'
p8176
(F-2.397836858575994
F-2.063803863525391
tp8177
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]"
p8178
(F-2.3357703916488157
F-1.899782943725586
tp8179
sS"l = ['a', 'b', 'b']"
p8180
(F-1.8549874045632102
F-2.1746180216471354
tp8181
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8182
(F-2.6121845592151987
F-2.287425231933594
tp8183
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))"
p8184
(F-2.4061912254050926
F-1.8724721272786458
tp8185
sS'import timeit'
p8186
(F-7.20515775680542
F-2.2649716695149738
tp8187
sS"l.count('a')\nl.count('b')"
p8188
(F-2.6599886576334635
F-2.161559295654297
tp8189
sS'from collections import Counter\nCounter(l)'
p8190
(F-2.112200130115856
F-1.931224568684896
tp8191
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8192
(F-3.0368109038381865
F-2.284081776936849
tp8193
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8194
(F-1.6033281396936487
F-2.0926377614339193
tp8195
sS'from collections import Counter'
p8196
(F-3.5553614298502603
F-1.99591916402181
tp8197
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8198
(F-1.5346843495088465
F-2.2310282389322915
tp8199
sS"l = ['a', 'b', 'b']\nfrom collections import Counter"
p8200
(F-2.2575011253356934
F-2.0184906005859373
tp8201
sS'Counter(l)'
p8202
(F-2.2289870580037436
F-2.093149948120117
tp8203
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8204
(F-1.365551688454368
F-2.1899134318033853
tp8205
sS"print 'count():   ', t2.repeat(repeat=3, number=10000)"
p8206
(F-2.886638416963465
F-2.25830078125
tp8207
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8208
(F-2.1831456820170083
F-2.311681874593099
tp8209
sS'dict(((x, l.count(x)) for x in set(l)))'
p8210
(F-2.3487987518310547
F-1.8628236134847005
tp8211
sS"l.count('b')"
p8212
(F-2.617049217224121
F-2.1779411315917967
tp8213
sS"l = ['a', 'b', 'b']\nl.count('a')"
p8214
(F-1.75764889187283
F-2.0929112752278645
tp8215
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8216
(F-2.7568050731312144
F-2.281363932291667
tp8217
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8218
(F-2.2884456927959738
F-2.2483497619628907
tp8219
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8220
(F-2.570664269583566
F-2.2460848490397134
tp8221
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8222
(F-2.420562744140625
F-2.142847696940104
tp8223
sS"l = ['a', 'b', 'b']\nl.count('a')\nl.count('b')"
p8224
(F-1.9325521850585938
F-2.095301055908203
tp8225
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8226
(F-2.1831456820170083
F-2.311681874593099
tp8227
sS"l.count('a')"
p8228
(F-2.617049217224121
F-2.1779411315917967
tp8229
sS'[[x, l.count(x)] for x in set(l)]'
p8230
(F-2.443729582287016
F-1.8485827128092447
tp8231
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8232
(F-2.5838938745959052
F-2.1852399190266927
tp8233
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8234
(F-2.223515220310377
F-2.3127095540364584
tp8235
sS"l = ['a', 'b', 'b']\nfrom collections import Counter\nCounter(l)"
p8236
(F-1.765279315766834
F-1.976220194498698
tp8237
sS'[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))'
p8238
(F-2.5441530401056465
F-1.8411453247070313
tp8239
sS'Counter(z)'
p8240
(F-2.709392547607422
F-2.2181915283203124
tp8241
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8242
(F-1.742205186323686
F-2.0849349975585936
tp8243
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8244
(F-2.4711402893066405
F-2.2579241434733075
tp8245
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8246
(F-2.4338660606971154
F-2.2601801554361978
tp8247
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8248
(F-2.886638416963465
F-2.25830078125
tp8249
ssI845058
(dp8250
S'def mapcount(filename):\n    pass'
p8251
(F-1.6901009877522786
F-2.2973738583651455
tp8252
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8253
(F-1.9248251522288602
F-2.381987311623313
tp8254
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8255
(F-2.4603992618926585
F-2.413345683704723
tp8256
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8257
(F-2.3504254100768547
F-2.414655858820135
tp8258
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p8259
(F-2.0854876708984373
F-2.3734040693803267
tp8260
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8261
(F-2.8113418800243433
F-2.3597840395840732
tp8262
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8263
(F-2.3803792620236988
F-2.3761607083407315
tp8264
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8265
(F-2.4697694384362086
F-2.4098195162686435
tp8266
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8267
(F-2.2581120082310266
F-2.3636911565607246
tp8268
sS'lines = 0'
p8269
(F-4.977023696899414
F-2.2430577711625532
tp8270
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8271
(F-2.468651537625295
F-2.374341444535689
tp8272
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8273
(F-2.240744619658499
F-2.418698050759055
tp8274
sS'from __future__ import with_statement'
p8275
(F-1.7414167404174805
F-2.3112591830166904
tp8276
sS'return lines\n\ndef bufcount(filename):\n    pass'
p8277
(F-2.5566279888153076
F-2.293912887573242
tp8278
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p8279
(F-2.2984015997939222
F-2.4116498773748223
tp8280
sS'def simplecount(filename):\n    pass'
p8281
(F-1.6901009877522786
F-2.297374031760476
tp8282
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8283
(F-2.0872059171161954
F-2.358925212513317
tp8284
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8285
(F-2.2555140327004826
F-2.3778962222012607
tp8286
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8287
(F-2.3304493779721467
F-2.4123190099542793
tp8288
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8289
(F-2.38121803061476
F-2.4066956259987573
tp8290
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8291
(F-1.4529823303222655
F-2.3600080663507637
tp8292
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8293
(F-2.1897940384714225
F-2.3547259244051846
tp8294
sS"def mapcount(filename):\n    f = open(filename, 'r+')"
p8295
(F-1.237455267655222
F-2.3350758986039595
tp8296
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8297
(F-2.2996011559231824
F-2.3819150057705967
tp8298
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8299
(F-2.218309311639695
F-2.3351173400878906
tp8300
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8301
(F-1.7557745645212572
F-2.361927032470703
tp8302
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8303
(F-2.313967397522228
F-2.4126902493563565
tp8304
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8305
(F-2.3003530130757914
F-2.40329326282848
tp8306
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p8307
(F-2.2439166477748325
F-2.3865318298339844
tp8308
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8309
(F-2.2257353838752296
F-2.3542522083629263
tp8310
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8311
(F-2.3427168447760085
F-2.347109014337713
tp8312
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8313
(F-2.475390174971198
F-2.37516281821511
tp8314
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass'
p8315
(F-2.4587198893229165
F-2.2611831318248403
tp8316
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8317
(F-2.3203494348258618
F-2.413206620649858
tp8318
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8319
(F-2.4735391671316966
F-2.3787730823863638
tp8320
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8321
(F-2.413326379024621
F-2.393668434836648
tp8322
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8323
(F-2.3158085035241167
F-2.4183197021484375
tp8324
sS'readline = buf.readline'
p8325
(F-3.852400371006557
F-2.255035400390625
tp8326
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8327
(F-1.525830118279708
F-2.3386480158025567
tp8328
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8329
(F-2.2190556886817228
F-2.3856367631392046
tp8330
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8331
(F-2.4972680593501626
F-2.409865986217152
tp8332
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p8333
(F-1.4078415461948939
F-2.343568108298562
tp8334
sS"print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8335
(F-2.636683044433594
F-2.3627830852161753
tp8336
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8337
(F-2.4278929993346496
F-2.3463023792613638
tp8338
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8339
(F-2.0357346534729004
F-2.367761091752486
tp8340
sS'return lines\n\ndef simplecount(filename):\n    lines = 0'
p8341
(F-2.9830945332845054
F-2.2960446097634057
tp8342
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8343
(F-2.6450355529785154
F-2.3420500321821733
tp8344
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8345
(F-2.3414944904606516
F-2.29134126143022
tp8346
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8347
(F-2.405601791188687
F-2.404688228260387
tp8348
sS'pass'
p8349
(F-3.0512816111246743
F-2.3229715173894707
tp8350
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8351
(F-2.5356000716311073
F-2.373427997935902
tp8352
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8353
(F-2.329202196074695
F-2.404582977294922
tp8354
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8355
(F-2.1310521052433895
F-2.359148719094016
tp8356
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8357
(F-2.351978339037849
F-2.406185843727805
tp8358
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8359
(F-2.436857881601791
F-2.3817398764870386
tp8360
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p8361
(F-2.8307022958431602
F-2.346687663685192
tp8362
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8363
(F-2.277995194538985
F-2.4048791365189985
tp8364
sS'lines += 1'
p8365
(F-4.2416435241699215
F-2.213295503096147
tp8366
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8367
(F-2.643695068359375
F-2.3660654588179155
tp8368
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8369
(F-2.290913821187259
F-2.3785653547807173
tp8370
sS"f = open(filename, 'r+')"
p8371
(F-1.4662202835083007
F-2.34931096163663
tp8372
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8373
(F-1.9990543413765822
F-2.360913710160689
tp8374
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8375
(F-2.600646722512167
F-2.3727371909401636
tp8376
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8377
(F-2.060767775315505
F-2.361672141335227
tp8378
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8379
(F-2.55429516250281
F-2.4016508622602983
tp8380
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8381
(F-2.247125577059659
F-2.4099375984885474
tp8382
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8383
(F-2.170931199017693
F-2.378389011729847
tp8384
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8385
(F-2.3711346435546874
F-2.36920166015625
tp8386
sS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8387
(F-2.742176818847656
F-2.251432765613903
tp8388
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p8389
(F-3.2563174703846807
F-2.265525124289773
tp8390
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8391
(F-2.4799365628150203
F-2.4109784906560723
tp8392
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8393
(F-1.8801163653938138
F-2.3581362637606533
tp8394
sS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8395
(F-2.864104601801658
F-2.4500482732599433
tp8396
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8397
(F-2.2632496392548975
F-2.391101837158203
tp8398
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8399
(F-2.350078565958838
F-2.4086570739746094
tp8400
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8401
(F-2.2200147567256803
F-2.39471452886408
tp8402
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8403
(F-2.508699417114258
F-2.3650939247824927
tp8404
sS'buf = mmap.mmap(f.fileno(), 0)'
p8405
(F-1.863434910774231
F-2.3190161965110083
tp8406
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8407
(F-2.238625793457031
F-2.3664124228737573
tp8408
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8409
(F-2.605608996223001
F-2.4204063415527344
tp8410
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8411
(F-2.413605880737305
F-2.373310089111328
tp8412
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8413
(F-2.240092678541851
F-2.4067223288796167
tp8414
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8415
(F-1.745534826208044
F-2.385326212102717
tp8416
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8417
(F-2.283065089473018
F-2.3751779036088423
tp8418
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8419
(F-2.3672432701427715
F-2.3977088928222656
tp8420
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8421
(F-2.5742624406334307
F-2.3504506891424004
tp8422
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8423
(F-2.5125052712180396
F-2.361817620017312
tp8424
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p8425
(F-2.174396260579427
F-2.3597292466597124
tp8426
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8427
(F-2.149787081204928
F-2.3667293895374644
tp8428
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8429
(F-2.5123408924449575
F-2.4119333787397905
tp8430
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8431
(F-2.3392522475298714
F-2.392618179321289
tp8432
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8433
(F-2.295074289495295
F-2.3679745414040307
tp8434
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8435
(F-2.3349287553267044
F-2.375293558294123
tp8436
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8437
(F-2.423369376890121
F-2.3842572298916904
tp8438
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8439
(F-2.329938190739329
F-2.3819684115323154
tp8440
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8441
(F-2.6032872102698503
F-2.3686644814231177
tp8442
sS'read_f = f.read'
p8443
(F-3.6643252902560763
F-2.329612905328924
tp8444
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8445
(F-2.2069871690538196
F-2.357837677001953
tp8446
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8447
(F-2.274958865743288
F-2.3895672884854404
tp8448
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8449
(F-2.571940231323242
F-2.3049149946732954
tp8450
sS'buf = read_f(buf_size)\nreturn lines'
p8451
(F-2.6485326131184896
F-2.274947079745206
tp8452
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8453
(F-2.5328216552734375
F-2.412556214766069
tp8454
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline'
p8455
(F-3.0177359947791467
F-2.2760134610262783
tp8456
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8457
(F-2.4777358648345227
F-2.4163591211492363
tp8458
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p8459
(F-2.373173083289195
F-2.408013950694691
tp8460
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8461
(F-2.71810791984437
F-2.3495559692382812
tp8462
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8463
(F-2.621985093602594
F-2.3402057994495737
tp8464
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8465
(F-2.6391958421276462
F-2.34967023676092
tp8466
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p8467
(F-2.1103363037109375
F-2.3740357485684482
tp8468
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8469
(F-2.269691058567592
F-2.409583178433505
tp8470
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8471
(F-2.377008745747228
F-2.4053930802778765
tp8472
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8473
(F-2.663962809244792
F-2.3264291936700996
tp8474
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8475
(F-2.395356808566717
F-2.3701548142866655
tp8476
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8477
(F-2.369183143872893
F-2.34558781710538
tp8478
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8479
(F-1.9702090095071232
F-2.366627259687944
tp8480
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8481
(F-2.1721338671307233
F-2.3550642186945137
tp8482
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8483
(F-2.3505403995513916
F-2.3575430783358486
tp8484
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8485
(F-2.464831923118512
F-2.377838828346946
tp8486
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8487
(F-2.4613197813642786
F-2.4078204415061255
tp8488
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8489
(F-2.2532990124760843
F-2.365728898481889
tp8490
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8491
(F-2.5008469921047403
F-2.3705685355446557
tp8492
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8493
(F-2.2950620745668315
F-2.3464537533846768
tp8494
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8495
(F-2.299652535574777
F-2.2724021564830434
tp8496
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8497
(F-2.7407671431420555
F-2.3467960357666016
tp8498
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8499
(F-2.256003684185921
F-2.3524809750643643
tp8500
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8501
(F-2.7101487190492692
F-2.3003609397194604
tp8502
sS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8503
(F-3.2404071438697075
F-2.397656874223189
tp8504
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p8505
(F-2.9386197258444393
F-2.3098832910711113
tp8506
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8507
(F-1.9421360467069892
F-2.3781681060791016
tp8508
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8509
(F-2.447191936213796
F-2.398551247336648
tp8510
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8511
(F-2.6657649714772296
F-2.3530235290527344
tp8512
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8513
(F-2.4518754141671315
F-2.2498129064386543
tp8514
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8515
(F-2.1119389389500474
F-2.3693004954944956
tp8516
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8517
(F-2.2863133865567398
F-2.4021353288130327
tp8518
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8519
(F-2.425065599046312
F-2.3834169561212715
tp8520
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8521
(F-2.340171120383523
F-2.4005714763294566
tp8522
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8523
(F-2.309592304924722
F-2.405258525501598
tp8524
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8525
(F-2.4430947629561337
F-2.402713082053445
tp8526
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8527
(F-2.2714686467097356
F-2.3944617184725674
tp8528
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8529
(F-2.293356454500588
F-2.3643871654163706
tp8530
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8531
(F-2.1124712492290296
F-2.3550711545077236
tp8532
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8533
(F-2.4198859885886863
F-2.3410275199196557
tp8534
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8535
(F-2.451705593532986
F-2.231917988170277
tp8536
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8537
(F-2.6093455950419107
F-2.3599069768732246
tp8538
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8539
(F-2.7663104203495665
F-2.36749267578125
tp8540
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8541
(F-2.8598767961774554
F-2.35641791603782
tp8542
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p8543
(F-2.9554200349030673
F-2.3538773276589136
tp8544
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8545
(F-2.184483007057426
F-2.3348230882124468
tp8546
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8547
(F-2.3258233400854733
F-2.393972223455256
tp8548
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8549
(F-2.2345321655273436
F-2.3792651783336294
tp8550
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p8551
(F-1.6437944482873987
F-2.2877032540061255
tp8552
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8553
(F-2.401749572753906
F-2.4024009704589844
tp8554
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p8555
(F-2.875970204671224
F-2.2420916123823686
tp8556
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8557
(F-2.551845406197213
F-2.3814090381969106
tp8558
sS'read_f = f.read\nbuf = read_f(buf_size)'
p8559
(F-2.662571144104004
F-2.2785894220525567
tp8560
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8561
(F-2.555299355950154
F-2.413355740633878
tp8562
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8563
(F-2.42397639065853
F-2.3767786892977627
tp8564
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8565
(F-2.4634449717762705
F-2.4000554518266157
tp8566
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8567
(F-2.4249772533928
F-2.41023774580522
tp8568
sS'import mmap\nimport random\nfrom collections import defaultdict'
p8569
(F-3.2902132670084634
F-2.4256805073131216
tp8570
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8571
(F-2.2315401147913048
F-2.277347044511275
tp8572
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8573
(F-2.2646141939384994
F-2.382529518821023
tp8574
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8575
(F-2.376804252292799
F-2.3579160516912285
tp8576
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8577
(F-2.1531044006347657
F-2.3891559947620737
tp8578
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8579
(F-2.5234522892878606
F-2.358258854259144
tp8580
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8581
(F-2.0404079143817606
F-2.4000986272638496
tp8582
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict'
p8583
(F-3.214673868815104
F-2.4024649533358486
tp8584
sS'buf_size = (1024 * 1024)\nread_f = f.read'
p8585
(F-3.4240373310289884
F-2.3017761924050073
tp8586
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random'
p8587
(F-2.6933477301346627
F-2.3443783846768467
tp8588
sS"lines += buf.count('\\n')"
p8589
(F-2.427305221557617
F-2.2697200775146484
tp8590
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8591
(F-2.3372013568878174
F-2.3464976224032315
tp8592
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict'
p8593
(F-2.538445472717285
F-2.366880243474787
tp8594
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8595
(F-2.3476490118564706
F-2.367071498524059
tp8596
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8597
(F-2.5704695852179276
F-2.3602209958163174
tp8598
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8599
(F-2.166998845880682
F-2.4151913035999644
tp8600
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8601
(F-2.430811228485882
F-2.398847753351385
tp8602
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8603
(F-2.591987133026123
F-2.419222745028409
tp8604
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8605
(F-2.261959779609754
F-2.3834155689586294
tp8606
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8607
(F-2.4579342928799717
F-2.392833016135476
tp8608
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8609
(F-2.0714403788248696
F-2.365081787109375
tp8610
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    start_time = time.time()'
p8611
(F-1.673108418782552
F-2.3630315607244317
tp8612
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8613
(F-2.347827309056332
F-2.426937796852805
tp8614
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8615
(F-2.336742121998857
F-2.378533796830611
tp8616
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8617
(F-2.7556615369073274
F-2.358489990234375
tp8618
sS'read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8619
(F-2.352180208478655
F-2.2589449449019
tp8620
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8621
(F-2.4742221174568964
F-2.373599659312855
tp8622
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8623
(F-2.451234417197145
F-2.4110015522349966
tp8624
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8625
(F-2.9292002360026044
F-2.375964945012873
tp8626
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8627
(F-2.633398691813151
F-2.2752980318936435
tp8628
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8629
(F-2.6664962127429095
F-2.3657698197798296
tp8630
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8631
(F-2.542404571136871
F-2.354013963179155
tp8632
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8633
(F-2.0677640320824797
F-2.365307027643377
tp8634
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p8635
(F-2.92947749087685
F-2.237317345359109
tp8636
sS'readline = buf.readline\nwhile readline():\n    lines += 1'
p8637
(F-3.078354684930099
F-2.256395860151811
tp8638
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8639
(F-2.3382811727403086
F-2.392308321866122
tp8640
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8641
(F-2.335146011844758
F-2.3746121146462182
tp8642
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8643
(F-2.865538184322528
F-2.3583322004838423
tp8644
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8645
(F-2.702991400824653
F-2.3654857982288706
tp8646
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8647
(F-2.410688344868387
F-2.372812097722834
tp8648
sS"num_lines = sum((1 for line in open('myfile.txt')))"
p8649
(F-2.754246761924342
F-2.3098914406516333
tp8650
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8651
(F-2.485917646806319
F-2.3780826221812856
tp8652
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8653
(F-2.2481443106410013
F-2.3890646154230293
tp8654
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8655
(F-2.4764272589432568
F-2.3772511915727095
tp8656
sS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8657
(F-2.5114013270327917
F-2.232365521517667
tp8658
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p8659
(F-3.2206375122070314
F-2.3148786371404473
tp8660
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8661
(F-2.3239991900863908
F-2.404849312522195
tp8662
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8663
(F-2.5577474659886854
F-2.408652739091353
tp8664
sS'for (key, vals) in counts.items():\n    pass'
p8665
(F-1.9477209793893915
F-2.540731256658381
tp8666
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p8667
(F-2.548279639004039
F-2.4156910289417612
tp8668
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8669
(F-2.47234369093372
F-2.4215030670166016
tp8670
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8671
(F-2.3481604942908656
F-2.286454114046964
tp8672
sS'with open(fname) as f:\n    pass'
p8673
(F-1.2011868613106864
F-2.273619911887429
tp8674
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8675
(F-2.360708230481474
F-2.3824887709184126
tp8676
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8677
(F-2.2787298843207044
F-2.410643144087358
tp8678
sS'readline = buf.readline\nwhile readline():\n    pass'
p8679
(F-3.0323953067555145
F-2.2680409171364526
tp8680
sS'for i in range(5):\n    pass'
p8681
(F-1.2456996100289481
F-2.28939472545277
tp8682
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8683
(F-2.2779410226004466
F-2.335338592529297
tp8684
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8685
(F-2.7607560334382235
F-2.2993637431751597
tp8686
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8687
(F-2.4048191846999445
F-2.3724816062233667
tp8688
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8689
(F-2.2818185906661186
F-2.3695460232821377
tp8690
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8691
(F-2.624744669596354
F-2.2856740084561435
tp8692
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8693
(F-2.0401204427083335
F-2.252089587124911
tp8694
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8695
(F-2.308549834460747
F-2.4153215234929863
tp8696
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8697
(F-2.4702761270166413
F-2.3425778475674717
tp8698
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8699
(F-2.333589113675631
F-2.4011695168235083
tp8700
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p8701
(F-2.446795654296875
F-2.4101018038663
tp8702
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8703
(F-2.7417403157552083
F-2.3712773756547407
tp8704
sS'counts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass'
p8705
(F-2.6993642953725963
F-2.4833091389049184
tp8706
sS'lines = 0\nbuf_size = (1024 * 1024)'
p8707
(F-3.5893226623535157
F-2.23667387528853
tp8708
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8709
(F-2.8603494578394395
F-2.374015114524148
tp8710
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8711
(F-2.1370486936707427
F-2.361712022261186
tp8712
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8713
(F-2.7905617916222774
F-2.360206950794567
tp8714
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8715
(F-2.256371333681304
F-2.4158299186012964
tp8716
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p8717
(F-1.9502334594726562
F-2.2868418260054155
tp8718
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8719
(F-2.7694498697916665
F-2.24992544000799
tp8720
sS"while buf:\n    lines += buf.count('\\n')"
p8721
(F-1.8248229026794434
F-2.2472046938809482
tp8722
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8723
(F-2.5031861525315504
F-2.3698251897638496
tp8724
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8725
(F-2.4785708656793908
F-2.301724520596591
tp8726
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8727
(F-2.4078860977320997
F-2.415233091874556
tp8728
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8729
(F-2.2747846828214118
F-2.4041661349209873
tp8730
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8731
(F-2.616942655123197
F-2.3721635991876777
tp8732
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p8733
(F-3.133212619357639
F-2.313159942626953
tp8734
sS'lines = 0\nreadline = buf.readline'
p8735
(F-4.093373385342685
F-2.2594200481068003
tp8736
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8737
(F-2.421490407129477
F-2.4009165330366655
tp8738
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8739
(F-2.3785665289399587
F-2.3684669841419566
tp8740
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p8741
(F-2.031572229721967
F-2.3719059337269175
tp8742
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p8743
(F-1.7264899359809027
F-2.36417649009011
tp8744
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8745
(F-2.385405800559304
F-2.3497467041015625
tp8746
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p8747
(F-2.6541290283203125
F-2.2669509540904653
tp8748
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8749
(F-2.7275593392800963
F-2.351946570656516
tp8750
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8751
(F-2.366707282980489
F-2.369139237837358
tp8752
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8753
(F-2.4411717245023543
F-2.3539967970414595
tp8754
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p8755
(F-3.148285605690696
F-2.276513012972745
tp8756
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8757
(F-2.8222298971036586
F-2.351076126098633
tp8758
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8759
(F-2.433238983154297
F-2.292037096890536
tp8760
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8761
(F-2.5270552458586515
F-2.3399621790105645
tp8762
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8763
(F-2.350335429898269
F-2.389373605901545
tp8764
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8765
(F-1.7956738965264682
F-2.365700114857067
tp8766
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8767
(F-2.323460614239728
F-2.3641785708340732
tp8768
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8769
(F-2.3983427403336863
F-2.3904734524813565
tp8770
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8771
(F-2.286211787043391
F-2.3633126345547764
tp8772
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8773
(F-2.253107768733327
F-2.281063600019975
tp8774
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8775
(F-2.3110882098858174
F-2.402113827792081
tp8776
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8777
(F-2.1679119472085993
F-2.4175791306929155
tp8778
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8779
(F-2.419770050048828
F-2.2995250008322974
tp8780
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8781
(F-2.9042069455410573
F-2.369767275723544
tp8782
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8783
(F-2.6068085461128048
F-2.337159590287642
tp8784
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8785
(F-2.2915511172041936
F-2.4091642553156074
tp8786
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8787
(F-2.2981345698518574
F-2.3224537589333276
tp8788
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8789
(F-2.8523101806640625
F-2.3497357801957564
tp8790
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8791
(F-2.3679457286860317
F-2.3829409859397193
tp8792
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p8793
(F-2.0480090202169214
F-2.363151203502308
tp8794
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8795
(F-2.325305866745283
F-2.2827526439319956
tp8796
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8797
(F-2.3600280196578414
F-2.3822813901034268
tp8798
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8799
(F-2.926729202270508
F-2.3586557561700996
tp8800
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p8801
(F-1.5809500909620715
F-2.3412987102161753
tp8802
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8803
(F-2.8471830095563617
F-2.338923540982333
tp8804
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8805
(F-2.124682802142519
F-2.388039155439897
tp8806
sS'from collections import defaultdict'
p8807
(F-3.6025190353393555
F-2.448770349675959
tp8808
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8809
(F-2.29224323776533
F-2.3988597176291724
tp8810
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8811
(F-2.2340264438597623
F-2.361005089499734
tp8812
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8813
(F-2.508461139298893
F-2.3632930408824575
tp8814
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8815
(F-2.1977129484477795
F-2.2718887329101562
tp8816
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8817
(F-2.3581573184173887
F-2.3595797798850318
tp8818
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8819
(F-2.3647450764973956
F-2.408008575439453
tp8820
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8821
(F-2.4728633767307393
F-2.3743275729092685
tp8822
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8823
(F-2.495121728806269
F-2.361205361106179
tp8824
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8825
(F-2.317057974386535
F-2.3626632690429688
tp8826
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8827
(F-2.3340950303405297
F-2.360471552068537
tp8828
sS'for line in open(filename):\n    lines += 1\nreturn lines'
p8829
(F-2.385298076428865
F-2.3941503004594282
tp8830
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8831
(F-2.378318604968843
F-2.2862234982577236
tp8832
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p8833
(F-1.975129058395607
F-2.3759692798961294
tp8834
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8835
(F-2.050072934447216
F-2.3573563315651636
tp8836
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8837
(F-2.8544921875
F-2.352140946821733
tp8838
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8839
(F-2.538936593191964
F-2.358883250843395
tp8840
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8841
(F-2.711494173322405
F-2.3611583709716797
tp8842
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8843
(F-2.5358744154881387
F-2.4077377319335938
tp8844
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8845
(F-2.031728204691185
F-2.3133569197221235
tp8846
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8847
(F-2.7285365912750477
F-2.3469356190074575
tp8848
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8849
(F-2.9900437187902704
F-2.3686223463578657
tp8850
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8851
(F-2.541230583190918
F-2.3670343919233843
tp8852
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    pass'
p8853
(F-1.5955674020867598
F-2.3794735995205967
tp8854
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p8855
(F-3.0361902410333808
F-2.2908769087357954
tp8856
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8857
(F-2.530920772229211
F-2.4267600666392934
tp8858
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8859
(F-2.3780804802389706
F-2.408951152454723
tp8860
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p8861
(F-2.098199497569691
F-2.402220986106179
tp8862
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8863
(F-2.441152245107323
F-2.377332340587269
tp8864
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8865
(F-2.3550006705270685
F-2.397290836681019
tp8866
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8867
(F-2.417057582310268
F-2.4049354900013316
tp8868
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8869
(F-2.2000158136541192
F-2.4076791243119673
tp8870
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8871
(F-2.361583332439045
F-2.3612837357954546
tp8872
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8873
(F-2.741276590447677
F-2.3576396595348013
tp8874
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p8875
(F-2.5511961592004653
F-2.365772940895774
tp8876
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8877
(F-2.487760087134133
F-2.2613100572065874
tp8878
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8879
(F-2.3720681039910567
F-2.3906633203679863
tp8880
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8881
(F-2.2934566188502954
F-2.3822593688964844
tp8882
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8883
(F-2.38766991058526
F-2.406152205033736
tp8884
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8885
(F-2.299758396791608
F-2.3581038388338955
tp8886
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8887
(F-1.7173152250402115
F-2.3371526544744317
tp8888
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8889
(F-2.552673641997989
F-2.3480907786976206
tp8890
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8891
(F-2.936081210049716
F-2.3466163982044566
tp8892
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8893
(F-2.5625388853011595
F-2.2933273315429688
tp8894
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8895
(F-2.7286184210526314
F-2.3705380179665307
tp8896
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8897
(F-2.30369910415338
F-2.376055110584606
tp8898
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8899
(F-2.2533010382401315
F-2.399155703457919
tp8900
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8901
(F-2.5516247448620497
F-2.348586689342152
tp8902
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8903
(F-2.3350231694240198
F-2.3775284507057886
tp8904
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8905
(F-1.7391273498535156
F-2.399388399991122
tp8906
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8907
(F-2.1899385724748885
F-2.3478728207674893
tp8908
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8909
(F-2.174467963141364
F-2.3449185111305932
tp8910
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8911
(F-2.1201468413730837
F-2.359681562943892
tp8912
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8913
(F-2.5006467072860055
F-2.3499752391468394
tp8914
sS'while readline():\n    lines += 1\nreturn lines'
p8915
(F-2.770221471786499
F-2.2350581776012075
tp8916
sS'def simplecount(filename):\n    lines = 0'
p8917
(F-2.3430137634277344
F-2.277608698064631
tp8918
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8919
(F-2.307875842582889
F-2.3628387451171875
tp8920
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8921
(F-2.75293083190918
F-2.401270779696378
tp8922
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8923
(F-2.4865948424047355
F-2.3017715107310903
tp8924
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8925
(F-2.8671530264395253
F-2.3638879602605645
tp8926
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0'
p8927
(F-2.587641398111979
F-2.3271331787109375
tp8928
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p8929
(F-1.3096835327148437
F-2.365370837124911
tp8930
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8931
(F-2.4181784533579416
F-2.3756542205810547
tp8932
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8933
(F-2.398083917025862
F-2.282189802689986
tp8934
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8935
(F-2.4879343133223686
F-2.311317790638317
tp8936
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8937
(F-2.3382543033584025
F-2.4040638316761362
tp8938
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8939
(F-2.3004207388436284
F-2.402260520241477
tp8940
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8941
(F-2.270464597827327
F-2.398908268321644
tp8942
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8943
(F-2.120174020960711
F-2.3557538119229404
tp8944
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8945
(F-2.2601369526571857
F-2.389771894975142
tp8946
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8947
(F-2.8183550918311404
F-2.376657312566584
tp8948
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8949
(F-2.4172760585568986
F-2.409558729691939
tp8950
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8951
(F-2.979728480747768
F-2.306443301114169
tp8952
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8953
(F-2.299433708190918
F-2.360883019187234
tp8954
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8955
(F-2.9477191227738575
F-2.3720033819025215
tp8956
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8957
(F-2.4331294759114583
F-2.356272957541726
tp8958
sS'for line in open(filename):\n    lines += 1'
p8959
(F-2.0861213207244873
F-2.390655517578125
tp8960
sS'return lines'
p8961
(F-4.847680568695068
F-2.2680931091308594
tp8962
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8963
(F-2.4838011056784817
F-2.3615653298117896
tp8964
sS'counts[func].append((time.time() - start_time))'
p8965
(F-3.025062742687407
F-2.3483645699240943
tp8966
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8967
(F-2.417522765042489
F-2.4094857302579014
tp8968
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p8969
(F-2.01054133201132
F-2.376162789084695
tp8970
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8971
(F-2.568482666015625
F-2.2921485900878906
tp8972
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8973
(F-2.438961226851852
F-2.38151030106978
tp8974
sS'import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p8975
(F-1.7180569966634114
F-2.369850678877397
tp8976
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p8977
(F-3.2461936587379094
F-2.263002048839222
tp8978
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8979
(F-2.321279525756836
F-2.382269252430309
tp8980
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8981
(F-2.495949516083275
F-2.369558160955256
tp8982
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8983
(F-2.334047455148599
F-2.399497639049183
tp8984
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8985
(F-2.3221797658436336
F-2.349930156360973
tp8986
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8987
(F-2.583756865647735
F-2.3783004067160864
tp8988
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8989
(F-2.819190673828125
F-2.376982255415483
tp8990
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8991
(F-2.439802145656151
F-2.3912792205810547
tp8992
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8993
(F-2.1871050666360294
F-2.3085973913019355
tp8994
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8995
(F-2.362696355311715
F-2.409120733087713
tp8996
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8997
(F-2.2500910631475604
F-2.369557814164595
tp8998
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8999
(F-2.5372356372875173
F-2.3749481547962534
tp9000
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9001
(F-2.3276365413222204
F-2.372319308194247
tp9002
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9003
(F-2.175233218544408
F-2.387357711791992
tp9004
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9005
(F-1.6996410793728298
F-2.416737989945845
tp9006
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9007
(F-2.655920794629675
F-2.3546551791104404
tp9008
sS'return (i + 1)'
p9009
(F-2.981106996536255
F-2.269514257257635
tp9010
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9011
(F-2.3712013938210226
F-2.3705373243852095
tp9012
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9013
(F-2.5105325536790235
F-2.407271471890536
tp9014
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9015
(F-2.3425357318914735
F-2.3986540707674893
tp9016
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9017
(F-1.2890547702186985
F-2.37946232882413
tp9018
sS'return (i + 1)\ncounts = defaultdict(list)'
p9019
(F-3.3118492126464845
F-2.3983067599209873
tp9020
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9021
(F-2.352206953055494
F-2.3991402712735264
tp9022
sS'while readline():\n    pass'
p9023
(F-2.3578168695623223
F-2.3887544111772017
tp9024
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9025
(F-2.2988349914550783
F-2.420596036044034
tp9026
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9027
(F-2.956146599264706
F-2.3685836791992188
tp9028
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9029
(F-2.245987978848544
F-2.330585999922319
tp9030
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9031
(F-2.3168054697464924
F-2.370048696344549
tp9032
sS'def opcount(fname):\n    pass'
p9033
(F-1.355941613515218
F-2.3418629386208276
tp9034
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9035
(F-2.3561694917224703
F-2.3642716841264204
tp9036
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9037
(F-2.227192018090225
F-2.366996071555398
tp9038
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9039
(F-3.0281766694167565
F-2.3503671125932173
tp9040
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9041
(F-2.1872172528002634
F-2.3867998990145596
tp9042
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9043
(F-1.621873367664426
F-2.3339502161199395
tp9044
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9045
(F-2.929366478553185
F-2.3553754633123223
tp9046
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p9047
(F-2.3391015351708258
F-2.368673151189631
tp9048
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9049
(F-2.193209795884683
F-2.3710236982865767
tp9050
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9051
(F-2.5245257209329046
F-2.369570645419034
tp9052
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0'
p9053
(F-2.9568992614746095
F-2.2890701293945312
tp9054
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9055
(F-2.410784472216357
F-2.3426135670055044
tp9056
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9057
(F-2.703978523375496
F-2.2902115908536045
tp9058
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9059
(F-2.8559369437302213
F-2.3478658849542793
tp9060
sS'import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9061
(F-1.9137204488118489
F-2.327310735529119
tp9062
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9063
(F-2.4011371836942783
F-2.4199378273703833
tp9064
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9065
(F-2.474978825233502
F-2.3961809331720527
tp9066
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9067
(F-2.028391177837665
F-2.3643041090531782
tp9068
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9069
(F-2.97484811922399
F-2.2554699290882456
tp9070
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9071
(F-2.382728350044477
F-2.3549381602894175
tp9072
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9073
(F-2.657466343470982
F-2.2628021240234375
tp9074
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9075
(F-2.427356551178789
F-2.3631168712269175
tp9076
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9077
(F-2.795057932535807
F-2.3336417458274146
tp9078
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9079
(F-2.458748059395032
F-2.365623647516424
tp9080
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9081
(F-2.004582066689768
F-2.3700294494628906
tp9082
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9083
(F-2.433840892353996
F-2.2927010276100854
tp9084
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9085
(F-2.4430023903070492
F-2.365842645818537
tp9086
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9087
(F-2.327985050702336
F-2.3530750274658203
tp9088
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9089
(F-2.2478540738423667
F-2.3703094829212534
tp9090
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9091
(F-2.408640601418235
F-2.37451830777255
tp9092
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9093
(F-2.480115900812922
F-2.403430938720703
tp9094
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9095
(F-1.8489678700764973
F-2.3140640258789062
tp9096
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9097
(F-2.7363150460379466
F-2.349852128462358
tp9098
sS'start_time = time.time()'
p9099
(F-1.8201514157381924
F-2.286359440196644
tp9100
sS'return lines\n\ndef opcount(fname):\n    pass'
p9101
(F-2.341754198074341
F-2.2693824768066406
tp9102
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9103
(F-2.3696110620847177
F-2.392409931529652
tp9104
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9105
(F-2.427414255043895
F-2.402420910921964
tp9106
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9107
(F-1.784510923235604
F-2.3814738880504263
tp9108
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9109
(F-2.5073917643229167
F-2.3956656022505327
tp9110
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9111
(F-2.480867385864258
F-2.355920444835316
tp9112
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9113
(F-2.470632952844311
F-2.378894805908203
tp9114
sS'while buf:\n    pass'
p9115
(F-1.4413202073838975
F-2.4093364368785513
tp9116
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9117
(F-2.9268098596024186
F-2.346766385165128
tp9118
sS'from __future__ import with_statement\nimport time\nimport mmap'
p9119
(F-2.752592086791992
F-2.3307259299538354
tp9120
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9121
(F-2.41283933577999
F-2.353756471113725
tp9122
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9123
(F-2.3413821411132814
F-2.411985223943537
tp9124
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9125
(F-2.2720885757328
F-2.3629878651012075
tp9126
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9127
(F-2.2509883757560485
F-2.340940995649858
tp9128
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9129
(F-2.143652779715402
F-2.359122536399148
tp9130
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9131
(F-2.405287412839515
F-2.3697341572154653
tp9132
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9133
(F-2.3849334056243237
F-2.3998439095237036
tp9134
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9135
(F-2.802695599724265
F-2.3505814292214136
tp9136
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9137
(F-2.421007628834576
F-2.419251702048562
tp9138
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9139
(F-2.2347360338483537
F-2.3939287012273613
tp9140
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9141
(F-2.8233522268442006
F-2.3669416254216973
tp9142
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9143
(F-2.3579984392438615
F-2.401359731500799
tp9144
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9145
(F-2.4210841513087606
F-2.3627525676380503
tp9146
sS'import time'
p9147
(F-5.638287544250488
F-2.3103979284113105
tp9148
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9149
(F-2.4248999151259816
F-2.391677509654652
tp9150
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9151
(F-2.163371437474301
F-2.3317415064031426
tp9152
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9153
(F-2.346767153058733
F-2.3980248191139917
tp9154
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9155
(F-2.4602722508947275
F-2.4038821133700283
tp9156
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9157
(F-2.5801691376002487
F-2.347335468639027
tp9158
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9159
(F-2.3992678877236187
F-2.356341101906516
tp9160
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9161
(F-2.477183583018544
F-2.40719257701527
tp9162
sS"assert (func('big_file.txt') == 1209138)"
p9163
(F-3.4871326793323862
F-2.452117746526545
tp9164
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9165
(F-2.5457286834716797
F-2.3833037289706143
tp9166
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9167
(F-2.050067901611328
F-2.306196386163885
tp9168
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9169
(F-2.539396382994571
F-2.262637051669034
tp9170
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9171
(F-2.6356201171875
F-2.3692073822021484
tp9172
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9173
(F-2.40865321933287
F-2.407563643022017
tp9174
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9175
(F-2.349857384050396
F-2.3507556915283203
tp9176
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9177
(F-2.248512182342872
F-2.386209487915039
tp9178
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9179
(F-3.2663274911733775
F-2.2852556055242363
tp9180
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9181
(F-2.3539901069972826
F-2.4060081135142934
tp9182
sS'import random\nfrom collections import defaultdict'
p9183
(F-3.2284172905815973
F-2.44678393277255
tp9184
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9185
(F-2.752524760232043
F-2.3638525876131924
tp9186
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9187
(F-2.077768865621315
F-2.362600326538086
tp9188
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9189
(F-2.351328700041968
F-2.367067510431463
tp9190
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9191
(F-2.4259098332102704
F-2.3867579373446377
tp9192
sS'return lines\n\ndef simplecount(filename):\n    pass'
p9193
(F-2.5566279888153076
F-2.293912887573242
tp9194
sS'import mmap'
p9195
(F-5.991691589355469
F-2.3411195928400215
tp9196
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9197
(F-2.762663897346048
F-2.3349266052246094
tp9198
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9199
(F-2.6809446603659817
F-2.3632125854492188
tp9200
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9201
(F-2.382042605377907
F-2.379304365678267
tp9202
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9203
(F-2.264513132523517
F-2.4109235243363814
tp9204
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9205
(F-2.578022377163756
F-2.378921161998402
tp9206
sS'for (i, l) in enumerate(f):\n    pass'
p9207
(F-1.8913226657443576
F-2.4534081545743076
tp9208
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9209
(F-2.2126014177189317
F-2.362778056751598
tp9210
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9211
(F-2.295418701171875
F-2.394239078868519
tp9212
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9213
(F-2.3768073662177667
F-2.3778384815562856
tp9214
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9215
(F-2.3083300203890413
F-2.3580610101873223
tp9216
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9217
(F-2.3779772882876187
F-2.2854440862482246
tp9218
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9219
(F-2.140497886528403
F-2.363829872824929
tp9220
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9221
(F-2.689172274824502
F-2.352132970636541
tp9222
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9223
(F-2.462725340014827
F-2.3787460327148438
tp9224
sS'from collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9225
(F-1.6898839738633897
F-2.326894239945845
tp9226
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9227
(F-2.2745339998634915
F-2.46225998618386
tp9228
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9229
(F-2.409607907559009
F-2.4174482172185723
tp9230
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9231
(F-2.342788601513975
F-2.3989557786421343
tp9232
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9233
(F-2.313493408203125
F-2.4031281904740767
tp9234
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9235
(F-2.510590484176857
F-2.3012577403675425
tp9236
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9237
(F-2.3745130934156813
F-2.375801433216442
tp9238
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9239
(F-2.450804562912774
F-2.339724974198775
tp9240
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9241
(F-1.8261904509171196
F-2.369577928022905
tp9242
sS'import mmap\nimport random'
p9243
(F-4.348821095057896
F-2.342245275324041
tp9244
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9245
(F-2.232065130163122
F-2.326040441339666
tp9246
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9247
(F-2.3284827844420475
F-2.3667084087025034
tp9248
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9249
(F-2.710025694312119
F-2.3625160564075816
tp9250
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9251
(F-2.342288607642764
F-2.354669050736861
tp9252
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9253
(F-2.0247969450774015
F-2.33561186356978
tp9254
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9255
(F-2.273663751010237
F-2.34704607183283
tp9256
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9257
(F-2.2622481191624475
F-2.3739214810458096
tp9258
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9259
(F-2.1746087646484376
F-2.3568992614746094
tp9260
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9261
(F-2.1546100616455077
F-2.363305698741566
tp9262
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9263
(F-2.2919414744657627
F-2.3721363761208276
tp9264
sS'import time\nimport mmap'
p9265
(F-4.447558539254325
F-2.3314566178755327
tp9266
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9267
(F-2.7852757771809897
F-2.3672877225008877
tp9268
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9269
(F-2.25756961783183
F-2.390766837380149
tp9270
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9271
(F-2.338764856216755
F-2.380048231645064
tp9272
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9273
(F-2.1202389699108197
F-2.362245559692383
tp9274
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9275
(F-2.865594482421875
F-2.355960152365945
tp9276
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9277
(F-2.5104428593983905
F-2.365480596368963
tp9278
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9279
(F-2.3344287872314453
F-2.366950815374201
tp9280
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9281
(F-2.722370236418968
F-2.3463613336736504
tp9282
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9283
(F-2.3850108782450357
F-2.3649669994007456
tp9284
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9285
(F-2.13531494140625
F-2.352535941384055
tp9286
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9287
(F-2.7904803936298075
F-2.3051671114834873
tp9288
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9289
(F-2.608743139060147
F-2.3169770674272017
tp9290
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9291
(F-2.294659670158352
F-2.409697792746804
tp9292
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9293
(F-2.5037006849653265
F-2.3780912919477983
tp9294
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9295
(F-2.4089578265792753
F-2.3726823980158027
tp9296
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9297
(F-2.2900197809392755
F-2.412575461647727
tp9298
sS'with open(fname) as f:\n    for (i, l) in enumerate(f):\n        pass'
p9299
(F-1.4226339932145744
F-2.3928616263649682
tp9300
sS'def opcount(fname):\n    with open(fname) as f:\n        pass'
p9301
(F-1.0220872630243716
F-2.272504286332564
tp9302
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9303
(F-1.659206753685361
F-2.3906449404629795
tp9304
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9305
(F-3.6583178976307744
F-2.2669029235839844
tp9306
sS'buf_size = (1024 * 1024)'
p9307
(F-3.1080523404208096
F-2.29869929226962
tp9308
sS'counts = defaultdict(list)'
p9309
(F-2.7405660152435303
F-2.5103194496848364
tp9310
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9311
(F-2.441425354500127
F-2.358083204789595
tp9312
sS'from __future__ import with_statement\nimport time'
p9313
(F-2.6469673743614783
F-2.3240124095569956
tp9314
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9315
(F-3.0018389412526334
F-2.365498282692649
tp9316
sS'while readline():\n    lines += 1'
p9317
(F-2.5456537099984975
F-2.244458632035689
tp9318
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9319
(F-2.1695569356282554
F-2.3113379044966265
tp9320
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9321
(F-2.3525584827769888
F-2.3861385692249644
tp9322
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p9323
(F-2.4845158960912133
F-2.4143090681596235
tp9324
sS'counts = defaultdict(list)\nfor i in range(5):\n    pass'
p9325
(F-1.600940159388951
F-2.4389780217950996
tp9326
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9327
(F-2.3828169389204548
F-2.3976083235307173
tp9328
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9329
(F-2.6815625619197236
F-2.3620432073419746
tp9330
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9331
(F-2.3873045831663995
F-2.4103071039373223
tp9332
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9333
(F-2.315531724801093
F-2.374215906316584
tp9334
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9335
(F-2.90408641887161
F-2.2843007174405185
tp9336
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9337
(F-2.2865093455595127
F-2.3837540366432886
tp9338
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9339
(F-2.4901231553819443
F-2.332067142833363
tp9340
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9341
(F-3.0060907408248547
F-2.3098427165638316
tp9342
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9343
(F-2.5986918997257313
F-2.3409501856023613
tp9344
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9345
(F-3.0544674521998356
F-2.31179497458718
tp9346
sS'def bufcount(filename):\n    pass'
p9347
(F-1.6901009877522786
F-2.2973738583651455
tp9348
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9349
(F-2.5140615609975963
F-2.4029048572887075
tp9350
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9351
(F-2.3812922987827037
F-2.302358453924006
tp9352
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9353
(F-1.7002575818230123
F-2.327770406549627
tp9354
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9355
(F-3.0303822685690487
F-2.2582114826549184
tp9356
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9357
(F-2.3981977520566997
F-2.3738186576149682
tp9358
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9359
(F-2.6723512461487675
F-2.3751005692915483
tp9360
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9361
(F-2.2807004716661243
F-2.401929161765359
tp9362
sS'f = open(filename)'
p9363
(F-2.392700433731079
F-2.35536020452326
tp9364
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9365
(F-2.4699046341414306
F-2.419475382024592
tp9366
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9367
(F-2.713463181715745
F-2.36707895452326
tp9368
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9369
(F-2.2644948457416736
F-2.395747098055753
tp9370
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9371
(F-2.5014590077191237
F-2.370229721069336
tp9372
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9373
(F-2.3550579494900172
F-2.3743983182040127
tp9374
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9375
(F-2.4091071611569252
F-2.3494654568758877
tp9376
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9377
(F-2.213808991188227
F-2.4116887179288
tp9378
sS'for line in open(filename):\n    pass'
p9379
(F-1.6366633006504603
F-2.397793856534091
tp9380
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9381
(F-3.012503662109375
F-2.334821180863814
tp9382
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9383
(F-2.397125666042627
F-2.361266396262429
tp9384
sS'def bufcount(filename):\n    f = open(filename)'
p9385
(F-1.5164052177877987
F-2.334247589111328
tp9386
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9387
(F-2.2893688242922545
F-2.378550962968306
tp9388
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9389
(F-2.2910045149139546
F-2.4086102572354404
tp9390
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9391
(F-2.350719955119681
F-2.3768863677978516
tp9392
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9393
(F-2.2685873243543835
F-2.351194381713867
tp9394
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9395
(F-2.3159660961692787
F-2.4062232971191406
tp9396
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p9397
(F-1.9931730123666616
F-2.381439208984375
tp9398
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9399
(F-1.6696477322965055
F-2.4476566314697266
tp9400
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9401
(F-1.7621017456054688
F-2.3732752366499468
tp9402
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9403
(F-2.5232948480650434
F-2.3279788277365943
tp9404
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9405
(F-2.617455618722098
F-2.347946513782848
tp9406
sS'import time\nimport mmap\nimport random'
p9407
(F-3.8369110107421873
F-2.3456256172873755
tp9408
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9409
(F-2.285806642356494
F-2.408183878118342
tp9410
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9411
(F-2.1036092758178713
F-2.360208684747869
tp9412
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9413
(F-2.471536154275412
F-2.365220156582919
tp9414
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9415
(F-1.9048643292121168
F-2.371763055974787
tp9416
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p9417
(F-2.5318016459923665
F-2.4007129669189453
tp9418
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9419
(F-2.390478721650844
F-2.4079048850319604
tp9420
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9421
(F-2.2664914289523757
F-2.40077712319114
tp9422
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9423
(F-2.4313575226126365
F-2.3755604137073862
tp9424
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9425
(F-2.3877055800963785
F-2.378959829157049
tp9426
sS'import random'
p9427
(F-5.6007513999938965
F-2.334931113503196
tp9428
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9429
(F-2.2641066992842913
F-2.3715584494850854
tp9430
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9431
(F-2.3613133834580244
F-2.349809473211115
tp9432
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9433
(F-2.904785664876302
F-2.269584308971058
tp9434
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9435
(F-2.1344841003417967
F-2.4018898010253906
tp9436
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9437
(F-2.31795281630296
F-2.3313640247691763
tp9438
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9439
(F-2.981064035922666
F-2.3722931254993784
tp9440
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9441
(F-2.637600044582201
F-2.3560253490101206
tp9442
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9443
(F-2.013744212962963
F-2.3192325938831675
tp9444
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9445
(F-2.2606973955708165
F-2.3496743982488457
tp9446
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9447
(F-2.1009437297952585
F-2.358012979680842
tp9448
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9449
(F-2.2493484898617395
F-2.3476728959517046
tp9450
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9451
(F-2.6190083821614585
F-2.3602277582341973
tp9452
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9453
(F-2.3703884921231113
F-2.296451048417525
tp9454
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9455
(F-2.0961540222167967
F-2.3786754608154297
tp9456
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9457
(F-2.044779068384415
F-2.369287144054066
tp9458
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9459
(F-2.3773689875527033
F-2.378681182861328
tp9460
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9461
(F-2.3797840881347656
F-2.448942184448242
tp9462
sS'buf = read_f(buf_size)'
p9463
(F-2.295029958089193
F-2.2771556160666724
tp9464
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9465
(F-2.4839053683810763
F-2.3679589358243076
tp9466
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9467
(F-2.44114013671875
F-2.3803423101251777
tp9468
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9469
(F-2.735393290617028
F-2.3458425348455254
tp9470
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9471
(F-2.3640261442764947
F-2.4133560874245386
tp9472
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9473
(F-2.549818864957554
F-2.3499556454745205
tp9474
sS'buf = read_f(buf_size)\nwhile buf:\n    pass'
p9475
(F-2.038421630859375
F-2.2582420002330434
tp9476
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9477
(F-2.278876283115014
F-2.402252197265625
tp9478
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9479
(F-2.41689611364294
F-2.3668637709184126
tp9480
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9481
(F-2.0681785236705434
F-2.424805381081321
tp9482
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9483
(F-2.055845243436796
F-2.3597667000510474
tp9484
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9485
(F-2.3064997938812755
F-2.3949812108820137
tp9486
ssI6416131
(dp9487
S'copy = self.copy()'
p9488
(F-3.4033605787489147
F-3.2908005714416504
tp9489
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()'
p9490
(F-1.576535701751709
F-3.166975498199463
tp9491
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9492
(F-4.097134459252451
F-3.140644073486328
tp9493
sS'class Dict(dict):\n\n    def __add__(self, other):\n        pass'
p9494
(F-1.2813500624436598
F-3.1793746948242188
tp9495
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9496
(F-3.5862877017161887
F-3.0588080883026123
tp9497
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9498
(F-3.1108786541482676
F-3.1088991165161133
tp9499
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9500
(F-3.711786058213976
F-3.2619166374206543
tp9501
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9502
(F-3.2624459402901786
F-3.0862836837768555
tp9503
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9504
(F-3.777617698492006
F-3.1057825088500977
tp9505
sS'copy.update(self)'
p9506
(F-3.2925896644592285
F-3.2130417823791504
tp9507
sS"(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9508
(F-4.591438802083333
F-3.137082815170288
tp9509
sS'def __add__(self, other):\n    copy = self.copy()'
p9510
(F-2.0359479730779473
F-3.349499225616455
tp9511
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9512
(F-3.6618902861182367
F-3.1578969955444336
tp9513
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9514
(F-3.1191258430480957
F-3.2876698970794678
tp9515
sS'copy = other.copy()'
p9516
(F-3.6339102851019964
F-3.220090389251709
tp9517
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9518
(F-3.515347233525029
F-3.1856040954589844
tp9519
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9520
(F-3.9584205264136907
F-3.1573190689086914
tp9521
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9522
(F-3.8444576687282987
F-3.0300984382629395
tp9523
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9524
(F-3.919486305930398
F-3.243149518966675
tp9525
sS'return copy\n\ndef __radd__(self, other):\n    pass'
p9526
(F-2.7550485610961912
F-3.38242769241333
tp9527
sS"({'test1': 1, } + Dict(test2=2))"
p9528
(F-3.7552113252527572
F-3.168811321258545
tp9529
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9530
(F-3.3763319283477533
F-3.0699403285980225
tp9531
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9532
(F-3.114141610952524
F-3.3020219802856445
tp9533
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9534
(F-3.3647689819335938
F-3.2651824951171875
tp9535
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p9536
(F-2.4635322833883353
F-3.1621201038360596
tp9537
sS'class Dict(dict):\n    pass'
p9538
(F-1.341947873433431
F-3.1382648944854736
tp9539
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9540
(F-3.6041734912727454
F-3.1508054733276367
tp9541
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy'
p9542
(F-2.680719466436477
F-3.123772621154785
tp9543
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9544
(F-2.9796874587600297
F-3.141005516052246
tp9545
sS'copy.update(other)'
p9546
(F-3.1959495544433594
F-2.9475178718566895
tp9547
sS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9548
(F-3.429624557495117
F-3.250187873840332
tp9549
sS"default_data = Dict({'item1': 1, 'item2': 2, })"
p9550
(F-2.8164508217259456
F-3.305838108062744
tp9551
sS'copy.update(self)\nreturn copy'
p9552
(F-4.62228046764027
F-3.2085118293762207
tp9553
sS'def __radd__(self, other):\n    copy = other.copy()'
p9554
(F-2.231699510054155
F-3.348639965057373
tp9555
sS'def __radd__(self, other):\n    pass'
p9556
(F-1.5972572565078735
F-3.45723032951355
tp9557
sS"default_data['item3'] = 3"
p9558
(F-3.387042236328125
F-3.273994207382202
tp9559
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9560
(F-2.8721115757042255
F-3.1399192810058594
tp9561
sS'return copy'
p9562
(F-7.39096736907959
F-3.3445091247558594
tp9563
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9564
(F-3.727063409213362
F-3.1514668464660645
tp9565
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9566
(F-3.7139364706503377
F-3.0426557064056396
tp9567
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9568
(F-3.384122576032366
F-3.180429697036743
tp9569
sS'copy.update(other)\nreturn copy'
p9570
(F-5.051374955610796
F-2.9687271118164062
tp9571
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)'
p9572
(F-2.267582428761018
F-3.1236531734466553
tp9573
sS'def __add__(self, other):\n    pass'
p9574
(F-1.6863620281219482
F-3.4301297664642334
tp9575
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9576
(F-4.118035678205819
F-3.107978343963623
tp9577
sS"(default_data + {'item3': 3, })"
p9578
(F-4.215396881103516
F-3.2392711639404297
tp9579
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9580
(F-2.680558204650879
F-3.1439461708068848
tp9581
sS"default_data.update({'item3': 3, })"
p9582
(F-3.324071502685547
F-3.2081665992736816
tp9583
sS"default_data.update({'item4': 4, 'item5': 5, })"
p9584
(F-3.008054632889597
F-3.2003426551818848
tp9585
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9586
(F-3.8009845779602784
F-3.131539821624756
tp9587
sS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9588
(F-3.7768478393554688
F-3.1886847019195557
tp9589
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9590
(F-2.714557779246363
F-3.292855739593506
tp9591
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9592
(F-3.3428610599402226
F-3.10673189163208
tp9593
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9594
(F-3.4971267700195314
F-3.1001267433166504
tp9595
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9596
(F-3.9424708775111608
F-3.193756103515625
tp9597
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9598
(F-3.1451812744140626
F-3.205986261367798
tp9599
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p9600
(F-3.1432588365342884
F-3.1398515701293945
tp9601
ssI3964681
(dp9602
S"import glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p9603
(F-1.2431463514055525
F-3.0898798429048977
tp9604
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    pass"
p9605
(F-1.7971891784667968
F-3.112597245436448
tp9606
sS"glob.glob('./*.txt')"
p9607
(F-1.1005427837371826
F-3.157970428466797
tp9608
sS'import glob, os'
p9609
(F-3.9112059275309243
F-3.32923830472506
tp9610
sS"for file in os.listdir('/mydir'):\n    pass"
p9611
(F-1.1777329444885254
F-3.092127873347356
tp9612
sS"for file in glob.glob('*.txt'):\n    pass"
p9613
(F-1.1226251125335693
F-3.0543248103215146
tp9614
sS"import glob\nglob.glob('./*.txt')"
p9615
(F-1.1906743483109907
F-3.1606914813701925
tp9616
sS"os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p9617
(F-1.3257656926694124
F-3.0463831974909854
tp9618
sS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p9619
(F-1.3877436940262957
F-3.060791015625
tp9620
sS'print os.path.join(root, file)'
p9621
(F-1.5655912252572866
F-3.437159905066857
tp9622
sS"for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p9623
(F-0.90833494398329
F-3.0462711040790262
tp9624
sS"import os\nfor file in os.listdir('/mydir'):\n    pass"
p9625
(F-1.0278845335307873
F-3.1279156024639425
tp9626
sS"for (root, dirs, files) in os.walk('/mydir'):\n    pass"
p9627
(F-1.947566812688654
F-3.1095281747671275
tp9628
sS"for file in files:\n    if file.endswith('.txt'):\n        pass"
p9629
(F-1.0338628942316228
F-3.0226663442758412
tp9630
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p9631
(F-1.3317978598854758
F-3.0763473510742188
tp9632
sS'import os'
p9633
(F-3.808030605316162
F-3.558904794546274
tp9634
sS"if file.endswith('.txt'):\n    pass"
p9635
(F-1.3181749071393694
F-3.2476624708909254
tp9636
sS'print file'
p9637
(F-4.353447437286377
F-3.260432316706731
tp9638
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p9639
(F-1.6080730322635535
F-3.087935521052434
tp9640
sS"import os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p9641
(F-0.8388110478719075
F-3.0683053823617787
tp9642
sS'import glob'
p9643
(F-4.91317081451416
F-3.3569253774789662
tp9644
sS"os.chdir('/mydir')"
p9645
(F-1.0171610116958618
F-3.3970216604379506
tp9646
sS'for file in files:\n    pass'
p9647
(F-1.520857204090465
F-3.064865992619441
tp9648
sS"import glob, os\nos.chdir('/mydir')"
p9649
(F-1.3647158696101263
F-3.3353975736177883
tp9650
sS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p9651
(F-1.6948075612386069
F-3.0687426053560696
tp9652
ssI849674
(dp9653
S"import thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9654
(F-2.0879758947035847
F-3.15892333984375
tp9655
sS'print errtxt'
p9656
(F-3.5578322410583496
F-3.273020935058594
tp9657
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    pass'
p9658
(F-1.470763433547247
F-3.232166544596354
tp9659
sS'import thread, time'
p9660
(F-4.604407946268718
F-3.2701098124186196
tp9661
sS'while 1:\n    pass'
p9662
(F-2.166713926527235
F-3.154387919108073
tp9663
sS'pass'
p9664
(F-3.090700149536133
F-3.305550130208333
tp9665
sS'import thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p9666
(F-1.9359132766723632
F-3.166229248046875
tp9667
sS"import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9668
(F-2.1010265350341797
F-3.1611175537109375
tp9669
sS'import thread'
p9670
(F-4.911186218261719
F-3.256769561767578
tp9671
sS'import thread\n\ndef myfunction(mystring, *args):\n    pass'
p9672
(F-1.7659518593236019
F-3.172093709309896
tp9673
sS"Thread(target=myfunction, args=('MyStringHere', 1)).start()"
p9674
(F-1.6057563781738282
F-3.2379074096679688
tp9675
sS'def myfunction(mystring, *args):\n    pass'
p9676
(F-1.7355992635091146
F-3.2286705017089843
tp9677
sS'def myfunction(mystring, *args):\n    print mystring'
p9678
(F-1.9149048328399658
F-3.224822998046875
tp9679
sS"from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9680
(F-1.8265503777398004
F-3.210895029703776
tp9681
sS't.start()\nt.join()'
p9682
(F-1.9109300466684194
F-3.4123779296875
tp9683
sS't.start()'
p9684
(F-1.5985208238874162
F-3.3771593729654947
tp9685
sS'time.sleep(5)'
p9686
(F-1.0484390258789062
F-3.2559410095214845
tp9687
sS'print mystring'
p9688
(F-3.5578322410583496
F-3.273020935058594
tp9689
sS't.join()'
p9690
(F-1.945315224783761
F-3.4404566446940104
tp9691
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p9692
(F-1.5824949091131038
F-3.228199005126953
tp9693
sS'from threading import Thread'
p9694
(F-2.966001510620117
F-3.313462575276693
tp9695
sS"def myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9696
(F-2.062371317545573
F-3.214837900797526
tp9697
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring'
p9698
(F-1.9777611819180576
F-3.1729812622070312
tp9699
sS"if (__name__ == '__main__'):\n    pass"
p9700
(F-2.058381779988607
F-3.308086649576823
tp9701
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    pass'
p9702
(F-1.8239119393484933
F-3.179987080891927
tp9703
sS"thread.start_new_thread(myfunction, ('MyStringHere', 1))"
p9704
(F-2.697790781656901
F-3.405487823486328
tp9705
sS"t = Thread(None, myfunction, None, ('MyStringHere', 1))"
p9706
(F-2.338926527235243
F-3.4527936299641926
tp9707
ssI8270092
(dp9708
S"pattern = re.compile('\\\\s+')"
p9709
(F-1.075404167175293
F-2.0180765787760415
tp9710
sS'import re'
p9711
(F-4.70591402053833
F-2.0950109693739147
tp9712
sS"import re\npattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p9713
(F-1.2270223910991962
F-1.9916297064887152
tp9714
sS"pattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p9715
(F-1.2413677547288977
F-2.001943164401584
tp9716
sS"import re\npattern = re.compile('\\\\s+')"
p9717
(F-1.3259394719050481
F-2.0020887586805554
tp9718
sS"sentence = sentence.replace(' ', '')"
p9719
(F-1.5525188446044922
F-2.5030926598442926
tp9720
sS"sentence = re.sub('\\\\s+', '', sentence, flags=re.UNICODE)"
p9721
(F-1.3079008102416991
F-2.0608037312825522
tp9722
sS"'helloapple'"
p9723
(F-3.3039461771647134
F-2.632897694905599
tp9724
sS'sentence = sentence.strip()'
p9725
(F-2.4437709384494357
F-2.8170859018961587
tp9726
sS"sentence = re.sub(pattern, '', sentence)"
p9727
(F-1.8237560817173548
F-2.0312686496310763
tp9728
sS"'hello  apple'"
p9729
(F-3.3039461771647134
F-2.632897694905599
tp9730
sS"'hello apple'"
p9731
(F-3.3039461771647134
F-2.632897694905599
tp9732
sS"sentence = ''.join(sentence.split())"
p9733
(F-1.7119534356253487
F-2.126914554172092
tp9734
ssI7961363
(dp9735
S"list(OrderedDict.fromkeys('abracadabra'))"
p9736
(F-2.6506970723470054
F-3.753825823465983
tp9737
sS's = [1, 2, 3]\nlist((set(t) - set(s)))'
p9738
(F-2.729755695049579
F-2.6710611979166665
tp9739
sS"list(dict.fromkeys('abracadabra'))"
p9740
(F-1.975055000998757
F-3.2315394083658853
tp9741
sS't\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p9742
(F-3.206723107231988
F-2.6712522506713867
tp9743
sS'list(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p9744
(F-2.8318023681640625
F-2.6659274101257324
tp9745
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt'
p9746
(F-2.393612976074219
F-3.016923268636068
tp9747
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]'
p9748
(F-2.370173786961755
F-2.831941286722819
tp9749
sS'from collections import OrderedDict'
p9750
(F-2.621685573032924
F-2.6732915242513022
tp9751
sS'list((set(t) - set(s)))'
p9752
(F-3.136749505996704
F-2.812514305114746
tp9753
sS't\nlist(set(t))'
p9754
(F-3.645852869207209
F-2.950662612915039
tp9755
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))'
p9756
(F-2.1314068418560606
F-2.856811841328939
tp9757
sS'list(set(t))'
p9758
(F-2.157466252644857
F-2.910954157511393
tp9759
sS't'
p9760
(F-9.248240152994791
F-3.8357566197713218
tp9761
sS'list(set(t))\ns = [1, 2, 3]'
p9762
(F-2.842011702688117
F-2.7982304890950522
tp9763
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p9764
(F-2.471765978582974
F-2.7200196584065757
tp9765
sS's = [1, 2, 3]'
p9766
(F-2.5788596760142934
F-2.9469706217447915
tp9767
sS't\nlist(set(t))\ns = [1, 2, 3]'
p9768
(F-3.5052257719494047
F-2.8262767791748047
tp9769
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]'
p9770
(F-1.8952515643575918
F-3.0331592559814453
tp9771
sS"from collections import OrderedDict\nlist(OrderedDict.fromkeys('abracadabra'))"
p9772
(F-1.89141845703125
F-2.6980342864990234
tp9773
ssI931092
(dp9774
S"'foo'[reverse_slice]"
p9775
(F-5.101025104522705
F-2.2775769914899553
tp9776
sS'def reverse_a_string_slowly(a_string):\n    pass'
p9777
(F-2.4910053253173827
F-2.3174686431884766
tp9778
sS'def reversed_string(a_string):\n    return a_string[::(-1)]'
p9779
(F-2.7139864321108216
F-2.1078172411237444
tp9780
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)'
p9781
(F-2.6951501634385853
F-2.1412710462297713
tp9782
sS"return ''.join(reversed(string))"
p9783
(F-1.6683823267618816
F-2.1140101296561107
tp9784
sS'string[slice_obj]'
p9785
(F-5.065033435821533
F-2.070031302315848
tp9786
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9787
(F-4.890159221610638
F-2.246159144810268
tp9788
sS'step = (-1)'
p9789
(F-4.224566459655762
F-2.6316375732421875
tp9790
sS"new_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9791
(F-2.6489898681640627
F-2.118685449872698
tp9792
sS"'foo'[::(-1)]"
p9793
(F-4.311105554754084
F-2.1982246126447404
tp9794
sS"index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9795
(F-2.7375458804043857
F-2.107799393790109
tp9796
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1"
p9797
(F-2.531803752100745
F-2.1257738385881697
tp9798
sS'return a_string[::(-1)]'
p9799
(F-4.049368722098214
F-2.150589261736189
tp9800
sS'index = len(a_string)'
p9801
(F-3.3773651123046875
F-2.1256209782191684
tp9802
sS'def reverse_a_string_more_slowly(a_string):\n    pass'
p9803
(F-2.7305348136208276
F-2.384488786969866
tp9804
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''"
p9805
(F-2.428509076436361
F-2.246468952723912
tp9806
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p9807
(F-3.0634577009412975
F-2.1149817875453403
tp9808
sS'start = stop = None\nstep = (-1)'
p9809
(F-4.599032810756138
F-2.2715865543910434
tp9810
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))"
p9811
(F-4.891020888582282
F-2.1632578713553294
tp9812
sS"return ''.join(new_strings)"
p9813
(F-1.9855837388472124
F-2.085953984941755
tp9814
sS'return new_string'
p9815
(F-2.9899689356486
F-2.2949115208217075
tp9816
sS'slice_obj = slice(start, stop, step)'
p9817
(F-4.547395978655134
F-2.0952232905796597
tp9818
sS'new_strings = []'
p9819
(F-3.191467761993408
F-2.1713619232177734
tp9820
sS'while index:\n    index -= 1\nnew_string += a_string[index]'
p9821
(F-3.1432207280939277
F-2.1593810490199496
tp9822
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))"
p9823
(F-4.913183914987664
F-2.1369007655552457
tp9824
sS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9825
(F-4.733616666973762
F-2.24097102028983
tp9826
sS"reverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p9827
(F-4.607325599307106
F-2.126504489353725
tp9828
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    pass"
p9829
(F-2.516125748797161
F-2.1369871412004744
tp9830
sS"new_string = ''"
p9831
(F-2.5474905286516463
F-2.319136755807059
tp9832
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    pass'
p9833
(F-2.665572079745206
F-2.1336618150983537
tp9834
sS'def reversed_string(a_string):\n    pass'
p9835
(F-1.9672218561172485
F-2.1309215000697543
tp9836
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p9837
(F-2.882300657384536
F-2.1204354422433034
tp9838
sS"reversed_string('foo')"
p9839
(F-2.4120631217956543
F-2.3878440856933594
tp9840
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []'
p9841
(F-2.6138040048104747
F-2.2266575949532643
tp9842
sS'min(timeit.repeat((lambda : reversed_string(a_string))))'
p9843
(F-3.805397727272727
F-2.2521359579903737
tp9844
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]'
p9845
(F-3.0538157801474295
F-2.1260038103376115
tp9846
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))"
p9847
(F-5.402823978000217
F-2.1174474443708147
tp9848
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))'
p9849
(F-4.985612909844581
F-2.2497555868966237
tp9850
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p9851
(F-2.723120371500651
F-2.1148789269583568
tp9852
sS"'hello world'[::(-1)]"
p9853
(F-4.311105554754084
F-2.1982246126447404
tp9854
sS'string[start:stop:step]'
p9855
(F-4.146653747558593
F-2.1007837568010603
tp9856
sS'slice_obj = slice(start, stop, step)\nstring[slice_obj]'
p9857
(F-4.818729945591518
F-2.071698325020926
tp9858
sS"step = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p9859
(F-4.700345175606864
F-2.1791607992989674
tp9860
sS'index -= 1'
p9861
(F-3.0945640563964845
F-2.3965797424316406
tp9862
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p9863
(F-4.892196231418186
F-2.2459144592285156
tp9864
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1'
p9865
(F-2.644824318263842
F-2.1284008026123047
tp9866
sS'new_string += a_string[index]\nreturn new_string'
p9867
(F-3.0735469144933365
F-2.137204851422991
tp9868
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]"
p9869
(F-2.6343745478877314
F-2.11263302394322
tp9870
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)"
p9871
(F-2.5003176602450283
F-2.1556153978620256
tp9872
sS'new_string += a_string[index]'
p9873
(F-3.0789785385131836
F-2.14802428654262
tp9874
sS'index = len(a_string)\nwhile index:\n    pass'
p9875
(F-3.1329966651068792
F-2.12927736554827
tp9876
sS'start = stop = None'
p9877
(F-4.005156925746372
F-2.178553444998605
tp9878
sS"start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p9879
(F-4.5514014748966
F-2.1839772633143832
tp9880
sS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p9881
(F-4.299253747818318
F-2.2494204384940013
tp9882
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))'
p9883
(F-5.767625661996695
F-2.2657293592180525
tp9884
sS"def reverse_string_readable_answer(string):\n    return ''.join(reversed(string))"
p9885
(F-2.93862462926794
F-2.1306652341570174
tp9886
sS"while index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9887
(F-2.719769723074777
F-2.114525386265346
tp9888
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))"
p9889
(F-4.875376259408346
F-2.1509500231061662
tp9890
sS'start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)'
p9891
(F-4.191767657244647
F-2.1855275290352956
tp9892
sS"a_string = ('amanaplanacanalpanama' * 10)"
p9893
(F-4.1270058371803975
F-2.163332530430385
tp9894
sS'reverse_slice = slice(start, stop, step)'
p9895
(F-4.145598820277622
F-2.106286185128348
tp9896
sS'while index:\n    index -= 1'
p9897
(F-2.44972055608576
F-2.310390199933733
tp9898
sS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p9899
(F-4.517208979679988
F-2.2548142841884067
tp9900
sS'while index:\n    pass'
p9901
(F-2.3921324412027993
F-2.4391844613211497
tp9902
sS'min(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9903
(F-4.727020263671875
F-2.253981726510184
tp9904
sS'string[subscript]'
p9905
(F-2.635329564412435
F-2.204972675868443
tp9906
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string"
p9907
(F-2.5913758358712924
F-2.1092921665736606
tp9908
sS'step = (-1)\nreverse_slice = slice(start, stop, step)'
p9909
(F-4.277187892368862
F-2.1727121898106168
tp9910
sS'index = len(a_string)\nwhile index:\n    index -= 1'
p9911
(F-3.018386650085449
F-2.143570763724191
tp9912
sS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p9913
(F-4.5226898193359375
F-2.2468809400285994
tp9914
sS'def reverse_string_readable_answer(string):\n    pass'
p9915
(F-3.8730977376302085
F-2.290726797921317
tp9916
sS'new_strings.append(a_string[index])'
p9917
(F-2.746441141764323
F-2.116989408220564
tp9918
sS'while index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p9919
(F-3.1456897876880787
F-2.1350470951625278
tp9920
sS'while index:\n    index -= 1\nnew_strings.append(a_string[index])'
p9921
(F-2.8754592895507813
F-2.1455768857683455
tp9922
sS"def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p9923
(F-2.546999032156808
F-2.106670379638672
tp9924
ssI415511
(dp9925
S'import datetime'
p9926
(F-4.4214701652526855
F-1.8367072211371527
tp9927
sS'from time import gmtime, strftime'
p9928
(F-4.155500411987305
F-1.7823560502794054
tp9929
sS'datetime.datetime.now()'
p9930
(F-0.930723614162869
F-1.7994863722059462
tp9931
sS'str(datetime.now())'
p9932
(F-1.6020402908325195
F-1.8133133782280817
tp9933
sS'datetime.datetime.time(datetime.datetime.now())'
p9934
(F-1.422856330871582
F-1.771844016181098
tp9935
sS'from datetime import datetime'
p9936
(F-3.2948973973592124
F-1.800946553548177
tp9937
sS'datetime.datetime.now().time()'
p9938
(F-0.9797082314124475
F-1.7935184902615018
tp9939
sS'import datetime\ndatetime.datetime.now()'
p9940
(F-1.027575174967448
F-1.7947093115912542
tp9941
sS"from time import gmtime, strftime\nstrftime('%Y-%m-%d %H:%M:%S', gmtime())"
p9942
(F-2.387315413531135
F-1.8030416700575087
tp9943
sS"strftime('%Y-%m-%d %H:%M:%S', gmtime())"
p9944
(F-1.8135259628295899
F-1.8215592702229817
tp9945
sS'from datetime import datetime\nstr(datetime.now())'
p9946
(F-1.3000043233235676
F-1.7826694912380643
tp9947
ssI14043934
(dp9948
S'import datetime'
p9949
(F-4.5076494216918945
F-4.1686347961425785
tp9950
sS'dt = datetime.datetime.combine(datetime.date.today(), t)'
p9951
(F-1.3770413398742676
F-3.8855377197265626
tp9952
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p9953
(F-1.815765958843809
F-3.909262847900391
tp9954
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p9955
(F-1.7446661376953125
F-3.9390594482421877
tp9956
sS'(t - datetime.timedelta(hours=1, minutes=10))'
p9957
(F-2.5830762651231556
F-4.029130172729492
tp9958
sS't = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p9959
(F-2.1749771663120816
F-3.898548889160156
tp9960
sS'import datetime\nt = datetime.datetime.now()'
p9961
(F-1.1840076446533203
F-3.953896331787109
tp9962
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p9963
(F-2.3693695068359375
F-3.9141166687011717
tp9964
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)'
p9965
(F-1.481904060609879
F-3.9108211517333986
tp9966
sS'dt.time()'
p9967
(F-1.543365478515625
F-4.632913970947266
tp9968
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p9969
(F-1.778441689231179
F-3.9173866271972657
tp9970
sS'dt -= datetime.timedelta(hours=5)\ndt.time()'
p9971
(F-1.5619383917914496
F-4.025175094604492
tp9972
sS'import datetime\nt = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p9973
(F-2.018815194406817
F-3.883619689941406
tp9974
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p9975
(F-1.764142354329427
F-3.9408714294433596
tp9976
sS't = datetime.time(1, 2)'
p9977
(F-2.004528363545736
F-3.9596012115478514
tp9978
sS't = datetime.datetime.now()'
p9979
(F-1.3006104555996982
F-3.951529693603516
tp9980
sS'dt'
p9981
(F-6.732798894246419
F-4.660531997680664
tp9982
sS'dt\ndt -= datetime.timedelta(hours=5)'
p9983
(F-2.0284553255353654
F-3.9723274230957033
tp9984
sS'dt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p9985
(F-1.9181632995605469
F-4.042226409912109
tp9986
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p9987
(F-2.1249329538056343
F-3.9327537536621096
tp9988
sS'dt -= datetime.timedelta(hours=5)'
p9989
(F-1.3241421381632488
F-3.943071746826172
tp9990
ssI3940128
(dp9991
S'array = [0, 10, 20, 40]'
p9992
(F-2.993611849271334
F-1.6790455904873935
tp9993
sS'L = [0, 10, 20, 40]\nL.reverse()\nL'
p9994
(F-2.927980695452009
F-1.7577904787930576
tp9995
sS'array = [0, 10, 20, 40]\nfor i in reversed(array):\n    pass'
p9996
(F-1.9687483860896184
F-1.5820139104669744
tp9997
sS'L = [0, 10, 20, 40]\nL.reverse()'
p9998
(F-2.1100495990953947
F-1.7621877843683416
tp9999
sS'L = [0, 10, 20, 40]\nL[::(-1)]'
p10000
(F-3.1704038537066914
F-1.5219572240656072
tp10001
sS'print i'
p10002
(F-4.201584339141846
F-1.7500776811079546
tp10003
sS'L'
p10004
(F-7.14289665222168
F-1.8301571932705967
tp10005
sS'L = [0, 10, 20, 40]'
p10006
(F-2.637072049654447
F-1.5755929079922764
tp10007
sS'L[::(-1)]'
p10008
(F-3.8367156982421875
F-1.5914245952259412
tp10009
sS'L.reverse()\nL'
p10010
(F-3.7003826565212674
F-1.993259776722301
tp10011
sS'for i in reversed(array):\n    pass'
p10012
(F-1.670029640197754
F-1.6337887157093396
tp10013
sS'L.reverse()'
p10014
(F-2.0206775665283203
F-2.013554659756747
tp10015
ssI1949318
(dp10016
S'import httplib'
p10017
(F-5.461703300476074
F-3.138104248046875
tp10018
sS'200'
p10019
(F-8.189573287963867
F-3.0686248779296874
tp10020
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10021
(F-1.5102878570556642
F-3.043906593322754
tp10022
sS"conn = httplib.HTTPConnection('www.python.org')"
p10023
(F-1.5246110395951704
F-3.110695648193359
tp10024
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10025
(F-1.3411740012790845
F-2.9402015686035154
tp10026
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10027
(F-1.6258537504408095
F-2.9525360107421874
tp10028
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)'
p10029
(F-2.1454179382324217
F-2.9805673599243163
tp10030
sS'r1 = conn.getresponse()'
p10031
(F-1.3643898434109158
F-3.26558837890625
tp10032
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p10033
(F-2.7486856248643665
F-2.974666786193848
tp10034
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()"
p10035
(F-1.5094796694242036
F-3.0075239181518554
tp10036
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')"
p10037
(F-1.6969356536865234
F-3.0966888427734376
tp10038
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10039
(F-1.3464768409729004
F-2.8940868377685547
tp10040
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10041
(F-2.0127776817039207
F-2.9465972900390627
tp10042
sS"conn.request('HEAD', '/')"
p10043
(F-1.5160444259643555
F-3.0184682846069335
tp10044
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10045
(F-1.2753511244250881
F-2.9845291137695313
tp10046
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10047
(F-1.6292724609375
F-2.95934944152832
tp10048
sS'r = requests.head(url)'
p10049
(F-2.8781089782714844
F-2.9651885986328126
tp10050
sS'print r1.status, r1.reason'
p10051
(F-2.7644222259521483
F-3.0051151275634767
tp10052
sS'def url_ok(url):\n    pass'
p10053
(F-2.1933469772338867
F-2.9855918884277344
tp10054
sS'r1 = conn.getresponse()\nprint r1.status, r1.reason'
p10055
(F-2.066382726033529
F-3.088237190246582
tp10056
sS'def url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p10057
(F-2.9859752655029297
F-3.0039432525634764
tp10058
sS'import requests\n\ndef url_ok(url):\n    pass'
p10059
(F-1.9715499877929688
F-2.932727241516113
tp10060
sS'import requests'
p10061
(F-4.798171043395996
F-2.8848106384277346
tp10062
sS'def url_ok(url):\n    r = requests.head(url)'
p10063
(F-2.4268163045247397
F-3.0248613357543945
tp10064
sS'return (r.status_code == 200)'
p10065
(F-3.531618118286133
F-3.233868408203125
tp10066
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10067
(F-1.299884523664202
F-2.933163642883301
tp10068
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()\n200"
p10069
(F-2.987040710449219
F-3.010414886474609
tp10070
ssI2052390
(dp10071
S'raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10072
(F-1.57391357421875
F-4.108001015403054
tp10073
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    pass'
p10074
(F-2.5818108694893973
F-3.9631344188343394
tp10075
sS'raise AppError, error, sys.exc_info()[2]\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p10076
(F-3.5884308448204627
F-4.013390974564985
tp10077
sS'raise AppError, error, sys.exc_info()[2]'
p10078
(F-3.675525665283203
F-3.990983096036044
tp10079
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\nraise'
p10080
(F-3.628662872314453
F-3.964901317249645
tp10081
sS'do_something_in_app_that_breaks_easily()'
p10082
(F-4.808585223029642
F-4.005726554177024
tp10083
sS'if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    pass'
p10084
(F-3.8525164204259075
F-4.02190468528054
tp10085
sS'class MyAppLookupError(LookupError):\n    "raise this when there\'s a lookup error for my app"'
p10086
(F-1.6472907066345215
F-4.01928052035245
tp10087
sS'raise'
p10088
(F-9.128273010253906
F-4.069515921852806
tp10089
sS'if (foo not in _ALLOWED_ARGS):\n    pass'
p10090
(F-2.5277740955352783
F-4.0847767916592685
tp10091
sS"('message', 'foo', 'bar', 'baz')"
p10092
(F-2.095950733531605
F-4.0679779052734375
tp10093
sS'if (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10094
(F-1.9277559095813381
F-4.156558990478516
tp10095
sS'logger.error(error)'
p10096
(F-3.3832528591156006
F-3.98074028708718
tp10097
sS'"raise this when there\'s a lookup error for my app"'
p10098
(F-3.034883499145508
F-4.088233947753906
tp10099
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."'
p10100
(F-2.078384671892439
F-3.9814831126819956
tp10101
sS'def api_func(foo):\n    pass'
p10102
(F-2.0127852303641185
F-3.97008618441495
tp10103
sS'demo_bad_catch()'
p10104
(F-3.8968387179904513
F-4.018348347056996
tp10105
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10106
(F-1.9316721829501065
F-4.0532004616477275
tp10107
sS"raise Exception('I know python!')"
p10108
(F-1.919032369341169
F-3.9916881214488638
tp10109
sS'raise error.with_traceback(sys.exc_info()[2])'
p10110
(F-3.6411464691162108
F-3.9781279130415483
tp10111
sS'"foo should be either \'baz\' or \'bar\'. returns something very useful."'
p10112
(F-3.034883499145508
F-4.088233947753906
tp10113
sS'print err.args'
p10114
(F-1.963491439819336
F-3.9931508844549004
tp10115
sS"raise 'message'"
p10116
(F-6.068206787109375
F-4.02840180830522
tp10117
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    pass'
p10118
(F-2.2648649544551454
F-4.007122386585582
tp10119
sS'demo_no_catch()'
p10120
(F-3.902268303765191
F-4.046778592196378
tp10121
sS'if (0 < distance <= RADIUS):\n    pass'
p10122
(F-3.5015879313151044
F-4.12006933038885
tp10123
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)'
p10124
(F-3.215299505936472
F-3.9674367037686435
tp10125
sS"raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz')"
p10126
(F-1.5185725348336356
F-4.024923497980291
tp10127
sS"raise Exception('I know Python!')"
p10128
(F-1.919032369341169
F-3.9916881214488638
tp10129
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print err.args'
p10130
(F-2.5519800688091077
F-3.9581180919300425
tp10131
sS"raise ValueError('A very specific bad thing happened')"
p10132
(F-1.4025554656982422
F-4.002180966463956
tp10133
sS"if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    raise MyAppLookupError('resource is missing, and that is not ok.')"
p10134
(F-3.4578773096988074
F-4.02655653520064
tp10135
sS"raise MyAppLookupError('resource is missing, and that is not ok.')"
p10136
(F-2.204055404663086
F-4.028877258300781
tp10137
sS'some_code_that_may_raise_our_value_error()'
p10138
(F-3.8561578047902962
F-3.9918955022638496
tp10139
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    pass'
p10140
(F-3.094390175559304
F-3.961048819802024
tp10141
sS"raise ValueError, 'message'"
p10142
(F-2.520296369280134
F-4.011941042813388
tp10143
sS'raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p10144
(F-3.413980974469866
F-4.03147402676669
tp10145
sS'class MyAppLookupError(LookupError):\n    pass'
p10146
(F-1.5302720069885254
F-3.9662479053844106
tp10147
sS'raise AssertionError("Unexpected value of \'distance\'!", distance)'
p10148
(F-2.591848945617676
F-3.9549293518066406
tp10149
ssI2331943
(dp10150
S"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10151
(F-1.7680586496988933
F-2.0617754459381104
tp10152
sS'print json.load(u)\nu.close()'
p10153
(F-2.5183062235514324
F-2.1108458042144775
tp10154
sS'try:\n    import json\nexcept ImportError:\n    pass'
p10155
(F-1.0117022196451824
F-2.1364641189575195
tp10156
sS'import urllib2'
p10157
(F-4.99741268157959
F-2.2078025341033936
tp10158
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10159
(F-1.940075397491455
F-2.0874428749084473
tp10160
sS'import json'
p10161
(F-4.563488006591797
F-2.0231857299804688
tp10162
sS'import simplejson as json'
p10163
(F-3.9991041819254556
F-2.044907569885254
tp10164
sS'print json.load(u)'
p10165
(F-2.2039260864257812
F-2.105670690536499
tp10166
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10167
(F-1.6172603425525485
F-2.028045654296875
tp10168
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10169
(F-1.6906037330627441
F-2.052506446838379
tp10170
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p10171
(F-1.8462307453155518
F-2.0852701663970947
tp10172
sS'u.close()'
p10173
(F-2.292781284877232
F-2.593261957168579
tp10174
sS'import urllib2\nimport json'
p10175
(F-3.5047988891601562
F-2.0342607498168945
tp10176
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10177
(F-1.7617470070167824
F-2.0444633960723877
tp10178
sS"u = urllib2.urlopen('http://www.reddit.com/.json')"
p10179
(F-1.9370296478271485
F-2.1956677436828613
tp10180
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p10181
(F-1.7581523014948919
F-2.029257297515869
tp10182
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10183
(F-1.8159222073025174
F-2.07808256149292
tp10184
sS'try:\n    import json\nexcept ImportError:\n    import simplejson as json'
p10185
(F-1.5365882146926153
F-2.0567970275878906
tp10186
ssI273192
(dp10187
S'os.makedirs(path, exist_ok=True)'
p10188
(F-2.886310032435826
F-2.7421719868977865
tp10189
sS'if (not os.path.isdir(path)):\n    raise'
p10190
(F-2.07528325131065
F-2.72388916015625
tp10191
sS'if (not os.path.isdir(path)):\n    pass'
p10192
(F-1.7258846885279606
F-2.707036844889323
tp10193
sS'os.makedirs(directory)'
p10194
(F-1.5767292976379395
F-2.661699422200521
tp10195
sS'distutils.dir_util.mkpath(path)'
p10196
(F-2.9768123626708984
F-2.7281598409016925
tp10197
sS'import distutils.dir_util'
p10198
(F-3.7097887992858887
F-2.736499532063802
tp10199
sS'raise'
p10200
(F-9.235679626464844
F-2.8851669311523436
tp10201
sS'import distutils.dir_util\ndistutils.dir_util.mkpath(path)'
p10202
(F-3.110245754844264
F-2.72692387898763
tp10203
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        raise'
p10204
(F-1.2568941618266858
F-2.7148844401041665
tp10205
sS'if (exception.errno != errno.EEXIST):\n    pass'
p10206
(F-3.1472365435431984
F-2.7541483561197917
tp10207
sS'import errno'
p10208
(F-6.459096908569336
F-2.811869812011719
tp10209
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    pass'
p10210
(F-0.8485001650723544
F-2.708832041422526
tp10211
sS'if (not os.path.exists(directory)):\n    os.makedirs(directory)'
p10212
(F-1.6240530014038086
F-2.663720957438151
tp10213
sS'if (not os.path.exists(directory)):\n    pass'
p10214
(F-1.8459436517012746
F-2.6734113057454425
tp10215
sS'import errno\n\ndef make_sure_path_exists(path):\n    pass'
p10216
(F-2.8821440610018643
F-2.7791318257649738
tp10217
sS'import os'
p10218
(F-3.8951163291931152
F-2.7250467936197915
tp10219
sS'os.makedirs(path)'
p10220
(F-1.2683732509613037
F-2.710820515950521
tp10221
sS'def make_sure_path_exists(path):\n    pass'
p10222
(F-3.008544921875
F-2.8311416625976564
tp10223
sS'if (exception.errno != errno.EEXIST):\n    raise'
p10224
(F-3.620265511905446
F-2.775032806396484
tp10225
sS'import os\nimport errno\n\ndef make_sure_path_exists(path):\n    pass'
p10226
(F-2.6503802490234376
F-2.7366714477539062
tp10227
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        pass'
p10228
(F-1.202450902838456
F-2.6994471232096355
tp10229
sS'import os\nimport errno'
p10230
(F-4.257552555629185
F-2.7420244852701825
tp10231
ssI4020539
(dp10232
S'import codecs'
p10233
(F-4.555190563201904
F-3.5444713592529298
tp10234
sS"myString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10235
(F-2.9444971720377606
F-3.3406524658203125
tp10236
sS"decoded_string = myString.decode('string_escape')\nprint decoded_string"
p10237
(F-3.0036563873291016
F-3.0968475341796875
tp10238
sS"return codecs.decode(match.group(0), 'unicode-escape')"
p10239
(F-2.3763463497161865
F-3.225382614135742
tp10240
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10241
(F-2.8244107154107865
F-3.30413703918457
tp10242
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p10243
(F-2.6981968470982145
F-3.13214054107666
tp10244
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10245
(F-2.0986503042825837
F-3.136418914794922
tp10246
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10247
(F-2.0497247796309623
F-3.1137058258056642
tp10248
sS'print decoded_string'
p10249
(F-4.190907160441081
F-3.041249656677246
tp10250
sS"s = 'na\\xc3\\xafve \\\\t test'"
p10251
(F-2.5080196380615236
F-3.1191165924072264
tp10252
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10253
(F-2.147035669397425
F-3.150948715209961
tp10254
sS"def decode_match(match):\n    return codecs.decode(match.group(0), 'unicode-escape')"
p10255
(F-1.9713249206542969
F-3.2023670196533205
tp10256
sS"myString = 'na\\xc3\\xafve \\\\t test'"
p10257
(F-3.057554244995117
F-3.4821205139160156
tp10258
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10259
(F-3.073810642048464
F-3.3363487243652346
tp10260
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10261
(F-2.9102114627235816
F-3.2955284118652344
tp10262
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p10263
(F-2.8472907024881113
F-3.1351383209228514
tp10264
sS'def decode_match(match):\n    pass'
p10265
(F-2.189244270324707
F-3.211154556274414
tp10266
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10267
(F-2.627173221472538
F-3.2848339080810547
tp10268
sS"import codecs\nprint codecs.decode(s, 'unicode_escape')"
p10269
(F-2.241689682006836
F-3.1795711517333984
tp10270
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10271
(F-3.207834314416956
F-3.3382308959960936
tp10272
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10273
(F-2.019434356689453
F-3.131452178955078
tp10274
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10275
(F-2.1110843706734572
F-3.1117454528808595
tp10276
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10277
(F-1.9553599281916543
F-3.1146142959594725
tp10278
sS"print decode_escapes('Ern\\xc5\\x91 \\\\t Rubik')"
p10279
(F-2.4757783677842884
F-3.1861034393310548
tp10280
sS'return ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10281
(F-3.1233495824477253
F-3.1785655975341798
tp10282
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10283
(F-2.031697998046875
F-3.1050134658813477
tp10284
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')"
p10285
(F-1.9278359046349158
F-3.1766845703125
tp10286
sS"decoded_string = myString.decode('string_escape')"
p10287
(F-3.07976561326247
F-3.137068176269531
tp10288
sS'import re\nimport codecs'
p10289
(F-3.493024008614676
F-3.1544092178344725
tp10290
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10291
(F-2.068175910500919
F-3.114293098449707
tp10292
sS'import re'
p10293
(F-4.517144203186035
F-3.116420364379883
tp10294
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p10295
(F-2.8749287923177085
F-3.1300140380859376
tp10296
sS"print 'Ern\\xc5\\x91 \\\\t Rubik'.encode('latin-1').decode('unicode_escape')"
p10297
(F-1.4894369670322962
F-3.1714714050292967
tp10298
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)"
p10299
(F-2.196058238636364
F-3.1570255279541017
tp10300
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10301
(F-2.9444971720377606
F-3.3406524658203125
tp10302
sS'def decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10303
(F-2.0247638408954325
F-3.1858074188232424
tp10304
sS"import codecs\nmyString = 'spam\\\\neggs'"
p10305
(F-2.7667257520887585
F-3.4424571990966797
tp10306
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10307
(F-3.500144449869792
F-3.3551124572753905
tp10308
sS"s = 'na\\xc3\\xafve \\\\t test'\nprint s.encode('utf-8').decode('unicode_escape')"
p10309
(F-1.3101319207085504
F-3.0758071899414063
tp10310
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10311
(F-2.0239962953509707
F-3.1313808441162108
tp10312
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p10313
(F-2.7407400131225588
F-3.1140668869018553
tp10314
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10315
(F-1.9756506139581853
F-3.1209623336791994
tp10316
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p10317
(F-3.062030792236328
F-3.1306615829467774
tp10318
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10319
(F-1.918952389039855
F-3.116424560546875
tp10320
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10321
(F-2.15592807676734
F-3.126510238647461
tp10322
sS"myString = 'spam\\\\neggs'"
p10323
(F-3.057554244995117
F-3.4821205139160156
tp10324
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p10325
(F-2.8833722795758927
F-3.109864044189453
tp10326
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10327
(F-3.2253101893833707
F-3.350147247314453
tp10328
sS'def decode_escapes(s):\n    pass'
p10329
(F-1.8193905694144112
F-3.274647521972656
tp10330
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10331
(F-2.089047701853626
F-3.1264625549316407
tp10332
sS"print codecs.decode(s, 'unicode_escape')"
p10333
(F-2.3237486752596768
F-3.165391731262207
tp10334
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10335
(F-1.9860005378723145
F-3.123881149291992
tp10336
sS"print s.encode('utf-8').decode('unicode_escape')"
p10337
(F-1.539236341203962
F-3.1699102401733397
tp10338
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p10339
(F-3.232383117675781
F-3.342997360229492
tp10340
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10341
(F-1.9710999897548132
F-3.1113208770751952
tp10342
sS"print s.encode('latin-1').decode('unicode_escape')"
p10343
(F-1.539236341203962
F-3.1699102401733397
tp10344
ssI21129020
(dp10345
S"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    pass"
p10346
(F-1.801819642384847
F-4.595348960474918
tp10347
sS'import sys'
p10348
(F-4.726949214935303
F-4.687243411415501
tp10349
sS'use_unicode = True'
p10350
(F-3.678828375680106
F-4.656871996427837
tp10351
sS"sys.setdefaultencoding('utf8')"
p10352
(F-1.6180014610290527
F-4.551115337171052
tp10353
sS'sys.getdefaultencoding()'
p10354
(F-1.5049994332449776
F-4.5966114244963
tp10355
sS"(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10356
(F-3.936017256516677
F-4.4614514802631575
tp10357
sS"(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10358
(F-3.296496800013951
F-4.4605174817537
tp10359
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'"
p10360
(F-3.888500213623047
F-4.639671325683594
tp10361
sS'import sys\nreload(sys)'
p10362
(F-2.2128868103027344
F-4.649676272743626
tp10363
sS'type(my_u)'
p10364
(F-3.411646842956543
F-4.600370708264802
tp10365
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10366
(F-3.7801220703125
F-4.436624627364309
tp10367
sS"reload(sys)\nsys.setdefaultencoding('utf8')"
p10368
(F-2.0241575974684496
F-4.612395838687294
tp10369
sS"(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10370
(F-3.7324632917131697
F-4.42989068282278
tp10371
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'\ntype(my_u)"
p10372
(F-3.3861465454101562
F-4.643240677682977
tp10373
sS'my_unicode_string = my_file.read()'
p10374
(F-2.4213358561197915
F-4.479073775442023
tp10375
sS'import sys\nreload(sys)\nsys.getdefaultencoding()'
p10376
(F-1.793706512451172
F-4.645064102975946
tp10377
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p10378
(F-3.655926465988159
F-4.640407361482319
tp10379
sS"source = unicode(source, 'utf-8')"
p10380
(F-3.3229228973388674
F-4.458555121170847
tp10381
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10382
(F-3.744482421875
F-4.485481262207031
tp10383
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')"
p10384
(F-2.4788661003112793
F-4.450592442562706
tp10385
sS"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    my_unicode_string = my_file.read()"
p10386
(F-1.9647242228190105
F-4.578713668020148
tp10387
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)\npsycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p10388
(F-3.9200951360887095
F-4.672435559724507
tp10389
sS'reload(sys)'
p10390
(F-2.7408084869384766
F-4.641778243215461
tp10391
sS'reload(sys)\nsys.getdefaultencoding()'
p10392
(F-2.5616561571756997
F-4.642052499871505
tp10393
sS"u'Z\\xfcrich'"
p10394
(F-2.356197198232015
F-4.428967927631579
tp10395
sS"charset = ('utf8',)"
p10396
(F-4.191116809844971
F-4.625493902909128
tp10397
sS"charset = ('utf8',)\nuse_unicode = True"
p10398
(F-4.532593318394253
F-4.656151620965255
tp10399
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10400
(F-3.709515162876674
F-4.471315885844984
tp10401
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10402
(F-3.8112869262695312
F-4.422933478104441
tp10403
sS"unicode('\\xe2\\x82\\xac')"
p10404
(F-2.6611016591389975
F-4.411246048776727
tp10405
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')"
p10406
(F-3.1943497290978065
F-4.4156554372687085
tp10407
sS"import sys\nreload(sys)\nsys.setdefaultencoding('utf8')"
p10408
(F-1.3790125846862793
F-4.625303569592927
tp10409
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)'
p10410
(F-3.655926465988159
F-4.640407361482319
tp10411
ssI1854
(dp10412
S'platform.system()'
p10413
(F-1.9850815364292689
F-5.311073303222656
tp10414
sS'import os\nprint os.name\nimport platform\nplatform.system()'
p10415
(F-2.3629362318250866
F-5.1925669583407315
tp10416
sS'import platform\nplatform.system()'
p10417
(F-2.447264289855957
F-5.240719188343395
tp10418
sS'import os\nos.name\nimport platform\nplatform.system()'
p10419
(F-2.512531504911535
F-5.167903553355824
tp10420
sS'os.name'
p10421
(F-2.7520509719848634
F-5.192148382013494
tp10422
sS'os.name\nimport platform\nplatform.system()'
p10423
(F-2.836150578090123
F-5.226135947487571
tp10424
sS'os.name\nimport platform'
p10425
(F-4.422067642211914
F-5.245434154163707
tp10426
sS'os.name\nimport platform\nplatform.system()\nplatform.release()'
p10427
(F-2.8531885147094727
F-5.251337224786932
tp10428
sS'import os\nprint os.name\nimport platform'
p10429
(F-3.1992174784342446
F-5.196979869495738
tp10430
sS'import os\nos.name\nimport platform\nplatform.system()\nplatform.release()'
p10431
(F-2.5822115359099014
F-5.22309043190696
tp10432
sS'platform.system()\nplatform.release()'
p10433
(F-2.634581345778245
F-5.306096510453657
tp10434
sS'import os\nos.name\nimport platform'
p10435
(F-3.630312832919034
F-5.162669788707387
tp10436
sS'import platform\nplatform.system()\nplatform.release()'
p10437
(F-2.6306521892547607
F-5.249765569513494
tp10438
sS'import os\nos.name'
p10439
(F-2.2242825031280518
F-5.160558527166193
tp10440
sS'platform.release()'
p10441
(F-2.0964249202183316
F-5.3816462430087
tp10442
sS'import os'
p10443
(F-3.946834087371826
F-5.1788812117143115
tp10444
sS'import platform'
p10445
(F-5.993171215057373
F-5.288358514959162
tp10446
sS'print os.name\nimport platform\nplatform.system()\nplatform.release()'
p10447
(F-2.949613298688616
F-5.242292230779475
tp10448
sS'print os.name\nimport platform\nplatform.system()'
p10449
(F-2.9914840698242187
F-5.214099190451882
tp10450
sS'print os.name\nimport platform'
p10451
(F-4.627529991997613
F-5.233938737349077
tp10452
sS'print os.name'
p10453
(F-3.2018311818440757
F-5.141516251997515
tp10454
sS'import os\nprint os.name\nimport platform\nplatform.system()\nplatform.release()'
p10455
(F-2.465050379435221
F-5.24081074107777
tp10456
sS'import os\nprint os.name'
p10457
(F-2.011870914035373
F-5.139841253107244
tp10458
ssI613183
(dp10459
S'd = defaultdict(int)\nfor w in text.split():\n    pass'
p10460
(F-2.072205283425071
F-2.6390480995178223
tp10461
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10462
(F-2.0238895416259766
F-2.0449509620666504
tp10463
sS'for w in text.split():\n    d[w] += 1'
p10464
(F-2.291242980957031
F-2.820183753967285
tp10465
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10466
(F-2.073055491727941
F-2.0256853103637695
tp10467
sS'for w in sorted(d, key=d.get, reverse=True):\n    pass'
p10468
(F-2.13335386912028
F-2.119206428527832
tp10469
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10470
(F-2.042245705922445
F-2.047313690185547
tp10471
sS'd = defaultdict(int)'
p10472
(F-2.7173421382904053
F-2.5054469108581543
tp10473
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10474
(F-2.058058645211014
F-2.0227596759796143
tp10475
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10476
(F-1.6186599731445312
F-1.9743893146514893
tp10477
sS'd = defaultdict(int)\nfor w in text.split():\n    d[w] += 1'
p10478
(F-2.1059407834653503
F-2.5521652698516846
tp10479
sS'import operator'
p10480
(F-5.840287208557129
F-2.686829090118408
tp10481
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10482
(F-1.6485244087550952
F-1.9825334548950195
tp10483
sS'for w in text.split():\n    pass'
p10484
(F-2.2681917826334637
F-3.0802576541900635
tp10485
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p10486
(F-2.439904048525054
F-2.5547125339508057
tp10487
sS'print w, d[w]'
p10488
(F-3.77687496609158
F-2.5525410175323486
tp10489
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p10490
(F-2.3769619281475363
F-2.584657669067383
tp10491
sS'd[w] += 1'
p10492
(F-2.9507484436035156
F-2.6685731410980225
tp10493
ssI3501382
(dp10494
S'x = Spam(0)'
p10495
(F-2.383021354675293
F-4.630204981023615
tp10496
sS'(type(x) == int)'
p10497
(F-3.7564228057861326
F-4.497928272594105
tp10498
sS'try:\n    x += 1\nexcept TypeError:\n    pass'
p10499
(F-1.201226886950041
F-4.50957558371804
tp10500
sS'for index in range(y):\n    pass'
p10501
(F-1.9345575060163225
F-4.652937802401456
tp10502
sS'pass'
p10503
(F-3.8043247858683267
F-4.751377452503551
tp10504
sS'import numbers\nisinstance(3, numbers.Integral)'
p10505
(F-3.748013129601112
F-4.491743607954546
tp10506
sS'float(5).is_integer()\nfloat(5.1).is_integer()'
p10507
(F-3.6118867293648096
F-4.9064414284446025
tp10508
sS'(type(x) == int)\nisinstance(x, int)'
p10509
(F-3.256359997917624
F-4.48593486439098
tp10510
sS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p10511
(F-2.8091809953962055
F-4.372176083651456
tp10512
sS'def is_int(val):\n    pass'
p10513
(F-1.5409465517316545
F-4.587979056618431
tp10514
sS'return True'
p10515
(F-3.2869834899902344
F-4.65241796320135
tp10516
sS'class Spam(int):\n    pass'
p10517
(F-1.5211448669433594
F-4.46619276566939
tp10518
sS'if (type(val) == int):\n    return True'
p10519
(F-2.487475002513212
F-4.540132695978338
tp10520
sS'x = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p10521
(F-3.2876307169596353
F-4.450594121759588
tp10522
sS'if (type(val) == int):\n    pass'
p10523
(F-2.4197068214416504
F-4.547677473588423
tp10524
sS'return False'
p10525
(F-3.2869834899902344
F-4.65241796320135
tp10526
sS'float(5).is_integer()\nfloat(5.1).is_integer()\nfloat(5.0).is_integer()'
p10527
(F-3.7077461691463696
F-4.936549793590199
tp10528
sS'def is_int(val):\n    if (type(val) == int):\n        return True'
p10529
(F-1.898658343723842
F-4.470511002974077
tp10530
sS'x += 1'
p10531
(F-2.6633249282836915
F-4.559790177778765
tp10532
sS'float(5.1).is_integer()\nfloat(5.0).is_integer()'
p10533
(F-3.3141449638034985
F-4.986779299649325
tp10534
sS'class Spam(int):\n    pass\nx = Spam(0)'
p10535
(F-2.2541811089766655
F-4.437938690185547
tp10536
sS'import numbers'
p10537
(F-6.945807456970215
F-4.588657725941051
tp10538
sS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)'
p10539
(F-3.0029983520507812
F-4.385620810768821
tp10540
sS'float(5).is_integer()'
p10541
(F-3.2821531295776367
F-4.817575974897905
tp10542
sS'def is_int(val):\n    if (type(val) == int):\n        pass'
p10543
(F-1.980613284640842
F-4.46369032426314
tp10544
sS'float(5.1).is_integer()'
p10545
(F-2.6753390630086265
F-4.940455350008878
tp10546
sS'isinstance(3, numbers.Integral)'
p10547
(F-3.1647880554199217
F-4.612647316672585
tp10548
sS'float(5.0).is_integer()'
p10549
(F-2.6753390630086265
F-4.940455350008878
tp10550
sS'x = Spam(0)\n(type(x) == int)'
p10551
(F-3.958027110380285
F-4.494413896040483
tp10552
sS'isinstance(x, int)'
p10553
(F-2.261258602142334
F-4.545258955522017
tp10554
ssI89228
(dp10555
S'print line,'
p10556
(F-4.278972625732422
F-2.36281418800354
tp10557
sS'import subprocess'
p10558
(F-4.5872802734375
F-1.7975516319274902
tp10559
sS"return_code = subprocess.call('echo Hello World', shell=True)"
p10560
(F-2.32403302192688
F-1.7995434999465942
tp10561
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p10562
(F-1.1727469704367899
F-1.800447702407837
tp10563
sS'from subprocess import call'
p10564
(F-3.619900703430176
F-1.7491891384124756
tp10565
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p10566
(F-0.9651726616753472
F-1.7972493171691895
tp10567
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p10568
(F-0.9532510666620164
F-1.81273353099823
tp10569
sS"print os.popen('echo Hello World').read()"
p10570
(F-1.7764044541579027
F-2.1872987747192383
tp10571
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p10572
(F-0.6765846839317908
F-1.8064231872558594
tp10573
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p10574
(F-0.7485962571768925
F-1.787708044052124
tp10575
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p10576
(F-1.1838816862839918
F-1.8153307437896729
tp10577
sS'for line in p.stdout.readlines():\n    pass'
p10578
(F-1.5090352226706112
F-1.937436580657959
tp10579
sS"print subprocess.Popen(('echo %s ' % user_input), stdout=PIPE).stdout.read()"
p10580
(F-2.1877256774902345
F-1.8206989765167236
tp10581
sS"os.system('some_command < input_file | another_command > output_file')"
p10582
(F-0.6471248269081116
F-1.9016728401184082
tp10583
sS"from subprocess import call\ncall(['ls', '-l'])"
p10584
(F-1.2205382029215495
F-1.7944064140319824
tp10585
sS'for line in p.stdout.readlines():\n    print line,\nretval = p.wait()'
p10586
(F-1.734231878209997
F-1.9073020219802856
tp10587
sS'retval = p.wait()'
p10588
(F-1.8441098531087239
F-1.9210052490234375
tp10589
sS"print subprocess.Popen('echo Hello World', shell=True, stdout=subprocess.PIPE).stdout.read()"
p10590
(F-1.4394108581542968
F-1.8174104690551758
tp10591
sS"call(['ls', '-l'])"
p10592
(F-1.26270751953125
F-1.9939336776733398
tp10593
ssI493386
(dp10594
S'print i,'
p10595
(F-4.827406692504883
F-3.0722805658976235
tp10596
sS"import sys\nsys.stdout.write('.')"
p10597
(F-0.8756791628324069
F-3.201388676961263
tp10598
sS"print ('Item %d: %s' % (i, strings[i]))"
p10599
(F-2.1888933817545575
F-3.0622288386027017
tp10600
sS'import sys'
p10601
(F-4.822268486022949
F-3.1613521575927734
tp10602
sS'sys.stdout.flush()'
p10603
(F-0.9093782636854384
F-3.1617425282796225
tp10604
sS"strings = ['one', 'two', 'three']\nfor i in xrange(3):\n    pass"
p10605
(F-1.3144288063049316
F-3.2416661580403647
tp10606
sS'from __future__ import print_function'
p10607
(F-1.4209684371948241
F-3.2259276707967124
tp10608
sS'for i in xrange(3):\n    pass'
p10609
(F-1.4127561024257116
F-3.266876538594564
tp10610
sS'for i in range(10):\n    pass'
p10611
(F-1.1492595672607422
F-3.216737747192383
tp10612
sS"strings = ['one', 'two', 'three']"
p10613
(F-1.894353519786488
F-3.253046989440918
tp10614
sS'print'
p10615
(F-6.681688944498698
F-3.0492919286092124
tp10616
sS"sys.stdout.write('.')"
p10617
(F-0.8995624542236328
F-3.179653803507487
tp10618
sS'for i in range(10):\n    print i,\nelse:\n    pass'
p10619
(F-1.3967064567234204
F-3.203704833984375
tp10620
sS'for i in range(10):\n    print i,\nelse:\n    print'
p10621
(F-1.6002207217009172
F-3.203951835632324
tp10622
sS"print ('.' * 10)"
p10623
(F-2.7647287845611572
F-2.9766670862833657
tp10624
ssI311627
(dp10625
S"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10626
(F-1.4907602474389487
F-2.617690159724309
tp10627
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p10628
(F-1.9222543650660022
F-2.634511214036208
tp10629
sS'import datetime\nmylist = []\ntoday = datetime.date.today()'
p10630
(F-1.7771465903834294
F-2.686000237098107
tp10631
sS"print ('This is a new day : ' + mylist[0])"
p10632
(F-2.0534806685014204
F-2.77323238666241
tp10633
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10634
(F-1.498451855717873
F-2.6246880751389723
tp10635
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10636
(F-1.5102871234600361
F-2.6255082350510817
tp10637
sS'today = datetime.date.today()\nmylist.append(today)'
p10638
(F-1.6553250418768988
F-2.7887482276329627
tp10639
sS"import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10640
(F-2.4212420654296873
F-2.7765367948091946
tp10641
sS'print mylist[0]'
p10642
(F-1.8595327649797713
F-2.8037364666278544
tp10643
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10644
(F-1.4042875116521663
F-2.6209247295673075
tp10645
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10646
(F-1.479539813417377
F-2.623236142672025
tp10647
sS"print 'Day of year: ', datetime.date.today().strftime('%j')"
p10648
(F-1.4315725214341108
F-2.6203880310058594
tp10649
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10650
(F-1.4593775431315104
F-2.6103451068584738
tp10651
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10652
(F-1.479539813417377
F-2.623236142672025
tp10653
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10654
(F-1.4999991280691964
F-2.6225351186899037
tp10655
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10656
(F-1.4634117951264252
F-2.6101355919471154
tp10657
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())"
p10658
(F-2.039224624633789
F-2.679796952467698
tp10659
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10660
(F-1.5124495370047433
F-2.6127806443434496
tp10661
sS"print mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10662
(F-3.482384033203125
F-2.9584726186899037
tp10663
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p10664
(F-1.764190936910695
F-2.83390133197491
tp10665
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10666
(F-1.5304036098243916
F-2.6265103266789365
tp10667
sS'import time\nimport datetime'
p10668
(F-3.3805953434535434
F-2.7446746826171875
tp10669
sS'import datetime\nmylist = []'
p10670
(F-3.0889051225450306
F-2.6921231196476865
tp10671
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10672
(F-1.5186995518060378
F-2.6259947556715746
tp10673
sS'import datetime'
p10674
(F-4.8198018074035645
F-2.6974862905649037
tp10675
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())"
p10676
(F-2.0308948516845704
F-2.636658888596755
tp10677
sS'for date in mylist:\n    pass'
p10678
(F-1.6360147649591619
F-2.864012498121995
tp10679
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p10680
(F-1.8873002425484036
F-2.6269205533541164
tp10681
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10682
(F-1.4920873334330897
F-2.6222704373873196
tp10683
sS"print 'This is a new day : ', mylist[0]"
p10684
(F-2.0601673126220703
F-2.804183079646184
tp10685
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10686
(F-1.4805450439453125
F-2.616625272310697
tp10687
sS"'We are the 22, Nov 2008'"
p10688
(F-3.239503542582194
F-2.8442966754619894
tp10689
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p10690
(F-1.757946843686311
F-2.8401800302358775
tp10691
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10692
(F-1.4420821074467556
F-2.6113246037409854
tp10693
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10694
(F-1.4788041388851472
F-2.6161722036508412
tp10695
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10696
(F-1.43952392578125
F-2.6109900841346154
tp10697
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10698
(F-1.4547181562943892
F-2.611429654634916
tp10699
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10700
(F-2.8431448094985066
F-2.7807652400090146
tp10701
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10702
(F-1.479539813417377
F-2.623236142672025
tp10703
sS"today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10704
(F-2.641331082298642
F-2.8015163128192606
tp10705
sS"print 'Day of week: ', datetime.date.today().strftime('%A')"
p10706
(F-1.4315725214341108
F-2.6203880310058594
tp10707
sS"print ('Time in seconds since the epoch: %s' % time.time())"
p10708
(F-1.914061705271403
F-2.713824052077073
tp10709
sS"print ('This is a new day : ' + str(mylist[0]))"
p10710
(F-1.5066149575369698
F-2.7671385544996996
tp10711
sS"print 'We are the {:%d, %b %Y}'.format(today)"
p10712
(F-2.178696950276693
F-2.6126342186561
tp10713
sS'print str(date)'
p10714
(F-2.434496743338449
F-2.647659888634315
tp10715
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10716
(F-1.3533886500767298
F-2.6193257845365086
tp10717
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10718
(F-1.285233553718118
F-2.60763432429387
tp10719
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10720
(F-1.5186995518060378
F-2.6259947556715746
tp10721
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10722
(F-1.501576111379978
F-2.622264862060547
tp10723
sS'mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10724
(F-3.8854843775431314
F-3.00723383976863
tp10725
sS'mylist = []\ntoday = datetime.date.today()'
p10726
(F-2.0532143115997314
F-2.7963350736177883
tp10727
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10728
(F-1.5186995518060378
F-2.6259947556715746
tp10729
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p10730
(F-1.6014357346754808
F-2.716337350698618
tp10731
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p10732
(F-1.6780846913655598
F-2.755962665264423
tp10733
sS"import time\nprint time.strftime('%Y-%m-%d %H:%M')"
p10734
(F-1.3957648277282715
F-2.6109707172100363
tp10735
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10736
(F-1.470723525337551
F-2.621712611271785
tp10737
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10738
(F-1.4834812709263392
F-2.6170178926908054
tp10739
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10740
(F-2.567540486653646
F-2.75705073429988
tp10741
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10742
(F-1.4447080550655242
F-2.611005636361929
tp10743
sS"print 'Current date and time: ', datetime.datetime.now()"
p10744
(F-1.7302970886230469
F-2.6252065805288463
tp10745
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10746
(F-1.4859522039240056
F-2.6151783282940206
tp10747
sS"mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10748
(F-2.577786222417304
F-2.8854449345515323
tp10749
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10750
(F-1.4869939733434607
F-2.617369138277494
tp10751
sS'mylist.append(today)\nprint mylist[0]'
p10752
(F-2.2190702983311246
F-2.947705488938552
tp10753
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10754
(F-1.5102871234600361
F-2.6255082350510817
tp10755
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10756
(F-1.5102871234600361
F-2.6255082350510817
tp10757
sS"print 'We are the {:%d, %b %Y}'.format(today)\n'We are the 22, Nov 2008'"
p10758
(F-2.6598635586825283
F-2.6171675461989183
tp10759
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10760
(F-1.4615986308113473
F-2.611028817983774
tp10761
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p10762
(F-1.588784098625183
F-2.7222615755521336
tp10763
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10764
(F-1.4594730881025206
F-2.6106690626878004
tp10765
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10766
(F-1.498451855717873
F-2.6246883685772238
tp10767
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()"
p10768
(F-1.931647227360652
F-2.622377248910757
tp10769
sS"((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10770
(F-4.573597155119243
F-3.0277134821965146
tp10771
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10772
(F-1.479539813417377
F-2.623236142672025
tp10773
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10774
(F-1.498451855717873
F-2.6246880751389723
tp10775
sS"print today.strftime('We are the %d, %b %Y')"
p10776
(F-1.8202667236328125
F-2.6426412142240086
tp10777
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10778
(F-1.4921893876852448
F-2.6217833298903246
tp10779
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10780
(F-1.4684013267616174
F-2.6117577185997596
tp10781
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10782
(F-1.482555248119213
F-2.621993431678185
tp10783
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10784
(F-1.5102871234600361
F-2.6255082350510817
tp10785
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10786
(F-1.5256178114149306
F-2.618406442495493
tp10787
sS'print mylist[0]\n((2008 - 11) - 22)'
p10788
(F-4.159330031451057
F-2.9739620502178488
tp10789
sS"mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p10790
(F-3.3003408908843994
F-2.9975430415226865
tp10791
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10792
(F-1.463617882361779
F-2.620381575364333
tp10793
sS"import datetime\nprint datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p10794
(F-0.8570961422390408
F-2.5976703350360575
tp10795
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10796
(F-1.4315725214341108
F-2.6203880310058594
tp10797
sS'((2008 - 11) - 22)'
p10798
(F-5.95676005970348
F-3.1226551349346456
tp10799
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10800
(F-1.47955644634408
F-2.615644014798678
tp10801
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10802
(F-1.4767671178598873
F-2.6128707298865685
tp10803
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10804
(F-1.5251670916055895
F-2.626302572397085
tp10805
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10806
(F-1.4315725214341108
F-2.6203880310058594
tp10807
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10808
(F-1.498451855717873
F-2.6246880751389723
tp10809
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10810
(F-1.5251670916055895
F-2.626302572397085
tp10811
sS'import time'
p10812
(F-5.371318340301514
F-2.8720823434682994
tp10813
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p10814
(F-1.4554535715203536
F-2.6214458759014425
tp10815
sS"print 'Current year: ', datetime.date.today().strftime('%Y')"
p10816
(F-1.4315725214341108
F-2.6203880310058594
tp10817
sS"print time.strftime('%Y-%m-%d %H:%M')"
p10818
(F-1.4801003138224285
F-2.608629373403696
tp10819
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10820
(F-1.4346813201904296
F-2.6212117121769833
tp10821
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10822
(F-1.479539813417377
F-2.623236142672025
tp10823
sS"print datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p10824
(F-0.9294949213663737
F-2.596835209773137
tp10825
sS'mylist = []'
p10826
(F-3.730811436971029
F-2.995045882004958
tp10827
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10828
(F-1.498451855717873
F-2.6246883685772238
tp10829
sS'today = datetime.date.today()'
p10830
(F-1.5660284215753728
F-2.7636081988994894
tp10831
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10832
(F-1.4647495435631794
F-2.6113956157977762
tp10833
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p10834
(F-1.4390551508689413
F-2.6191720228928785
tp10835
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p10836
(F-2.754735115246895
F-2.8737432039701023
tp10837
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')"
p10838
(F-1.4315725214341108
F-2.6203880310058594
tp10839
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p10840
(F-1.4402846748947251
F-2.6111359229454627
tp10841
sS"print 'Month of year: ', datetime.date.today().strftime('%B')"
p10842
(F-1.4315725214341108
F-2.6203880310058594
tp10843
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p10844
(F-1.479539813417377
F-2.623236142672025
tp10845
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10846
(F-1.3965914177172112
F-2.6167931189903846
tp10847
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p10848
(F-1.5091727796451067
F-2.62266599214994
tp10849
sS"import time\nimport datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10850
(F-1.440545598301319
F-2.6109222998985877
tp10851
sS"print ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p10852
(F-1.5067421350723658
F-2.615499349740835
tp10853
sS'mylist.append(today)'
p10854
(F-2.631889820098877
F-3.0919209993802586
tp10855
sS"print today.strftime('We are the %d, %b %Y')\n'We are the 22, Nov 2008'"
p10856
(F-2.3573986400257456
F-2.6562784635103664
tp10857
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p10858
(F-1.480104140293451
F-2.621182368351863
tp10859
sS"import datetime\nprint ('Time in seconds since the epoch: %s' % time.time())\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p10860
(F-1.4766544473582301
F-2.6103653540978065
tp10861
ssI1024847
(dp10862
S'print x\nx.update({3: 4, })\nprint x'
p10863
(F-3.9611547369706
F-1.9177867889404296
tp10864
sS'data.pop(key)\ndata.clear()'
p10865
(F-2.5438180650983537
F-1.9279664993286132
tp10866
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10867
(F-2.5046351296561107
F-1.865766716003418
tp10868
sS"data.update({'a': 1, })"
p10869
(F-2.779346172626202
F-1.9779829025268554
tp10870
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10871
(F-2.471060858832465
F-1.9244020462036133
tp10872
sS'data.update(a=1)\ndata.update(data2)'
p10873
(F-2.782071955063764
F-2.0235109329223633
tp10874
sS'data = {}\ndata = dict()'
p10875
(F-2.2496097882588706
F-2.0094221115112303
tp10876
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p10877
(F-2.0689160029093423
F-1.9685380935668946
tp10878
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10879
(F-2.8614974725441855
F-1.88414306640625
tp10880
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10881
(F-2.5828541346958707
F-1.8849666595458985
tp10882
sS'data.update(dict(a=1))'
p10883
(F-2.3733890240009012
F-1.8853630065917968
tp10884
sS"d['mynewkey'] = 'mynewvalue'"
p10885
(F-1.6806434392929077
F-1.9921947479248048
tp10886
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10887
(F-2.9603044225814497
F-1.8946060180664062
tp10888
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]'
p10889
(F-3.179012464440387
F-1.981985855102539
tp10890
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p10891
(F-2.7222442626953125
F-1.9072931289672852
tp10892
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10893
(F-2.381127039591471
F-1.8638633728027343
tp10894
sS'data.pop(key)'
p10895
(F-2.3924660682678223
F-1.912642478942871
tp10896
sS'x = {1: 2, }'
p10897
(F-3.5904808044433594
F-1.9848951339721679
tp10898
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p10899
(F-2.2890128369601266
F-1.9171401977539062
tp10900
sS'data = dict()'
p10901
(F-2.4996920994349887
F-1.9925336837768555
tp10902
sS'data.update(dict(a=1))\ndata.update(a=1)'
p10903
(F-2.7510415857488457
F-1.9098684310913085
tp10904
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10905
(F-2.6226432398745887
F-1.8572261810302735
tp10906
sS'data.update(a=1)'
p10907
(F-3.043766212463379
F-2.0455989837646484
tp10908
sS"data['a'] = 1"
p10909
(F-2.124053955078125
F-2.1565631866455077
tp10910
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10911
(F-2.560267368209696
F-1.86254825592041
tp10912
sS"d = {'key': 'value', }\nprint d"
p10913
(F-2.9168783334585338
F-1.9257562637329102
tp10914
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p10915
(F-2.3714947584198742
F-1.9126144409179688
tp10916
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10917
(F-2.464837893091067
F-1.8697111129760742
tp10918
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]'
p10919
(F-2.919801766531808
F-1.9123821258544922
tp10920
sS'data.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p10921
(F-2.82021642614294
F-1.9152797698974608
tp10922
sS'data.update(data2)\ndel data[key]\ndata.pop(key)'
p10923
(F-2.8140048072451638
F-1.8739221572875977
tp10924
sS'print d'
p10925
(F-4.794997692108154
F-2.292047882080078
tp10926
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p10927
(F-2.8550859339096966
F-1.891202163696289
tp10928
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10929
(F-2.5829004807905718
F-1.8708074569702149
tp10930
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10931
(F-2.719147100681212
F-1.898078155517578
tp10932
sS'print x\nx.update({3: 4, })'
p10933
(F-3.9577488899230957
F-1.8783626556396484
tp10934
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10935
(F-2.5053598655844636
F-1.8555915832519532
tp10936
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10937
(F-2.397054498845881
F-1.8668857574462892
tp10938
sS'data.update(data2)\ndel data[key]'
p10939
(F-2.8815996987479076
F-1.9999992370605468
tp10940
sS"print d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p10941
(F-2.5917391095842635
F-2.035445785522461
tp10942
sS"data = {'a': 1, 'b': 2, 'c': 3, }"
p10943
(F-2.054623497856988
F-2.044499969482422
tp10944
sS'del data[key]'
p10945
(F-2.917345864432199
F-2.0254953384399412
tp10946
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10947
(F-2.6272215843200684
F-1.9085134506225585
tp10948
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p10949
(F-2.5038859049479165
F-1.8768207550048828
tp10950
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10951
(F-2.6779609886375635
F-1.9375017166137696
tp10952
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10953
(F-2.336340801532452
F-1.9055461883544922
tp10954
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p10955
(F-1.9773542469945447
F-1.981815719604492
tp10956
sS'del data[key]\ndata.pop(key)'
p10957
(F-2.9912354605538503
F-1.844303512573242
tp10958
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10959
(F-2.343386742376512
F-1.8726909637451172
tp10960
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10961
(F-2.614316463470459
F-1.9137842178344726
tp10962
sS'x.update({3: 4, })\nprint x'
p10963
(F-3.9046130180358887
F-1.8441057205200195
tp10964
sS"d = {'key': 'value', }"
p10965
(F-2.973497200012207
F-1.9655614852905274
tp10966
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p10967
(F-2.717832538443552
F-1.8903600692749023
tp10968
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10969
(F-2.9538609822591146
F-1.885489273071289
tp10970
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p10971
(F-2.4379838885683003
F-1.869283676147461
tp10972
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10973
(F-2.561834958520266
F-1.8516820907592773
tp10974
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p10975
(F-2.758173037797977
F-1.8766185760498046
tp10976
sS'data.clear()'
p10977
(F-2.2166786193847656
F-2.305771827697754
tp10978
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p10979
(F-3.055903116861979
F-1.9481435775756837
tp10980
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p10981
(F-2.407213338216146
F-1.8999048233032227
tp10982
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10983
(F-2.4518196292039827
F-1.8759939193725585
tp10984
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p10985
(F-2.7473175412132624
F-1.8943504333496093
tp10986
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p10987
(F-2.8991270065307617
F-1.9131647109985352
tp10988
sS'data.update(data2)'
p10989
(F-1.8984293937683105
F-2.0399202346801757
tp10990
sS'data = dict(a=1, b=2, c=3)'
p10991
(F-2.701076719495985
F-2.0110652923583983
tp10992
sS'x = {1: 2, }\nprint x\nx.update({3: 4, })\nprint x'
p10993
(F-3.5887930733816966
F-1.83359375
tp10994
sS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p10995
(F-2.5381632265837295
F-1.9172370910644532
tp10996
sS"print d\nd['mynewkey'] = 'mynewvalue'"
p10997
(F-2.7731203599409624
F-2.008539390563965
tp10998
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p10999
(F-2.561700674203726
F-1.8967319488525392
tp11000
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)'
p11001
(F-2.6262043920056573
F-1.9187475204467774
tp11002
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p11003
(F-2.290235768193784
F-1.9076856613159179
tp11004
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11005
(F-2.9785342746310763
F-1.8688383102416992
tp11006
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11007
(F-2.44622501326196
F-1.8665384292602538
tp11008
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11009
(F-2.844177929323111
F-1.9019676208496095
tp11010
sS"data['a'] = 1\ndata.update({'a': 1, })"
p11011
(F-2.66959228515625
F-1.9946601867675782
tp11012
sS'x.update({3: 4, })'
p11013
(F-3.7017012376051683
F-1.8295652389526367
tp11014
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11015
(F-2.387658584949582
F-1.8716712951660157
tp11016
sS'x = {1: 2, }\nprint x'
p11017
(F-3.183131584754357
F-2.0001625061035155
tp11018
sS'print x'
p11019
(F-4.559996604919434
F-2.501777458190918
tp11020
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11021
(F-2.52156862299493
F-1.8637702941894532
tp11022
sS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'"
p11023
(F-2.643454360961914
F-1.8904289245605468
tp11024
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11025
(F-2.3407007853190103
F-1.9248056411743164
tp11026
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p11027
(F-3.1169474283854166
F-1.9031858444213867
tp11028
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11029
(F-2.820307413736979
F-1.9078880310058595
tp11030
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11031
(F-2.6199216937074565
F-1.8715925216674805
tp11032
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11033
(F-2.3841988699776784
F-1.9787822723388673
tp11034
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11035
(F-2.6381125614560883
F-1.8973207473754883
tp11036
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p11037
(F-2.9229947044735862
F-1.8839225769042969
tp11038
sS'data = {}'
p11039
(F-3.435277303059896
F-2.152342987060547
tp11040
sS"data.update({'a': 1, })\ndata.update(dict(a=1))"
p11041
(F-2.770005798339844
F-1.898524856567383
tp11042
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11043
(F-2.5927975463867186
F-2.018063545227051
tp11044
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p11045
(F-2.317969185965402
F-1.8726579666137695
tp11046
sS"d['mynewkey'] = 'mynewvalue'\nprint d"
p11047
(F-2.0519778511740943
F-2.0386558532714845
tp11048
sS'del data[key]\ndata.pop(key)\ndata.clear()'
p11049
(F-3.0143741607666015
F-1.8675870895385742
tp11050
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p11051
(F-2.4315828595842635
F-1.9661102294921875
tp11052
sS'x = {1: 2, }\nprint x\nx.update({3: 4, })'
p11053
(F-3.6157574462890625
F-1.816505241394043
tp11054
ssI120656
(dp11055
S"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p11056
(F-1.3725417455037434
F-3.3857701619466147
tp11057
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p11058
(F-1.344530029296875
F-3.4040873845418296
tp11059
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11060
(F-1.3431389808654786
F-3.4008591969807944
tp11061
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p11062
(F-1.7425233667547053
F-3.3703912099202475
tp11063
sS'for filename in filenames:\n    pass'
p11064
(F-1.725185220891779
F-3.4303207397460938
tp11065
sS"import os\nfor filename in os.listdir('C:\\\\temp'):\n    pass"
p11066
(F-1.034608941329153
F-3.3814881642659507
tp11067
sS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11068
(F-1.552674745258532
F-3.3875020345052085
tp11069
sS'print os.path.join(dirname, subdirname)'
p11070
(F-1.042050288273738
F-3.4226601918538413
tp11071
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p11072
(F-1.3393610828327682
F-3.399826685587565
tp11073
sS"if ('.git' in dirnames):\n    pass"
p11074
(F-2.1395639272836537
F-3.5800043741861978
tp11075
sS"dirnames.remove('.git')"
p11076
(F-1.7278645038604736
F-3.665232022603353
tp11077
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p11078
(F-1.3778526306152343
F-3.378939946492513
tp11079
sS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    pass"
p11080
(F-1.5935247016675544
F-3.3894805908203125
tp11081
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11082
(F-1.3658762349710836
F-3.382385571797689
tp11083
sS'for subdirname in dirnames:\n    pass'
p11084
(F-1.3753156661987305
F-3.6243197123209634
tp11085
sS'import os'
p11086
(F-3.915839195251465
F-3.531834284464518
tp11087
sS'print filename'
p11088
(F-3.4339239597320557
F-3.454798380533854
tp11089
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p11090
(F-1.4931525028113164
F-3.383742332458496
tp11091
sS'os.listdir(path)'
p11092
(F-1.14738130569458
F-3.4019571940104165
tp11093
sS"for filename in os.listdir('C:\\\\temp'):\n    pass"
p11094
(F-1.126922607421875
F-3.4037351608276367
tp11095
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p11096
(F-1.6642457580566405
F-3.387579600016276
tp11097
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p11098
(F-1.5218121846516928
F-3.357178052266439
tp11099
sS'print os.path.join(dirname, filename)'
p11100
(F-1.2128686171311598
F-3.4161106745402017
tp11101
sS"if ('.git' in dirnames):\n    dirnames.remove('.git')"
p11102
(F-1.861100090874566
F-3.6361846923828125
tp11103
ssI2150739
(dp11104
S'import datetime'
p11105
(F-4.799181938171387
F-4.0949648076837715
tp11106
sS"from datetime import datetime\ndatetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p11107
(F-1.2429509480794272
F-3.918610312721946
tp11108
sS'def utcoffset(self, dt):\n    pass'
p11109
(F-1.4096660614013672
F-4.800975452769887
tp11110
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p11111
(F-1.6890384129115514
F-4.1699770147150215
tp11112
sS'def utcoffset(self, dt):\n    return timedelta(minutes=(-399))'
p11113
(F-2.304471223250679
F-4.56353725086559
tp11114
sS'class TZ(tzinfo):\n    pass'
p11115
(F-1.1160202026367188
F-4.8663482666015625
tp11116
sS'return timedelta(minutes=(-399))'
p11117
(F-3.6093241373697915
F-4.4146059209650215
tp11118
sS'from datetime import tzinfo, timedelta, datetime'
p11119
(F-4.015510940551758
F-3.9473228454589844
tp11120
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p11121
(F-1.0497674942016602
F-4.927147951993075
tp11122
sS'datetime.fromtimestamp(x)'
p11123
(F-2.3675684928894043
F-3.9901948408647017
tp11124
sS"from time import strftime\nstrftime('%Y-%m-%d %H:%M:%S')"
p11125
(F-2.0107638619162818
F-4.124034188010476
tp11126
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11127
(F-2.768925666809082
F-4.672766251997515
tp11128
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p11129
(F-1.966534354469993
F-4.112149325284091
tp11130
sS'from mx.DateTime.ISO import ParseDateTimeUTC'
p11131
(F-2.6141897348257213
F-4.76084414395419
tp11132
sS'import datetime\ndatetime.datetime.now().isoformat()'
p11133
(F-1.4626671075820923
F-3.9749901511452417
tp11134
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11135
(F-2.4301961263020835
F-4.2056496360085225
tp11136
sS'import datetime\ndatetime.datetime.utcnow().isoformat()'
p11137
(F-1.9705073833465576
F-3.9660485007546167
tp11138
sS'datetime.datetime.now().isoformat()'
p11139
(F-1.5441005413348858
F-3.9547535289417612
tp11140
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n    pass'
p11141
(F-2.047713735829229
F-4.08591045032848
tp11142
sS"from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11143
(F-2.223506450653076
F-4.109196402809837
tp11144
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p11145
(F-1.746088779333866
F-4.692895369096235
tp11146
sS'datetime.datetime.utcnow().isoformat()'
p11147
(F-2.0107489365797777
F-3.961745175448331
tp11148
sS'from datetime import datetime'
p11149
(F-3.631117820739746
F-3.9254850907759233
tp11150
sS"datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11151
(F-2.3929250807989213
F-4.228277033025568
tp11152
sS"datetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p11153
(F-1.1641212463378907
F-3.989227294921875
tp11154
sS"strftime('%Y-%m-%d %H:%M:%S')"
p11155
(F-2.0100350379943848
F-4.094686681574041
tp11156
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11157
(F-2.3062589818781074
F-3.9463497508655894
tp11158
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11159
(F-2.268661050235524
F-4.1236114501953125
tp11160
sS'from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime'
p11161
(F-2.859734853108724
F-4.22663671320135
tp11162
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11163
(F-2.575854133157169
F-4.216182361949574
tp11164
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11165
(F-2.5599599202473957
F-3.9650469693270596
tp11166
sS"class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11167
(F-2.151349769448334
F-4.516447240656072
tp11168
sS'from time import strftime'
p11169
(F-4.2295792897542315
F-4.19158900867809
tp11170
ssI1186789
(dp11171
S"if (__name__ == '__main__'):\n    service_func()"
p11172
(F-2.4646108526932564
F-1.6688824821920956
tp11173
sS"print 'test1.py'"
p11174
(F-2.811866283416748
F-1.6451604506548714
tp11175
sS"def service_func():\n    print 'service func'"
p11176
(F-2.1209922518048967
F-1.5917094735538257
tp11177
sS'def service_func():\n    pass'
p11178
(F-2.202980775099534
F-1.589822432574104
tp11179
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p11180
(F-2.3191521167755127
F-1.6364832485423368
tp11181
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p11182
(F-2.2862365029074927
F-1.578777649823357
tp11183
sS'service_func()'
p11184
(F-3.1552723475864957
F-1.628958085004021
tp11185
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p11186
(F-2.079557010105678
F-1.6086784811580883
tp11187
sS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    pass"
p11188
(F-1.9323477063860213
F-1.6221763386445887
tp11189
sS"print 'in test 1, unproductive'"
p11190
(F-2.811866283416748
F-1.6451605628518498
tp11191
sS'import test1'
p11192
(F-3.786586284637451
F-1.5501971525304459
tp11193
sS'def some_func():\n    pass'
p11194
(F-1.9275217789870043
F-1.610541399787454
tp11195
sS"subprocess.call('test1.py', shell=True)"
p11196
(F-1.1933021545410156
F-1.4554167354808134
tp11197
sS"execfile('test2.py')"
p11198
(F-1.3729162216186523
F-1.7577893874224495
tp11199
sS"import test1\n\ndef service_func():\n    print 'service func'"
p11200
(F-1.8595422108968098
F-1.5140252954819624
tp11201
sS'import subprocess'
p11202
(F-4.564359664916992
F-1.3475151062011719
tp11203
sS'import test1\n\ndef service_func():\n    pass'
p11204
(F-1.9397457347196692
F-1.5056276882396025
tp11205
sS"print 'service func'"
p11206
(F-2.811866283416748
F-1.6451605628518498
tp11207
sS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    some_func()"
p11208
(F-2.011091709136963
F-1.6471369126263786
tp11209
sS"if (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p11210
(F-2.5932546544958046
F-1.660592471852022
tp11211
sS"import subprocess\nsubprocess.call('test1.py', shell=True)"
p11212
(F-1.0588699340820313
F-1.418194378123564
tp11213
sS'some_func()'
p11214
(F-2.2414467675345287
F-1.6450166141285616
tp11215
sS'test1.some_func()'
p11216
(F-2.2077168358696833
F-1.594022975248449
tp11217
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p11218
(F-1.970106840133667
F-1.5510897916906021
tp11219
sS"if (__name__ == '__main__'):\n    some_func()"
p11220
(F-2.1468672501413444
F-1.6792448829202091
tp11221
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p11222
(F-2.44671516418457
F-1.6339748606962317
tp11223
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p11224
(F-2.1844558715820312
F-1.5771681841681986
tp11225
sS"if (__name__ == '__main__'):\n    pass"
p11226
(F-1.9535797119140625
F-1.6436051761402803
tp11227
sS"def some_func():\n    print 'in test 1, unproductive'"
p11228
(F-1.8610006059919084
F-1.6163105684168197
tp11229
ssI1747817
(dp11230
S'dict(gen)'
p11231
(F-1.7095130284627278
F-2.2121303558349608
tp11232
sS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11233
(F-3.1037682705238216
F-2.1308433532714846
tp11234
sS'd = {k: v for (k, v) in iterable}'
p11235
(F-2.3294065138872933
F-1.8382017135620117
tp11236
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p11237
(F-3.3151627797929066
F-1.9959856033325196
tp11238
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11239
(F-1.93175048828125
F-2.086107635498047
tp11240
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11241
(F-1.7710715239902712
F-2.107009506225586
tp11242
sS'd = dict(map(key_value_gen, range(26)))'
p11243
(F-2.7200523376464845
F-1.9678417205810548
tp11244
sS'ts = [(1, 2), (3, 4), (5, 6)]'
p11245
(F-1.4608535766601562
F-2.188389205932617
tp11246
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11247
(F-2.462711218631629
F-2.2362823486328125
tp11248
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11249
(F-2.2390590080848107
F-2.3029409408569337
tp11250
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))'
p11251
(F-2.8764133029513888
F-1.9701850891113282
tp11252
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)'
p11253
(F-1.2757859911237444
F-2.1112655639648437
tp11254
sS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p11255
(F-3.2019435337611606
F-2.308367156982422
tp11256
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11257
(F-2.7280994762073862
F-2.1726215362548826
tp11258
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11259
(F-2.4055313602570565
F-2.1723331451416015
tp11260
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11261
(F-2.572952069734272
F-2.1415950775146486
tp11262
sS'def key_value_gen(k):\n    pass'
p11263
(F-2.0946671962738037
F-2.345860481262207
tp11264
sS'yield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11265
(F-3.4318161010742188
F-2.061553192138672
tp11266
sS'yield chr((k + 65))'
p11267
(F-3.165784315629439
F-2.4312717437744142
tp11268
sS'd = {key: value for (key, value) in iterable}'
p11269
(F-2.6498615040498623
F-1.8603540420532227
tp11270
sS'dict(ts)'
p11271
(F-1.7095130284627278
F-2.2121303558349608
tp11272
sS'gen\ndict(gen)'
p11273
(F-3.603996753692627
F-2.246509552001953
tp11274
sS'yield chr((((k + 13) % 26) + 65))'
p11275
(F-3.8473040932103206
F-2.4360666275024414
tp11276
sS'def key_value_gen(k):\n    yield chr((k + 65))'
p11277
(F-2.4309377670288086
F-2.3026336669921874
tp11278
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11279
(F-2.616337639944894
F-2.2949703216552733
tp11280
sS'gen'
p11281
(F-7.182577133178711
F-2.582796096801758
tp11282
sS'd = dict(((key, value) for (key, value) in iterable))'
p11283
(F-2.376341559670188
F-1.863653564453125
tp11284
sS'd = {value: foo(value) for value in sequence if bar(value)}'
p11285
(F-2.966062999906994
F-1.9035232543945313
tp11286
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11287
(F-3.2063334395245806
F-1.9497411727905274
tp11288
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11289
(F-1.956455438787287
F-2.1069267272949217
tp11290
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    pass'
p11291
(F-2.760863226813239
F-1.9616880416870117
tp11292
ssI2793324
(dp11293
S'a = [1, 2, 3, 4]'
p11294
(F-1.793462166419396
F-1.8907567192526424
tp11295
sS'if (c in a):\n    a.remove(c)'
p11296
(F-2.4162025451660156
F-1.93121898875517
tp11297
sS'pass'
p11298
(F-4.467843691507976
F-2.1491773268755745
tp11299
sS'if (c in a):\n    pass'
p11300
(F-2.635759500356821
F-1.9472997328814339
tp11301
sS'print a'
p11302
(F-4.5604400634765625
F-2.038330078125
tp11303
sS"a.remove('b')"
p11304
(F-2.0462093353271484
F-1.9016654070685892
tp11305
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]'
p11306
(F-1.7616569705125762
F-1.8970013786764706
tp11307
sS'if (6 in a):\n    pass'
p11308
(F-3.0293206434983473
F-1.9458725873161764
tp11309
sS'a.remove(6)'
p11310
(F-2.981572151184082
F-1.8945186839384192
tp11311
sS'if (6 in a):\n    a.remove(6)'
p11312
(F-3.1222750345865884
F-1.935714048497817
tp11313
sS'a = [x for x in a if (x != 2)]'
p11314
(F-2.3863363826976105
F-1.9123526180491728
tp11315
sS'a = [x for x in a if (x != 2)]\nprint a'
p11316
(F-2.381002426147461
F-1.9130527271943933
tp11317
sS'a = [1, 2, 3, 4]\nif (6 in a):\n    a.remove(6)'
p11318
(F-2.2707010904947915
F-1.9044146818273209
tp11319
sS'a.remove(c)'
p11320
(F-2.156597137451172
F-1.9079073737649357
tp11321
sS"a.remove('b')\nprint a"
p11322
(F-2.421023802323775
F-1.911808687097886
tp11323
sS'a = [1, 2, 3, 4]\nif (6 in a):\n    pass'
p11324
(F-2.1053369140625
F-1.8968259026022518
tp11325
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')"
p11326
(F-1.4596464157104492
F-1.9136558981502758
tp11327
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]'
p11328
(F-1.6889535522460937
F-1.897530948414522
tp11329
sS'try:\n    a.remove(6)\nexcept:\n    pass'
p11330
(F-1.8719066619873046
F-1.9482646268956803
tp11331
sS'try:\n    a.remove(c)\nexcept ValueError:\n    pass'
p11332
(F-1.2004678899591619
F-1.9543037414550781
tp11333
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]\nprint a'
p11334
(F-1.780442324551669
F-1.8952194662655102
tp11335
sS"a = ['a', 'b', 'c', 'd']"
p11336
(F-1.6384058732252855
F-1.9683707742130054
tp11337
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')\nprint a"
p11338
(F-1.6002180679984714
F-1.9107324936810661
tp11339
ssI123198
(dp11340
S'from shutil import copyfile\ncopyfile(src, dst)'
p11341
(F-1.7604560852050781
F-1.48817270452326
tp11342
sS"shutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p11343
(F-1.2990259170532226
F-1.486262408169833
tp11344
sS"shutil.copy2('/dir/file.ext', '/new/dir')"
p11345
(F-1.2990259170532226
F-1.486262408169833
tp11346
sS"import shutil\nshutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p11347
(F-1.2003689545851488
F-1.3862992199984463
tp11348
sS'from shutil import copyfile'
p11349
(F-2.9346421559651694
F-1.4623640233820134
tp11350
sS'copyfile(src, dst)'
p11351
(F-2.2797179222106934
F-1.64280874078924
tp11352
sS'import shutil'
p11353
(F-4.420064449310303
F-1.4394514777443626
tp11354
ssI1602934
(dp11355
S'from collections import defaultdict\nd = defaultdict((lambda : 0))'
p11356
(F-3.3338899051441864
F-3.017042795817057
tp11357
sS'key = (i % 10)'
p11358
(F-3.800837622748481
F-3.07794189453125
tp11359
sS"('a' in d)\n('c' in d)"
p11360
(F-4.184339670034555
F-2.9825464884440103
tp11361
sS'for i in xrange(100):\n    d[(i % 10)] += 1'
p11362
(F-2.060050632642663
F-3.2290004094441733
tp11363
sS'd = defaultdict((lambda : 0))'
p11364
(F-4.446861902872722
F-3.007176399230957
tp11365
sS'd[key] = 1'
p11366
(F-2.625469923019409
F-2.903010050455729
tp11367
sS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p11368
(F-2.5026290111052685
F-3.0593350728352866
tp11369
sS'd = dict()\nfor i in xrange(100):\n    pass'
p11370
(F-1.5835498809814452
F-2.951239903767904
tp11371
sS"d = {'a': 1, 'b': 2, }"
p11372
(F-2.4242676326206754
F-2.897881825764974
tp11373
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11374
(F-1.937076083096591
F-2.923720677693685
tp11375
sS'if (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11376
(F-1.799266560872396
F-2.8424485524495444
tp11377
sS"if ('key1' in dict):\n    print 'blah'\nelse:\n    print 'boo'"
p11378
(F-1.4882448369806462
F-2.987703323364258
tp11379
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p11380
(F-1.9591415405273438
F-2.9248526891072593
tp11381
sS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p11382
(F-2.8839675903320314
F-3.0618896484375
tp11383
sS'if (key in d):\n    d[key] += 1'
p11384
(F-2.0941600799560547
F-2.8397480646769204
tp11385
sS'd[key] += 1'
p11386
(F-2.448981523513794
F-2.919707934061686
tp11387
sS"('a' in d)"
p11388
(F-4.0224312373570035
F-3.0249506632486978
tp11389
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)'
p11390
(F-2.0768764202411356
F-2.960397720336914
tp11391
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p11392
(F-2.0777094641397165
F-2.9310839970906577
tp11393
sS'd = dict()'
p11394
(F-2.5918143136160716
F-2.8476222356160483
tp11395
sS"if ('key1' in dict):\n    pass"
p11396
(F-2.204185779278095
F-2.991384188334147
tp11397
sS"d = {'a': 1, 'b': 2, }\n('a' in d)"
p11398
(F-3.265044403076172
F-2.852726936340332
tp11399
sS"if ('key1' in dict):\n    print 'blah'\nelse:\n    pass"
p11400
(F-1.7156686328706288
F-2.970794359842936
tp11401
sS'for i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p11402
(F-2.329056187679893
F-2.9766362508138022
tp11403
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p11404
(F-2.1924057006835938
F-2.937335650126139
tp11405
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p11406
(F-2.1865626248446377
F-2.961557706197103
tp11407
sS'from collections import defaultdict'
p11408
(F-3.352107365926107
F-3.006856918334961
tp11409
sS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p11410
(F-2.439721934000651
F-3.0378735860188804
tp11411
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p11412
(F-2.283540964126587
F-2.9837023417154946
tp11413
sS'for i in xrange(100):\n    pass'
p11414
(F-1.5414060865129744
F-3.2069546381632485
tp11415
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p11416
(F-2.039097699252042
F-2.936713536580404
tp11417
sS'for i in xrange(100):\n    key = (i % 10)'
p11418
(F-2.182763862609863
F-3.137047449747721
tp11419
sS"d = {'a': 1, 'b': 2, }\n('a' in d)\n('c' in d)"
p11420
(F-3.4520011314978967
F-2.843557675679525
tp11421
sS'd[key] = (d.get(key, 0) + 1)'
p11422
(F-2.6740401418585527
F-2.947709401448568
tp11423
sS"print 'blah'"
p11424
(F-4.240025520324707
F-3.313629150390625
tp11425
sS"('c' in d)"
p11426
(F-4.0224312373570035
F-3.0249506632486978
tp11427
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p11428
(F-2.157244029798006
F-2.938939094543457
tp11429
sS'd[(i % 10)] += 1'
p11430
(F-2.8596674601236978
F-3.1171722412109375
tp11431
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11432
(F-1.9805079868861608
F-2.9203503926595054
tp11433
sS'if (key in d):\n    pass'
p11434
(F-2.260817601130559
F-2.854889233907064
tp11435
sS'if (key in d):\n    d[key] += 1\nelse:\n    pass'
p11436
(F-1.8403633117675782
F-2.8526522318522134
tp11437
sS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p11438
(F-2.8421072118422566
F-3.114490826924642
tp11439
sS"print 'boo'"
p11440
(F-4.240025520324707
F-3.313629150390625
tp11441
ssI9573244
(dp11442
S'if (not my_string):\n    pass'
p11443
(F-2.3471483503069197
F-2.043696085611979
tp11444
sS"bool('   '.strip())"
p11445
(F-2.7468000411987306
F-2.308446248372396
tp11446
sS"bool('')\nbool('   ')"
p11447
(F-3.748017051003196
F-2.506396738688151
tp11448
sS'if some_string:\n    pass'
p11449
(F-1.9233847531405361
F-2.0697959899902343
tp11450
sS'if (not myString):\n    pass'
p11451
(F-2.4759806119478664
F-2.0535568237304687
tp11452
sS'if (not some_string):\n    pass'
p11453
(F-2.485306876046317
F-2.0523480733235675
tp11454
sS"bool('   ')\nbool('   '.strip())"
p11455
(F-3.454651133219401
F-2.4308430989583334
tp11456
sS'pass'
p11457
(F-3.4143199920654297
F-2.2148178100585936
tp11458
sS"bool('')\nbool('   ')\nbool('   '.strip())"
p11459
(F-3.628019332885742
F-2.50728759765625
tp11460
sS"bool('   ')"
p11461
(F-3.2414172490437827
F-2.37653071085612
tp11462
sS"bool('')"
p11463
(F-3.2414172490437827
F-2.37653071085612
tp11464
ssI743806
(dp11465
S"words = text.split(',')"
p11466
(F-1.997589111328125
F-1.5348836051093206
tp11467
sS"line = 'a sentence with a few words'\nline.split()"
p11468
(F-2.1095230796120386
F-1.6137305365668402
tp11469
sS'words = text.split()'
p11470
(F-2.3920169406467013
F-1.5230862299601238
tp11471
sS'line.split()'
p11472
(F-1.8882904052734375
F-1.5850375493367512
tp11473
sS'word.append(words)'
p11474
(F-2.468348979949951
F-1.4109560648600261
tp11475
sS"line = 'a sentence with a few words'"
p11476
(F-3.7028953552246096
F-1.8614868587917752
tp11477
sS'words.append(word)'
p11478
(F-1.9863147735595703
F-1.4289563496907551
tp11479
sS'text.split()'
p11480
(F-2.078920364379883
F-1.5457672542995877
tp11481
ssI518021
(dp11482
S'len(l)\nlen(s)'
p11483
(F-2.5458587299693716
F-1.9149358749389649
tp11484
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)\nlen(s)"
p11485
(F-2.026397846363209
F-1.9644052505493164
tp11486
sS"s = 'abcde'"
p11487
(F-3.2084869384765624
F-2.0419925689697265
tp11488
sS'my_tuple = (1, 2, 3, 4, 5)'
p11489
(F-2.140158260569853
F-1.7316343307495117
tp11490
sS'my_tuple = (1, 2, 3, 4, 5)\nlen(my_tuple)'
p11491
(F-2.0091493924458823
F-1.7907550811767579
tp11492
sS'len(l)'
p11493
(F-2.021669387817383
F-1.8151969909667969
tp11494
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)"
p11495
(F-1.8441038998690518
F-1.9309572219848632
tp11496
sS"l = [1, 2, 3, 4]\ns = 'abcde'"
p11497
(F-2.302425608915441
F-1.8492345809936523
tp11498
sS'len(my_list)'
p11499
(F-1.4563509225845337
F-1.774679946899414
tp11500
sS"s = 'abcde'\nlen(l)"
p11501
(F-1.9716556549072266
F-1.989377212524414
tp11502
sS'my_list = [1, 2, 3, 4, 5]\nlen(my_list)'
p11503
(F-1.422343413035075
F-1.8379898071289062
tp11504
sS"my_string = 'hello world'"
p11505
(F-2.749197006225586
F-1.9637657165527345
tp11506
sS"my_string = 'hello world'\nlen(my_string)"
p11507
(F-1.8849171229771204
F-1.9155519485473633
tp11508
sS'my_list = [1, 2, 3, 4, 5]'
p11509
(F-1.7394161224365234
F-1.7775352478027344
tp11510
sS"s = 'abcde'\nlen(l)\nlen(s)"
p11511
(F-2.16978759765625
F-2.0280506134033205
tp11512
sS'len(my_string)'
p11513
(F-1.749955415725708
F-1.7962345123291015
tp11514
sS'l = [1, 2, 3, 4]'
p11515
(F-2.0774239760178785
F-1.8125099182128905
tp11516
sS'len(my_tuple)'
p11517
(F-2.0768799781799316
F-1.7589080810546875
tp11518
sS'len(s)'
p11519
(F-2.0843286514282227
F-1.7933225631713867
tp11520
ssI510348
(dp11521
S"import time\nwhile True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p11522
(F-1.3283222198486329
F-1.9454919497172039
tp11523
sS'time.sleep(60)'
p11524
(F-1.142120361328125
F-1.9890276590983074
tp11525
sS'from time import sleep'
p11526
(F-3.258012135823568
F-1.9554375012715657
tp11527
sS"print 'This prints once a minute.'"
p11528
(F-3.421339511871338
F-2.0163710912068686
tp11529
sS'import time'
p11530
(F-4.3119659423828125
F-1.9331363042195637
tp11531
sS'time.sleep(5)'
p11532
(F-1.009531021118164
F-1.9800783793131511
tp11533
sS'sleep(0.1)'
p11534
(F-1.3723042805989583
F-1.990761121114095
tp11535
sS'import time\ntime.sleep(60)'
p11536
(F-1.1288261413574219
F-1.9515748023986816
tp11537
sS'import time\ntime.sleep(5)'
p11538
(F-0.9779394323175604
F-1.9455536206563313
tp11539
sS'from time import sleep\nsleep(0.1)'
p11540
(F-1.4819027293812146
F-1.9569387435913086
tp11541
sS'while True:\n    pass'
p11542
(F-1.35033204820421
F-1.9735727310180664
tp11543
sS'time.sleep(0.1)'
p11544
(F-0.8519840240478516
F-2.0153443018595376
tp11545
sS"while True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p11546
(F-1.3970079982981962
F-1.9540850321451824
tp11547
sS'import time\ntime.sleep(0.1)'
p11548
(F-0.8715175281871449
F-1.96044921875
tp11549
sS'import time\nwhile True:\n    pass'
p11550
(F-1.2398308912913005
F-1.9362675348917644
tp11551
sS'time.sleep(time.localtime(time.time())[5])'
p11552
(F-1.5897154808044434
F-1.9310811360677083
tp11553
ssI82831
(dp11554
S"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p11555
(F-1.3717348052234184
F-2.6061947162334738
tp11556
sS"print os.path.isfile('/etc')"
p11557
(F-1.3402997797185725
F-2.5624016981858473
tp11558
sS"my_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p11559
(F-1.9301119584303637
F-2.6017579298753004
tp11560
sS"print os.path.exists('/etc/password.txt')"
p11561
(F-1.8185977935791016
F-2.5573360736553488
tp11562
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11563
(F-1.7345617385137648
F-2.569933671217698
tp11564
sS'import os.path'
p11565
(F-3.037501017252604
F-2.581893334021935
tp11566
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p11567
(F-1.2766504741850353
F-2.5877066392164965
tp11568
sS'import os.path\nos.path.exists(file_path)'
p11569
(F-1.7317282732795267
F-2.5460868248572717
tp11570
sS'pass'
p11571
(F-3.5109945933024087
F-2.6909634516789365
tp11572
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p11573
(F-1.414827654438634
F-2.594052241398738
tp11574
sS"from pathlib import Path\nmy_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p11575
(F-1.8173157476609754
F-2.6064637991098256
tp11576
sS"print os.path.isfile('/does/not/exist')"
p11577
(F-1.3402996063232422
F-2.5624016981858473
tp11578
sS"from pathlib import Path\nmy_file = Path('/path/to/file')"
p11579
(F-2.1767420450846355
F-2.6563034057617188
tp11580
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11581
(F-1.4866345103194074
F-2.5993165236253004
tp11582
sS'from pathlib import Path'
p11583
(F-2.881307601928711
F-2.7198143005371094
tp11584
sS'os.path.isfile(fname)'
p11585
(F-0.7115272998809814
F-2.6128211388221154
tp11586
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11587
(F-1.5300846473843444
F-2.6045077397273135
tp11588
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')"
p11589
(F-1.2766502925327845
F-2.5877066392164965
tp11590
sS"print os.path.exists('/etc')"
p11591
(F-1.8185977935791016
F-2.5573360736553488
tp11592
sS"my_file = Path('/path/to/file')"
p11593
(F-2.382978057861328
F-2.646317115196815
tp11594
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p11595
(F-1.488920120965867
F-2.575444148137019
tp11596
sS'if my_file.is_file():\n    pass'
p11597
(F-1.839498856488396
F-2.598217303936298
tp11598
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11599
(F-1.5612657608524445
F-2.5847845811110277
tp11600
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11601
(F-1.7269347406202746
F-2.5839614868164062
tp11602
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11603
(F-1.481382276191086
F-2.612629230205829
tp11604
sS"print os.path.exists('/does/not/exist')"
p11605
(F-1.8185977935791016
F-2.5573360736553488
tp11606
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p11607
(F-1.2655237259403351
F-2.604267413799579
tp11608
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11609
(F-1.5976367113066883
F-2.5934410095214844
tp11610
sS'import os.path\nos.path.isfile(fname)'
p11611
(F-1.2782756805419921
F-2.5852831326998196
tp11612
sS"print os.path.isfile('/etc/password.txt')"
p11613
(F-1.3402996063232422
F-2.5624016981858473
tp11614
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p11615
(F-1.4373551910998774
F-2.6092529296875
tp11616
sS'os.path.exists(file_path)'
p11617
(F-1.43967072168986
F-2.535426506629357
tp11618
sS"print os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p11619
(F-1.7345617385137648
F-2.569933671217698
tp11620
ssI510357
(dp11621
S'def _find_getch():\n    pass'
p11622
(F-1.7234485332782452
F-2.787470245361328
tp11623
sS'return ch\nreturn _getch\ngetch = _find_getch()'
p11624
(F-2.9560559590657554
F-2.763995361328125
tp11625
sS'fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11626
(F-1.811779715798118
F-3.0547908782958983
tp11627
sS'def __init__(self):\n    pass'
p11628
(F-1.3110254832676478
F-2.9775720596313477
tp11629
sS'return self.impl()'
p11630
(F-2.695958375930786
F-2.997600555419922
tp11631
sS'def _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11632
(F-1.8612955729166667
F-2.976167106628418
tp11633
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p11634
(F-1.4060640077333193
F-2.9887081146240235
tp11635
sS'return ch\nreturn _getch'
p11636
(F-3.338899884905134
F-2.8671356201171876
tp11637
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'"
p11638
(F-1.8086310492621527
F-2.8848304748535156
tp11639
sS'return _getch'
p11640
(F-3.5869860649108887
F-2.872623062133789
tp11641
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p11642
(F-1.2745520550271738
F-2.9660146713256834
tp11643
sS'tty.setraw(fd)'
p11644
(F-2.0075604915618896
F-2.8159046173095703
tp11645
sS'tty.setraw(sys.stdin.fileno())'
p11646
(F-1.6381382261003767
F-2.94152889251709
tp11647
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p11648
(F-1.764269395308061
F-2.9923961639404295
tp11649
sS'def __call__(self):\n    pass'
p11650
(F-1.703143528529576
F-2.996468353271484
tp11651
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p11652
(F-1.4524447792454769
F-2.972525405883789
tp11653
sS'termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)'
p11654
(F-2.2812232971191406
F-3.160444450378418
tp11655
sS'ch = sys.stdin.read(1)'
p11656
(F-1.3532737096150715
F-3.0748565673828123
tp11657
sS'old_settings = termios.tcgetattr(fd)'
p11658
(F-2.0827368100484214
F-2.862687683105469
tp11659
sS'def __call__(self):\n    import sys, tty, termios'
p11660
(F-2.0023747494346216
F-2.9572277069091797
tp11661
sS'def _getch():\n    fd = sys.stdin.fileno()'
p11662
(F-1.4686270262065686
F-3.0171331405639648
tp11663
sS'def __init__(self):\n    import tty, sys'
p11664
(F-2.0681511374080883
F-2.955804443359375
tp11665
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11666
(F-1.783982379619892
F-2.9488269805908205
tp11667
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p11668
(F-1.8913365173339844
F-2.987440299987793
tp11669
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p11670
(F-1.6214545355902779
F-2.9440189361572267
tp11671
sS'def __init__(self):\n    import msvcrt'
p11672
(F-1.4326774597167968
F-2.949215316772461
tp11673
sS'getch = _find_getch()'
p11674
(F-2.2397558424207897
F-2.8014247894287108
tp11675
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p11676
(F-1.4791766575404577
F-2.9484130859375
tp11677
sS'return _getch\ngetch = _find_getch()'
p11678
(F-2.8074207305908203
F-2.7791276931762696
tp11679
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p11680
(F-1.7222168445587158
F-2.9924571990966795
tp11681
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11682
(F-2.4398463179425494
F-2.9333822250366213
tp11683
sS'return msvcrt.getch'
p11684
(F-3.517978032430013
F-2.888752746582031
tp11685
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        pass'
p11686
(F-1.3529096330915178
F-2.9798648834228514
tp11687
sS'import sys, tty\n\ndef _getch():\n    pass'
p11688
(F-2.3899563060087314
F-2.8243549346923826
tp11689
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p11690
(F-1.6121098445012019
F-3.0048547744750977
tp11691
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p11692
(F-1.7472483317057292
F-2.965597152709961
tp11693
sS'class _GetchWindows:\n\n    def __init__(self):\n        pass'
p11694
(F-1.1129363666881213
F-2.98331241607666
tp11695
sS'import termios'
p11696
(F-4.709692478179932
F-2.92659912109375
tp11697
sS'return msvcrt.getch()'
p11698
(F-1.9775238037109375
F-2.895060348510742
tp11699
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p11700
(F-1.69310546875
F-2.936172866821289
tp11701
sS'return ch\n\n\nclass _GetchWindows:\n    pass'
p11702
(F-2.035496139526367
F-2.872677230834961
tp11703
sS'getch = _Getch()'
p11704
(F-1.77204772404262
F-2.9506252288818358
tp11705
sS'class _GetchUnix:\n\n    def __init__(self):\n        pass'
p11706
(F-1.1129363666881213
F-2.98331241607666
tp11707
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p11708
(F-1.9152682168143136
F-2.8999298095703123
tp11709
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11710
(F-1.7321312399471507
F-2.9799549102783205
tp11711
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11712
(F-1.8243101119995118
F-3.0138648986816405
tp11713
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p11714
(F-1.6059244446835275
F-3.002001953125
tp11715
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p11716
(F-1.7280694580078124
F-2.9796958923339845
tp11717
sS'fd = sys.stdin.fileno()'
p11718
(F-1.6406610662286931
F-3.0988998413085938
tp11719
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p11720
(F-1.5643849092371322
F-2.9266006469726564
tp11721
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    pass'
p11722
(F-2.853685725818981
F-2.83644962310791
tp11723
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p11724
(F-1.5504244427348293
F-2.961499786376953
tp11725
sS'return ch'
p11726
(F-3.5869860649108887
F-2.872623062133789
tp11727
sS'self.impl = _GetchUnix()'
p11728
(F-1.8055994033813476
F-3.1186969757080076
tp11729
sS'def __call__(self):\n    return self.impl()'
p11730
(F-1.6536469710500616
F-2.9316743850708007
tp11731
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p11732
(F-1.8454796363567483
F-3.0447763442993163
tp11733
sS'return msvcrt.getch\nimport sys, tty'
p11734
(F-4.892019792036577
F-2.8465351104736327
tp11735
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p11736
(F-2.340692647298177
F-2.964455413818359
tp11737
sS'self.impl = _GetchWindows()'
p11738
(F-1.8055994033813476
F-3.1186969757080076
tp11739
sS'import tty, sys'
p11740
(F-5.237533887227376
F-2.7661258697509767
tp11741
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p11742
(F-1.9281383861194958
F-2.9230323791503907
tp11743
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p11744
(F-1.5097078595842635
F-2.9775058746337892
tp11745
sS'class _GetchUnix:\n    pass'
p11746
(F-1.9394813537597657
F-2.868479919433594
tp11747
sS"'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p11748
(F-2.9389378229777017
F-2.8398344039916994
tp11749
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p11750
(F-1.6733261108398438
F-2.9780811309814452
tp11751
sS'sys.stdin.read(1)'
p11752
(F-1.5184907913208008
F-3.0718561172485352
tp11753
sS'class _GetchWindows:\n    pass'
p11754
(F-1.9394813537597657
F-2.868479919433594
tp11755
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p11756
(F-2.15226321750217
F-2.9521507263183593
tp11757
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p11758
(F-1.7020615242622994
F-2.9879573822021483
tp11759
sS'class _Getch:\n    pass'
p11760
(F-1.7107708189222548
F-2.849049758911133
tp11761
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p11762
(F-1.8086310492621527
F-2.884830665588379
tp11763
sS'import msvcrt'
p11764
(F-4.709692478179932
F-2.9265987396240236
tp11765
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'\n\ndef __init__(self):\n    pass"
p11766
(F-1.2894491942032524
F-2.937765884399414
tp11767
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'\n\ndef __init__(self):\n    pass"
p11768
(F-1.2894491942032524
F-2.937765884399414
tp11769
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        pass'
p11770
(F-1.3652716742621527
F-2.9637849807739256
tp11771
sS'def __call__(self):\n    import msvcrt'
p11772
(F-1.8389040629069011
F-2.9832813262939455
tp11773
sS'def _getch():\n    pass'
p11774
(F-1.5336060957475142
F-2.8428842544555666
tp11775
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n    pass'
p11776
(F-1.5775794982910156
F-2.9274463653564453
tp11777
sS'return msvcrt.getch()\ngetch = _Getch()'
p11778
(F-2.3411712646484375
F-2.9483806610107424
tp11779
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p11780
(F-1.6309690475463867
F-2.9204111099243164
tp11781
sS"'Gets a single character from standard input.  Does not echo to the screen.'"
p11782
(F-2.9389378229777017
F-2.8398345947265624
tp11783
sS'import sys, tty'
p11784
(F-5.481247584025065
F-2.840633201599121
tp11785
sS'import sys, tty, termios'
p11786
(F-3.6389365196228027
F-2.8278581619262697
tp11787
ssI1450393
(dp11788
S'for line in fileinput.input():\n    pass'
p11789
(F-1.230420176188151
F-2.1066069169477983
tp11790
sS'import sys'
p11791
(F-4.678792953491211
F-2.0942150462757456
tp11792
sS'print line'
p11793
(F-3.2921881675720215
F-1.9628488367254084
tp11794
sS'for line in sys.stdin:\n    pass'
p11795
(F-1.38768797654372
F-1.9229056618430398
tp11796
sS'import fileinput\nfor line in fileinput.input():\n    pass'
p11797
(F-1.3600764804416232
F-2.1772790388627485
tp11798
sS'import fileinput'
p11799
(F-5.718738079071045
F-1.9903224598277698
tp11800
sS'pass'
p11801
(F-3.365880330403646
F-2.1335092024369673
tp11802
sS'import sys\nfor line in sys.stdin:\n    pass'
p11803
(F-1.414135456085205
F-1.9231239665638318
tp11804
ssI15411107
(dp11805
S'for key in keys_to_remove:\n    pass'
p11806
(F-2.280846913655599
F-3.498551940917969
tp11807
sS'new_dict = {k: mydict[k] for k in keys_to_keep}'
p11808
(F-2.172651464288885
F-3.42803840637207
tp11809
sS'try:\n    del mydict[key]\nexcept KeyError:\n    pass'
p11810
(F-1.356953121366955
F-3.6474258422851564
tp11811
sS'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p11812
(F-2.6284670743075282
F-3.5203022003173827
tp11813
sS'for key in keys_to_remove:\n    del mydict[key]'
p11814
(F-2.2917171277497945
F-3.480413055419922
tp11815
sS'pass'
p11816
(F-4.417121887207031
F-4.112499237060547
tp11817
sS'new_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p11818
(F-2.504251653497869
F-3.451084518432617
tp11819
sS'keys_to_keep = (set(mydict.keys()) - set(keys))'
p11820
(F-2.71623014367145
F-3.7082305908203126
tp11821
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    pass'
p11822
(F-2.441241615696957
F-3.5502880096435545
tp11823
sS'del mydict[key]'
p11824
(F-2.2549710954938615
F-3.660076141357422
tp11825
sS'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: mydict[k] for k in keys_to_keep}'
p11826
(F-2.4849083640358667
F-3.4887016296386717
tp11827
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))'
p11828
(F-2.5129946072896323
F-3.6005271911621093
tp11829
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    del mydict[key]'
p11830
(F-2.4495150248209634
F-3.5524318695068358
tp11831
sS"mydict.pop('key', None)"
p11832
(F-1.7301826477050781
F-3.8268112182617187
tp11833
ssI466345
(dp11834
S"dt = parser.parse('Aug 28 1999 12:00AM')"
p11835
(F-1.7498546600341798
F-2.298725128173828
tp11836
sS'from dateutil import parser'
p11837
(F-4.312087376912435
F-2.377520720163981
tp11838
sS'from datetime import datetime'
p11839
(F-3.1494550704956055
F-2.3023551305135093
tp11840
sS"from datetime import datetime\ndate_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p11841
(F-1.4804105256733142
F-2.2387768427530923
tp11842
sS"date_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p11843
(F-1.855459758213588
F-2.174553871154785
tp11844
sS"from dateutil import parser\ndt = parser.parse('Aug 28 1999 12:00AM')"
p11845
(F-1.8326372782389322
F-2.292245864868164
tp11846
ssI8177079
(dp11847
S'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p11848
(F-2.0955890856291117
F-2.339287519454956
tp11849
sS'c.extend(a)'
p11850
(F-2.4038944244384766
F-2.2528138160705566
tp11851
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11852
(F-1.5572250366210938
F-2.1168885231018066
tp11853
sS'a = range(5)'
p11854
(F-2.743194580078125
F-2.438173294067383
tp11855
sS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p11856
(F-3.61441969871521
F-2.1053054332733154
tp11857
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p11858
(F-2.3604192426127772
F-2.30031418800354
tp11859
sS'pass'
p11860
(F-4.448539733886719
F-2.3772222995758057
tp11861
sS'for logs in mydir:\n    for line in mylog:\n        list1.append(line)'
p11862
(F-1.641283671061198
F-2.121248960494995
tp11863
sS'list1.append(line)'
p11864
(F-2.270629405975342
F-2.110978126525879
tp11865
sS'c.extend(a)\nc'
p11866
(F-4.5519554138183596
F-2.255126714706421
tp11867
sS'b\nc.extend(a)'
p11868
(F-4.196175384521484
F-2.2396657466888428
tp11869
sS"import itertools\np = ['a', 'b', 'c']"
p11870
(F-2.152723857334682
F-2.2206828594207764
tp11871
sS'for logs in mydir:\n    pass'
p11872
(F-2.490692312067205
F-2.145460844039917
tp11873
sS'b.append(a)\nb'
p11874
(F-3.795914077758789
F-2.1441237926483154
tp11875
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p11876
(F-1.51425047843687
F-2.2393782138824463
tp11877
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)'
p11878
(F-1.7267412646063443
F-2.3750486373901367
tp11879
sS'for line in mylog:\n    pass'
p11880
(F-1.288809516213157
F-2.2120931148529053
tp11881
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)'
p11882
(F-2.5491437911987305
F-2.3073651790618896
tp11883
sS'b.append(a)\nb\nc.extend(a)'
p11884
(F-3.0768194759593293
F-2.170273780822754
tp11885
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p11886
(F-3.298182560847356
F-2.305542469024658
tp11887
sS'for x in itertools.chain(p, q, r):\n    pass'
p11888
(F-2.0282548904418944
F-2.1830248832702637
tp11889
sS"r = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11890
(F-1.730084737141927
F-2.1510932445526123
tp11891
sS'c = range(2)\nb.append(a)'
p11892
(F-1.9762941996256511
F-2.3386483192443848
tp11893
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    pass"
p11894
(F-2.4920315032309674
F-2.117337226867676
tp11895
sS'a = range(5)\nb = range(3)'
p11896
(F-2.2345609029134113
F-2.4272758960723877
tp11897
sS"p = ['a', 'b', 'c']"
p11898
(F-2.1432226354425605
F-2.310385227203369
tp11899
sS'list1.extend(mylog)'
p11900
(F-2.0848312377929688
F-2.137691020965576
tp11901
sS'for line in mylog:\n    list1.append(line)'
p11902
(F-1.0336487293243408
F-2.1635172367095947
tp11903
sS'b.append(a)\nb\nc.extend(a)\nc'
p11904
(F-4.076594704075863
F-2.16831636428833
tp11905
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p11906
(F-2.5949764251708984
F-2.336397409439087
tp11907
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb'
p11908
(F-2.2594762002268145
F-2.3582940101623535
tp11909
sS'list2.extend(list1)'
p11910
(F-1.9407680034637451
F-2.1572775840759277
tp11911
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11912
(F-1.4612123021539651
F-2.1390836238861084
tp11913
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p11914
(F-1.4594503784179687
F-2.1456985473632812
tp11915
sS'for logs in mydir:\n    for line in mylog:\n        pass'
p11916
(F-1.9203031439530223
F-2.1276674270629883
tp11917
sS'list2.append(list1)'
p11918
(F-1.765489101409912
F-2.1637401580810547
tp11919
sS'c = range(2)\nb.append(a)\nb'
p11920
(F-2.9909946217256436
F-2.310718297958374
tp11921
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p11922
(F-2.8996315696022728
F-2.1108815670013428
tp11923
sS'b = range(3)\nc = range(2)\nb.append(a)\nb'
p11924
(F-2.63196595509847
F-2.3139290809631348
tp11925
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p11926
(F-2.4021729689378004
F-2.110253095626831
tp11927
sS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p11928
(F-2.797857613399111
F-2.1059939861297607
tp11929
sS'b.append(a)'
p11930
(F-2.1682279109954834
F-2.177339553833008
tp11931
sS'import itertools'
p11932
(F-4.9952497482299805
F-2.217897891998291
tp11933
sS"if any((True for line in list1 if ('string' in line))):\n    pass"
p11934
(F-3.032916704813639
F-2.120711326599121
tp11935
sS"r = ['g', 'h', 'i']"
p11936
(F-2.174379522150213
F-2.285478353500366
tp11937
sS'c'
p11938
(F-9.067582448323568
F-2.4158358573913574
tp11939
sS'b'
p11940
(F-9.21089235941569
F-2.3376877307891846
tp11941
sS'b = range(3)'
p11942
(F-3.1324462890625
F-2.4168121814727783
tp11943
sS'c = range(2)'
p11944
(F-3.074352264404297
F-2.4624686241149902
tp11945
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p11946
(F-1.6917125384012859
F-2.197261095046997
tp11947
sS'b = range(3)\nc = range(2)\nb.append(a)'
p11948
(F-1.9370183077725498
F-2.3366286754608154
tp11949
sS'b = range(3)\nc = range(2)'
p11950
(F-2.5607635498046877
F-2.4201765060424805
tp11951
sS'b\nc.extend(a)\nc'
p11952
(F-5.489439646402995
F-2.237447738647461
tp11953
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p11954
(F-1.6864307948521204
F-2.227346420288086
tp11955
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p11956
(F-1.6714175996326266
F-2.2703471183776855
tp11957
sS"q = ['d', 'e', 'f']"
p11958
(F-2.0688011863014917
F-2.289266586303711
tp11959
sS'a = range(5)\nb = range(3)\nc = range(2)'
p11960
(F-2.1149541681463067
F-2.4319663047790527
tp11961
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p11962
(F-1.5420647789450252
F-2.1778929233551025
tp11963
sS'del list1'
p11964
(F-8.277796745300293
F-2.1288485527038574
tp11965
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p11966
(F-2.955717606977983
F-2.2982873916625977
tp11967
ssI455612
(dp11968
S"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p11969
(F-4.045291553844105
F-4.5221381187438965
tp11970
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng"
p11971
(F-3.647707257952009
F-4.524639129638672
tp11972
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))'
p11973
(F-3.969145275297619
F-4.613731384277344
tp11974
sS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p11975
(F-2.588625226702009
F-4.536550998687744
tp11976
sS'a = 13.946\nprint a'
p11977
(F-2.890658140182495
F-4.898565292358398
tp11978
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p11979
(F-3.286767182526765
F-4.566773891448975
tp11980
sS'(234042163 / (2 ** 24))\na = 13.946\nprint a'
p11981
(F-3.999969482421875
F-4.6282758712768555
tp11982
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946'
p11983
(F-3.9734127807617186
F-4.625899314880371
tp11984
sS"('%.2f' % 3.14159)\n('%.2f' % 13.9499999)"
p11985
(F-4.319529606745793
F-4.916780471801758
tp11986
sS"print '{0:.2f}'.format(round(a, 2))"
p11987
(F-2.836493355887277
F-4.5125956535339355
tp11988
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p11989
(F-3.5445064968532987
F-4.59476375579834
tp11990
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p11991
(F-3.1822190504807693
F-4.556331157684326
tp11992
sS'(234042163 / (2 ** 24))\na = 13.946'
p11993
(F-4.280224100748698
F-4.62130069732666
tp11994
sS'h'
p11995
(F-9.353771209716797
F-5.317336082458496
tp11996
sS'h\n(x == h)'
p11997
(F-5.632816738552517
F-4.836459159851074
tp11998
sS'x'
p11999
(F-8.492841084798178
F-4.83751106262207
tp12000
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))"
p12001
(F-2.7355348687422905
F-4.517498970031738
tp12002
sS"g = float('{0:.2f}'.format(x))\ng"
p12003
(F-3.679273732503255
F-4.496685028076172
tp12004
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12005
(F-3.7127731323242186
F-4.536839485168457
tp12006
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12007
(F-2.9573636736188615
F-4.566201210021973
tp12008
sS'(x == g)\nh = round(x, 2)'
p12009
(F-4.161550521850586
F-4.6631760597229
tp12010
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12011
(F-2.882531183416193
F-4.605199813842773
tp12012
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12013
(F-4.254881858825684
F-4.5543341636657715
tp12014
sS"a = 13.946\nprint a\nprint ('%.2f' % a)"
p12015
(F-2.6200942993164062
F-4.887205600738525
tp12016
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12017
(F-2.96909761428833
F-4.555267333984375
tp12018
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)"
p12019
(F-3.459807913643973
F-4.631705284118652
tp12020
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12021
(F-4.508342518525965
F-4.531097412109375
tp12022
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p12023
(F-3.183383717256434
F-4.661385536193848
tp12024
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12025
(F-3.0712133135114397
F-4.471960067749023
tp12026
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12027
(F-3.185066916725852
F-4.537341594696045
tp12028
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12029
(F-2.9147874175525104
F-4.517122745513916
tp12030
sS"print ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12031
(F-2.9343159993489585
F-4.537838935852051
tp12032
sS"print '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12033
(F-2.827376189055266
F-4.487688064575195
tp12034
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p12035
(F-3.414042663574219
F-4.6392693519592285
tp12036
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12037
(F-3.6265089246961804
F-4.51862907409668
tp12038
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12039
(F-3.0056926448170733
F-4.4522013664245605
tp12040
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12041
(F-3.2384059612567606
F-4.586355686187744
tp12042
sS'h = round(x, 2)\nh\n(x == h)'
p12043
(F-4.506290859646267
F-4.640369415283203
tp12044
sS"print a\nprint ('%.2f' % a)\nround(a, 2)"
p12045
(F-3.3455418480767145
F-4.695302963256836
tp12046
sS'g\n(x == g)'
p12047
(F-5.504137674967448
F-4.78179931640625
tp12048
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12049
(F-4.144148174085115
F-4.5332255363464355
tp12050
sS'x = 13.95'
p12051
(F-3.1292840957641603
F-4.848075866699219
tp12052
sS'g\n(x == g)\nh = round(x, 2)\nh\n(x == h)'
p12053
(F-4.972136864295373
F-4.701628684997559
tp12054
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12055
(F-2.88371095203218
F-4.6446027755737305
tp12056
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p12057
(F-2.9876057017933237
F-4.723138809204102
tp12058
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12059
(F-3.6936153835720487
F-4.517231464385986
tp12060
sS"print ('%.2f' % round(a, 2))"
p12061
(F-3.2158079880934496
F-4.516667366027832
tp12062
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12063
(F-3.0038616704005823
F-4.583837509155273
tp12064
sS'(125650429603636838 / (2 ** 53))'
p12065
(F-3.66172270341353
F-4.618770599365234
tp12066
sS"print '{0:.15f}'.format(round(a, 2))"
p12067
(F-2.836493355887277
F-4.5125956535339355
tp12068
sS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12069
(F-2.7363159542992
F-4.532491207122803
tp12070
sS"x\ng = float('{0:.2f}'.format(x))\ng"
p12071
(F-4.256809010225184
F-4.5045166015625
tp12072
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12073
(F-3.1275294377253604
F-4.5348944664001465
tp12074
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12075
(F-3.6374188377743675
F-4.492665767669678
tp12076
sS"print a\nprint ('%.2f' % a)"
p12077
(F-3.040399031205611
F-4.899766445159912
tp12078
sS'(x == h)'
p12079
(F-4.372352055140904
F-4.6787872314453125
tp12080
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))"
p12081
(F-3.5619842529296877
F-4.481973648071289
tp12082
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p12083
(F-4.337994384765625
F-4.520900726318359
tp12084
sS"x\ng = float('{0:.2f}'.format(x))"
p12085
(F-3.1713328043619793
F-4.496953010559082
tp12086
sS"float('{0:.2f}'.format(13.95))"
p12087
(F-2.13525390625
F-4.508006572723389
tp12088
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p12089
(F-3.5098604474748885
F-4.60585880279541
tp12090
sS"g = float('{0:.2f}'.format(x))"
p12091
(F-2.2754042698786807
F-4.495281219482422
tp12092
sS'(x == g)\nh = round(x, 2)\nh'
p12093
(F-5.0518472459581165
F-4.687398910522461
tp12094
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12095
(F-4.0169453620910645
F-4.5127058029174805
tp12096
sS'g'
p12097
(F-9.15734608968099
F-5.288769721984863
tp12098
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p12099
(F-4.120970876593339
F-4.543872833251953
tp12100
sS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12101
(F-2.791712592629825
F-4.506181240081787
tp12102
sS'g\n(x == g)\nh = round(x, 2)\nh'
p12103
(F-5.491217803955078
F-4.74762487411499
tp12104
sS"print ('%.2f' % a)"
p12105
(F-2.234161853790283
F-4.76735782623291
tp12106
sS"print ('%.2f' % a)\nround(a, 2)"
p12107
(F-3.058063252766927
F-4.589014053344727
tp12108
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)"
p12109
(F-3.4129812622070315
F-4.6756086349487305
tp12110
sS'a = 13.946'
p12111
(F-3.010023498535156
F-4.836198806762695
tp12112
sS"('%.2f' % 13.9499999)"
p12113
(F-4.054193769182477
F-4.9251790046691895
tp12114
sS'g\n(x == g)\nh = round(x, 2)'
p12115
(F-4.735499911838108
F-4.724196434020996
tp12116
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))"
p12117
(F-3.536627335981889
F-4.598739147186279
tp12118
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12119
(F-3.2956968738186743
F-4.583956718444824
tp12120
sS'print a'
p12121
(F-4.7594146728515625
F-5.007672309875488
tp12122
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12123
(F-4.042823459791101
F-4.499701976776123
tp12124
sS"round(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12125
(F-2.966493112069589
F-4.444005489349365
tp12126
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12127
(F-3.2409769694010415
F-4.556230068206787
tp12128
sS'x = 13.95\nx'
p12129
(F-4.770577022007534
F-4.846574783325195
tp12130
sS'h = round(x, 2)'
p12131
(F-3.498402404785156
F-4.662661552429199
tp12132
sS"print a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)"
p12133
(F-3.0529327392578125
F-4.624026775360107
tp12134
sS'(234042163 / (2 ** 24))'
p12135
(F-4.127687627618963
F-4.594369888305664
tp12136
sS"(234042163 / (2 ** 24))\na = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)"
p12137
(F-3.4975244998931885
F-4.622186183929443
tp12138
sS"'{0:.2f}'.format(13.95)"
p12139
(F-2.2888848781585693
F-4.72119140625
tp12140
sS'(x == g)\nh = round(x, 2)\nh\n(x == h)'
p12141
(F-4.663373311360677
F-4.653779983520508
tp12142
sS'(x == g)'
p12143
(F-4.292035239083426
F-4.677905082702637
tp12144
sS'round(a, 2)'
p12145
(F-3.4350922107696533
F-4.593877792358398
tp12146
sS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p12147
(F-2.4499553333629263
F-4.583286762237549
tp12148
sS"a = 13.946\nprint a\nprint ('%.2f' % a)\nround(a, 2)\nprint ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12149
(F-2.875873565673828
F-4.574107646942139
tp12150
sS"print '{0:.2f}'.format(a)"
p12151
(F-1.888638390435113
F-4.710504531860352
tp12152
sS"print ('%.2f' % round(a, 2))\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p12153
(F-2.806907166825964
F-4.487090587615967
tp12154
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint a'
p12155
(F-3.8472251892089844
F-4.605197906494141
tp12156
sS'h = round(x, 2)\nh'
p12157
(F-5.059590657552083
F-4.684610366821289
tp12158
sS"('%.2f' % 3.14159)"
p12159
(F-4.054193769182477
F-4.9251790046691895
tp12160
ssI73663
(dp12161
S'sys.exit()'
p12162
(F-1.7985501970563615
F-2.8084891637166343
tp12163
sS'if (this == that):\n    pass'
p12164
(F-3.424030597393329
F-3.3921934763590493
tp12165
sS'import sys'
p12166
(F-4.492650032043457
F-2.719268480936686
tp12167
sS'if (this == that):\n    quit()'
p12168
(F-3.076100158691406
F-3.499389330546061
tp12169
sS'import sys\nsys.exit()'
p12170
(F-1.2453662872314453
F-2.7869701385498047
tp12171
sS'quit()'
p12172
(F-1.4158979415893556
F-3.1772454579671225
tp12173
sS'raise SystemExit'
p12174
(F-4.060578918457031
F-3.1042658487955728
tp12175
ssI1476
(dp12176
S"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))"
p12177
(F-2.993314743041992
F-2.3021115389737217
tp12178
sS"int('010101', 2)"
p12179
(F-2.910818576812744
F-2.321110812100497
tp12180
sS'21'
p12181
(F-3.9631290435791016
F-2.4645394411954014
tp12182
sS"int('10101', 0)\nint('0b10101', 0)"
p12183
(F-3.135118865966797
F-2.3253380168568003
tp12184
sS'bin(21)'
p12185
(F-2.7553380330403647
F-2.3711658824573862
tp12186
sS'47'
p12187
(F-3.9631290435791016
F-2.4645394411954014
tp12188
sS"int('0b10101', 0)"
p12189
(F-2.8849711418151855
F-2.331924785267223
tp12190
sS"print int('01010101111', 2)"
p12191
(F-2.8458726671006946
F-2.3442882191051138
tp12192
sS"int('0b0010101010', 2)"
p12193
(F-2.910818576812744
F-2.321110812100497
tp12194
sS"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))\nformat(int('010101', 2), '010b')"
p12195
(F-3.1885386572943792
F-2.3139690052379263
tp12196
sS'170\n21'
p12197
(F-3.23492546081543
F-2.4612938274036753
tp12198
sS'bin(173)'
p12199
(F-2.7553380330403647
F-2.3711658824573862
tp12200
sS"int('10101', 0)"
p12201
(F-2.8849711418151855
F-2.331924785267223
tp12202
sS"format(int('010101', 2), '010b')"
p12203
(F-2.9832933866060696
F-2.348166725852273
tp12204
sS"bin(int('010101', 2))"
p12205
(F-2.806092695756392
F-2.2780276211825283
tp12206
sS"print int('01010101111', 2)\nprint int('11111111', 2)"
p12207
(F-3.115249185001149
F-2.3782820268110796
tp12208
sS"print int('11111111', 2)"
p12209
(F-2.8458726671006946
F-2.3442882191051138
tp12210
sS'170'
p12211
(F-3.9631293614705405
F-2.4645394411954014
tp12212
ssI761804
(dp12213
S"'          Hello        '.strip()"
p12214
(F-2.035935946873256
F-1.4381158011300224
tp12215
sS"strip_one_space('   Hello ')"
p12216
(F-4.416603469848633
F-1.4713033948625838
tp12217
sS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12218
(F-3.391532287597656
F-1.4035194941929408
tp12219
sS"' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12220
(F-3.241947374845806
F-1.4051900591169084
tp12221
sS"title = title.strip(',.-')"
p12222
(F-3.1554405212402346
F-1.749755586896624
tp12223
sS"' Hello'.strip()"
p12224
(F-2.035935946873256
F-1.4381158011300224
tp12225
sS'myString.strip()'
p12226
(F-2.0232059955596924
F-1.4155213492257255
tp12227
sS"'Bob has a cat'.strip()"
p12228
(F-2.035935946873256
F-1.4381158011300224
tp12229
sS"'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12230
(F-2.9388492290790262
F-1.4100232805524553
tp12231
sS"' Hello '.strip()\n' Hello'.strip()"
p12232
(F-2.9388492290790262
F-1.4100232805524553
tp12233
sS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()"
p12234
(F-3.241947374845806
F-1.4051900591169084
tp12235
sS"' Hello'.strip()\n'Bob has a cat'.strip()"
p12236
(F-2.9388492290790262
F-1.4100232805524553
tp12237
sS"' Hello '.strip()"
p12238
(F-2.035935946873256
F-1.4381158011300224
tp12239
sS"'  Hello\\n'.strip(' ')"
p12240
(F-2.8135733604431152
F-1.4536288125174386
tp12241
ssI4476373
(dp12242
S"payload = {'key1': 'value1', 'key2': 'value2', }"
p12243
(F-2.158982413155692
F-3.7112964630126952
tp12244
sS'return urllib2.Request(url, data=urllib.urlencode(params))'
p12245
(F-1.7664135826958551
F-3.6673355102539062
tp12246
sS'r = requests.post(url, data=payload)\nimport json'
p12247
(F-2.5833769405589386
F-3.7488922119140624
tp12248
sS'resp'
p12249
(F-6.657278060913086
F-4.088321685791016
tp12250
sS"return urllib2.Request(((url + '?') + urllib.urlencode(params)))"
p12251
(F-2.4370108517733486
F-3.628398132324219
tp12252
sS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12253
(F-2.847959245954241
F-3.732889175415039
tp12254
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12255
(F-1.4645790523952908
F-3.678434371948242
tp12256
sS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        return urllib2.Request(url, data=urllib.urlencode(params))"
p12257
(F-1.6365328702059658
F-3.6853778839111326
tp12258
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12259
(F-1.8585275503305287
F-3.7218807220458983
tp12260
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p12261
(F-1.806994120279948
F-3.739950180053711
tp12262
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12263
(F-1.7878029232933408
F-3.707802581787109
tp12264
sS"if (method == 'POST'):\n    return urllib2.Request(url, data=urllib.urlencode(params))"
p12265
(F-1.8307764870779855
F-3.6730224609375
tp12266
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12267
(F-1.5664910452706473
F-3.72677001953125
tp12268
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12269
(F-1.6857312066214425
F-3.7064979553222654
tp12270
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p12271
(F-1.7927067620413644
F-3.7051334381103516
tp12272
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12273
(F-1.296388493027798
F-3.731784439086914
tp12274
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12275
(F-1.5057934125264485
F-3.7190887451171877
tp12276
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12277
(F-1.8046789902907152
F-3.7009860992431642
tp12278
sS'from httplib2 import Http\nfrom urllib import urlencode\nh = Http()'
p12279
(F-2.2047940422506893
F-3.9527095794677733
tp12280
sS'import requests'
p12281
(F-4.731019496917725
F-3.830409622192383
tp12282
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12283
(F-1.588695073531846
F-3.744200897216797
tp12284
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12285
(F-1.7688579185336244
F-3.7811046600341798
tp12286
sS"import requests\nurl = 'https://...'"
p12287
(F-2.3185646533966064
F-3.7784656524658202
tp12288
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12289
(F-1.4855717250279017
F-3.7020153045654296
tp12290
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12291
(F-2.2217066446940104
F-3.725747299194336
tp12292
sS"url = 'https://...'"
p12293
(F-2.1127344131469727
F-3.7134559631347654
tp12294
sS'r.status_code'
p12295
(F-3.366988045828683
F-4.0183876037597654
tp12296
sS'from httplib2 import Http'
p12297
(F-3.0461994806925454
F-4.180744171142578
tp12298
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p12299
(F-1.4396215368200231
F-3.737147903442383
tp12300
sS'r = requests.get(url, params=payload)'
p12301
(F-1.4065220696585519
F-3.710649108886719
tp12302
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12303
(F-1.3532120326779924
F-3.710919189453125
tp12304
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12305
(F-1.3509562492370606
F-3.684186553955078
tp12306
sS'r = requests.post(url, data=payload)'
p12307
(F-1.4988542284284319
F-3.769522857666016
tp12308
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12309
(F-2.3095631917317707
F-3.707838439941406
tp12310
sS"def URLRequest(url, params, method='GET'):\n    pass"
p12311
(F-1.820518092105263
F-3.734602355957031
tp12312
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12313
(F-1.6442308840544329
F-3.6529800415039064
tp12314
sS'from urllib import urlencode\nh = Http()'
p12315
(F-2.3312018712361655
F-3.7916286468505858
tp12316
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12317
(F-2.0847576904296874
F-3.7371990203857424
tp12318
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12319
(F-2.8618785313197543
F-3.8036483764648437
tp12320
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12321
(F-2.413644313812256
F-3.698427200317383
tp12322
sS'r = requests.get(url)\nr = requests.get(url, params=payload)'
p12323
(F-1.2788008814272673
F-3.7309005737304686
tp12324
sS"post_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12325
(F-1.8641974312918528
F-3.7364425659179688
tp12326
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12327
(F-1.4100465516786318
F-3.7067665100097655
tp12328
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12329
(F-2.262157287597656
F-3.7152355194091795
tp12330
sS'r.text\nr.status_code'
p12331
(F-3.655589363791726
F-4.07023811340332
tp12332
sS"post_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12333
(F-1.8042379379272462
F-3.748616409301758
tp12334
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12335
(F-1.6191266169313525
F-3.727519226074219
tp12336
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p12337
(F-1.9469224214553833
F-3.740935134887695
tp12338
sS"post_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12339
(F-2.2226093292236326
F-3.738132095336914
tp12340
sS'r = requests.post(url, data=json.dumps(payload))\nr.text'
p12341
(F-1.9353521595830503
F-3.6979835510253904
tp12342
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12343
(F-1.9691128020590924
F-3.7221115112304686
tp12344
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p12345
(F-1.6613543701171876
F-3.6986228942871096
tp12346
sS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12347
(F-2.5742180768181298
F-3.794935607910156
tp12348
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12349
(F-1.5428870872214988
F-3.659880447387695
tp12350
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12351
(F-1.730227543757512
F-3.715330123901367
tp12352
sS'r.text'
p12353
(F-3.3557891845703125
F-3.9951812744140627
tp12354
sS"import requests\nget_response = requests.get(url='http://google.com')"
p12355
(F-1.6592227711397058
F-3.7423912048339845
tp12356
sS'from httplib2 import Http\nfrom urllib import urlencode'
p12357
(F-2.490235762162642
F-3.931354522705078
tp12358
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12359
(F-2.0294297316978716
F-3.7187515258789063
tp12360
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12361
(F-1.4502832840900033
F-3.7052608489990235
tp12362
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12363
(F-2.472986602783203
F-3.7984832763671874
tp12364
sS'import json\nr = requests.post(url, data=json.dumps(payload))'
p12365
(F-1.4694007526744495
F-3.6961517333984375
tp12366
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12367
(F-1.3477893185305905
F-3.7396568298339843
tp12368
sS'r = requests.post(url, data=json.dumps(payload))'
p12369
(F-1.3459938450863487
F-3.7053836822509765
tp12370
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12371
(F-1.8714731216430665
F-3.7032852172851562
tp12372
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12373
(F-1.8893769677005596
F-3.7305984497070312
tp12374
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12375
(F-1.9385742774376502
F-3.695966339111328
tp12376
sS"if (method == 'POST'):\n    pass"
p12377
(F-2.1390727116511417
F-4.064566040039063
tp12378
sS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12379
(F-3.037054909600152
F-3.79794921875
tp12380
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p12381
(F-1.328871832953559
F-3.7489723205566405
tp12382
sS'import json'
p12383
(F-5.104668140411377
F-3.8232490539550783
tp12384
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12385
(F-2.094920857747396
F-3.757151794433594
tp12386
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12387
(F-1.9442745844523113
F-3.758635711669922
tp12388
sS'r = requests.get(url)'
p12389
(F-1.5432405471801758
F-3.7324901580810548
tp12390
sS"get_response = requests.get(url='http://google.com')"
p12391
(F-1.802596092224121
F-3.725724792480469
tp12392
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12393
(F-1.490576680501302
F-3.7086524963378906
tp12394
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12395
(F-1.6464889113967482
F-3.700215530395508
tp12396
sS"post_data = {'username': 'joeb', 'password': 'foobar', }"
p12397
(F-2.293923854827881
F-3.780717468261719
tp12398
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12399
(F-2.220906639099121
F-3.9091590881347655
tp12400
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12401
(F-1.2971635546003069
F-3.751629638671875
tp12402
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12403
(F-1.5678606277857072
F-3.7047786712646484
tp12404
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12405
(F-1.4223873740748356
F-3.7308879852294923
tp12406
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p12407
(F-2.200742918869545
F-3.7363861083984373
tp12408
sS'h = Http()'
p12409
(F-2.665837969098772
F-4.1913307189941404
tp12410
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12411
(F-2.5569287813626804
F-3.7164070129394533
tp12412
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p12413
(F-1.806155068533761
F-3.659679412841797
tp12414
sS'from urllib import urlencode'
p12415
(F-3.4385852813720703
F-3.7639408111572266
tp12416
sS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        pass"
p12417
(F-1.7887807385674839
F-3.7538917541503904
tp12418
sS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12419
(F-3.4932874596637227
F-3.7405181884765626
tp12420
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12421
(F-1.5014466650692033
F-3.7362747192382812
tp12422
sS"data = dict(name='Joe', comment='A test comment')"
p12423
(F-2.2458066940307617
F-3.8997344970703125
tp12424
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12425
(F-2.653425987730635
F-3.7075660705566404
tp12426
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p12427
(F-1.9533509148491754
F-3.6519237518310548
tp12428
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12429
(F-1.7160027164152298
F-3.7383399963378907
tp12430
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12431
(F-1.910787582397461
F-3.714215850830078
tp12432
sS'r = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12433
(F-2.4586657820076776
F-3.7061595916748047
tp12434
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p12435
(F-2.0499045054117837
F-3.726335144042969
tp12436
ssI247770
(dp12437
S'import inspect\ninspect.getfile(os)'
p12438
(F-2.797204104336825
F-3.389878590901693
tp12439
sS'os.path.dirname(inspect.getfile(inspect))'
p12440
(F-1.8307664235432943
F-3.3738886515299478
tp12441
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p12442
(F-2.8592906528049045
F-3.4193970362345376
tp12443
sS'print os.getcwd()'
p12444
(F-1.7886515855789185
F-3.3909708658854165
tp12445
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p12446
(F-2.748725164504278
F-3.426248868306478
tp12447
sS'inspect.getfile(os)\ninspect.getfile(inspect)'
p12448
(F-2.9768707275390627
F-3.4479614893595376
tp12449
sS'inspect.getfile(os)'
p12450
(F-2.931527614593506
F-3.3963562647501626
tp12451
sS'import inspect'
p12452
(F-5.498951435089111
F-3.3576062520345054
tp12453
sS'print __file__'
p12454
(F-3.3942152659098306
F-3.4890543619791665
tp12455
sS'print bar.__file__'
p12456
(F-3.4965662956237793
F-3.444838205973307
tp12457
sS'import bar\nprint bar.__file__'
p12458
(F-3.3237627202814277
F-3.40650208791097
tp12459
sS'path = os.path.abspath(amodule.__file__)'
p12460
(F-1.4046695232391357
F-3.419221560160319
tp12461
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12462
(F-2.634439706802368
F-3.4111572901407876
tp12463
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12464
(F-2.551824951171875
F-3.439655621846517
tp12465
sS'import bar'
p12466
(F-5.510899066925049
F-3.3435853322347007
tp12467
sS'path = os.path.dirname(amodule.__file__)'
p12468
(F-1.4046695232391357
F-3.419221560160319
tp12469
sS'import a_module'
p12470
(F-4.652169227600098
F-3.3341029485066733
tp12471
sS'import os'
p12472
(F-3.799508810043335
F-3.3797216415405273
tp12473
sS'import os\nimport inspect'
p12474
(F-3.9532530648367747
F-3.44384765625
tp12475
sS'inspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12476
(F-2.7068309783935547
F-3.465235710144043
tp12477
sS'import a_module\nprint a_module.__file__'
p12478
(F-3.617108154296875
F-3.376777013142904
tp12479
sS'import os\nprint os.getcwd()\nprint __file__'
p12480
(F-2.1802377700805664
F-3.4268805185953775
tp12481
sS'print a_module.__file__'
p12482
(F-3.764098358154297
F-3.369381904602051
tp12483
sS'import os\npath = os.path.dirname(amodule.__file__)'
p12484
(F-1.4300194790488796
F-3.460153261820475
tp12485
sS'import os\nprint os.getcwd()'
p12486
(F-1.2037004991011186
F-3.424352010091146
tp12487
sS'inspect.getfile(inspect)'
p12488
(F-2.9489784240722656
F-3.661688486735026
tp12489
sS'import os\nimport inspect\ninspect.getfile(os)'
p12490
(F-2.726327896118164
F-3.4438584645589194
tp12491
sS'inspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12492
(F-2.7006809629242996
F-3.4118096033732095
tp12493
sS'print os.getcwd()\nprint __file__'
p12494
(F-2.807515657865084
F-3.423710505167643
tp12495
ssI4906977
(dp12496
S'print os.environ'
p12497
(F-2.9130563735961914
F-2.979084014892578
tp12498
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')\nprint os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p12499
(F-2.7725259532099185
F-3.080183301653181
tp12500
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')"
p12501
(F-1.6910266876220703
F-3.059526171003069
tp12502
sS'import sys'
p12503
(F-4.325262069702148
F-2.939497811453683
tp12504
sS'import os\nprint os.environ'
p12505
(F-2.016034656100803
F-2.9333817618233815
tp12506
sS"('HOME' in os.environ)"
p12507
(F-3.4530372619628906
F-3.2257518768310547
tp12508
sS'print sys.prefix'
p12509
(F-3.1777013142903647
F-2.945070266723633
tp12510
sS"import os\nprint os.environ['HOME']"
p12511
(F-1.0215697288513184
F-3.008082798549107
tp12512
sS'os.environ'
p12513
(F-1.3796906471252441
F-3.0259998866489957
tp12514
sS"os.environ.has_key('HOME')"
p12515
(F-2.220052719116211
F-3.1606521606445312
tp12516
sS'import os'
p12517
(F-4.008045196533203
F-2.8780640193394254
tp12518
sS"print os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p12519
(F-3.4373350877028246
F-3.039191109793527
tp12520
sS"print os.environ.get('HOME', '/home/username/')"
p12521
(F-1.5486492743858924
F-3.077632086617606
tp12522
sS"print os.environ['HOME']"
p12523
(F-1.5780365202162001
F-3.0790579659598216
tp12524
sS'import sys\nprint sys.prefix'
p12525
(F-1.9678967793782551
F-2.9267891475132535
tp12526
ssI4641765
(dp12527
S'things_to_add = [0, 1, 1, 0]'
p12528
(F-3.0976721819709327
F-3.2129271030426025
tp12529
sS'fooList.append(3)\nfooList.append(2734)\nprint fooList'
p12530
(F-2.5871592930385043
F-3.213737726211548
tp12531
sS'print fooList'
p12532
(F-4.22594985961914
F-3.6000490188598633
tp12533
sS'foo.append(4)\nfoo.append([8, 7])\nprint foo'
p12534
(F-2.2670757987282495
F-3.071181297302246
tp12535
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p12536
(F-2.9753291917883833
F-2.8920931816101074
tp12537
sS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12538
(F-3.220922009698276
F-2.8142263889312744
tp12539
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p12540
(F-2.4997495763442097
F-2.889333724975586
tp12541
sS'foo[3] = (foo[3] + 4)\nprint foo'
p12542
(F-2.480543772379557
F-2.9324069023132324
tp12543
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)\nprint fooList'
p12544
(F-2.2064859726849724
F-2.895026922225952
tp12545
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p12546
(F-2.4875715775923295
F-2.896800994873047
tp12547
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])'
p12548
(F-1.6736453663219104
F-2.9548544883728027
tp12549
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p12550
(F-2.7752971205600474
F-2.901561737060547
tp12551
sS'foo.append([8, 7])\nprint foo'
p12552
(F-2.4118372599283853
F-3.1033689975738525
tp12553
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)'
p12554
(F-2.469777540727095
F-2.926873207092285
tp12555
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)'
p12556
(F-2.215204874674479
F-2.9369192123413086
tp12557
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p12558
(F-2.5498335702078685
F-2.9250965118408203
tp12559
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p12560
(F-2.7227461965460527
F-2.90002179145813
tp12561
sS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p12562
(F-2.8672318635163485
F-2.811732530593872
tp12563
sS'print foo'
p12564
(F-3.5643181800842285
F-3.6295440196990967
tp12565
sS'foo.append(4)'
p12566
(F-2.2110986709594727
F-3.121358633041382
tp12567
sS'foo = [1, 2, 3, 4, 5]'
p12568
(F-1.6069727579752604
F-2.9641032218933105
tp12569
sS'print x'
p12570
(F-4.270442008972168
F-3.6068918704986572
tp12571
sS'fooList = [1, 3, 348, 2]'
p12572
(F-2.891392844063895
F-2.984325408935547
tp12573
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12574
(F-3.007695855034722
F-2.8970727920532227
tp12575
sS'fooList.append(3)'
p12576
(F-3.3064426845974393
F-3.2841503620147705
tp12577
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)'
p12578
(F-1.4689036282626065
F-2.9554853439331055
tp12579
sS'things_to_add = [(1, 1), (2, 1)]'
p12580
(F-2.613968985421317
F-2.9824635982513428
tp12581
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])\nprint foo'
p12582
(F-1.6412510342068143
F-2.923644542694092
tp12583
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12584
(F-2.700471932547433
F-2.8818392753601074
tp12585
sS'L[idx] += amount'
p12586
(F-2.845463514328003
F-3.174304246902466
tp12587
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]'
p12588
(F-2.4349638840247847
F-3.0783491134643555
tp12589
sS'fooList.append(2734)\nprint fooList'
p12590
(F-2.7213079012357273
F-3.3522801399230957
tp12591
sS'L'
p12592
(F-7.430316925048828
F-3.7151219844818115
tp12593
sS'foo.append(4)\nfoo.append([8, 7])'
p12594
(F-2.2203059949372945
F-3.067107677459717
tp12595
sS'for (idx, amount) in things_to_add:\n    L[idx] += amount'
p12596
(F-3.1186701456705728
F-2.8948659896850586
tp12597
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12598
(F-2.6671629788582787
F-2.892624855041504
tp12599
sS'x = [2, 5, 10]\nx.insert(2, 77)'
p12600
(F-2.035287857055664
F-3.1332485675811768
tp12601
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount'
p12602
(F-2.7597508863969282
F-2.897084951400757
tp12603
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p12604
(F-2.656275431315104
F-2.854128837585449
tp12605
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p12606
(F-2.7325366707735284
F-2.9578065872192383
tp12607
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12608
(F-2.9177428654261996
F-2.905881643295288
tp12609
sS'L[:] = [sum(i) for i in zip(L, things_to_add)]'
p12610
(F-2.52383305476262
F-2.892766237258911
tp12611
sS'x.insert(2, 77)\nprint x'
p12612
(F-2.5014419555664062
F-3.3001532554626465
tp12613
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p12614
(F-2.7927554660373266
F-2.892770767211914
tp12615
sS'for (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p12616
(F-3.5133502666766825
F-2.895308017730713
tp12617
sS'fooList.append(3)\nfooList.append(2734)'
p12618
(F-2.6113397934857536
F-3.2145841121673584
tp12619
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)\nprint foo'
p12620
(F-1.67121160030365
F-2.9080140590667725
tp12621
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']"
p12622
(F-2.3973673306978664
F-2.917147159576416
tp12623
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12624
(F-2.7906399430899786
F-2.9157204627990723
tp12625
sS'for item in things_to_add:\n    pass'
p12626
(F-2.8696556091308594
F-2.982316017150879
tp12627
sS"L[item['idx']] += item['amount']"
p12628
(F-2.5510147639683316
F-3.16617751121521
tp12629
sS'x = [2, 5, 10]'
p12630
(F-2.6371307373046875
F-2.9913148880004883
tp12631
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)'
p12632
(F-1.594671578242861
F-2.935896635055542
tp12633
sS'foo.append([8, 7])'
p12634
(F-2.055264155069987
F-3.0940213203430176
tp12635
sS'foo[3] = (foo[3] + 4)'
p12636
(F-2.1949745178222657
F-2.967207908630371
tp12637
sS'x.insert(2, 77)'
p12638
(F-2.0644338607788084
F-3.4701876640319824
tp12639
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    pass'
p12640
(F-2.711965120755709
F-2.8732211589813232
tp12641
sS'L = [0, 0, 0, 0]'
p12642
(F-1.7958949162409856
F-3.2311782836914062
tp12643
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p12644
(F-2.9850276823966735
F-3.114856004714966
tp12645
sS'x = [2, 5, 10]\nx.insert(2, 77)\nprint x'
p12646
(F-2.0852372542671533
F-3.05521821975708
tp12647
sS'fooList.append(2734)'
p12648
(F-2.6474619971381292
F-3.4029173851013184
tp12649
sS'for (idx, amount) in enumerate(things_to_add):\n    pass'
p12650
(F-2.917694785378196
F-2.831040143966675
tp12651
sS'for (idx, amount) in things_to_add:\n    pass'
p12652
(F-3.2320086830540706
F-2.991424083709717
tp12653
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p12654
(F-2.439962921142578
F-2.88407301902771
tp12655
ssI2407398
(dp12656
S'zip(list_a, list_b)'
p12657
(F-2.2251364390055337
F-1.4009978430611747
tp12658
sS'list_b = [5, 6, 7, 8]'
p12659
(F-2.8790936787923176
F-1.503347669328962
tp12660
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]'
p12661
(F-2.1377860759866647
F-1.4470291137695312
tp12662
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p12663
(F-1.9526912689208984
F-1.4112404414585658
tp12664
sS'list_a = [1, 2, 3, 4]'
p12665
(F-2.347581481933594
F-1.4946932111467635
tp12666
sS'list_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p12667
(F-2.3442733471210184
F-1.4208142416817802
tp12668
ssI19602931
(dp12669
S'testfile = urllib.URLopener()'
p12670
(F-2.3765939712524413
F-3.8437881469726562
tp12671
sS'file_name = wget.download(file_url)'
p12672
(F-4.0893756321498325
F-3.72799799992488
tp12673
sS'import urllib\ntestfile = urllib.URLopener()'
p12674
(F-2.236871279202975
F-3.8043368412898135
tp12675
sS"testfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p12676
(F-2.0039419876901725
F-3.790319589468149
tp12677
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p12678
(F-3.8993517004925273
F-3.7172071016751804
tp12679
sS"urllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p12680
(F-1.357539463043213
F-3.847737825833834
tp12681
sS"file_url = 'http://johndoe.com/download.zip'"
p12682
(F-3.0344300951276506
F-3.780895526592548
tp12683
sS'import wget'
p12684
(F-6.399972915649414
F-4.072680840125451
tp12685
sS"testfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p12686
(F-1.9203588485717773
F-3.8121009239783654
tp12687
sS"file_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p12688
(F-3.4042457580566405
F-3.7041200491098256
tp12689
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'"
p12690
(F-4.083191680908203
F-3.809210263765775
tp12691
sS'import urllib'
p12692
(F-3.9248604774475098
F-3.8244960491473856
tp12693
sS"import urllib\nurllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p12694
(F-1.0559334388146033
F-3.787842970628005
tp12695
sS"import urllib\ntestfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p12696
(F-1.8864333412863992
F-3.777173555814303
tp12697
ssI4588628
(dp12698
S'(a == 0)'
p12699
(F-3.774169921875
F-4.083049456278483
tp12700
sS'numpy.where((x == 0))[0]'
p12701
(F-2.4260093688964846
F-3.6386947631835938
tp12702
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\nnumpy.where((x == 0))[0]'
p12703
(F-1.8438511724057405
F-3.605898857116699
tp12704
sS'a = np.asarray([0, 1, 2, 3, 4])\n(a == 0)'
p12705
(F-2.46286128117488
F-3.5580482482910156
tp12706
sS'(x == 0)\nnumpy.nonzero((x == 0))[0]'
p12707
(F-2.935775575183687
F-3.600523312886556
tp12708
sS'numpy.nonzero((x == 0))[0]'
p12709
(F-2.429523468017578
F-3.5970738728841147
tp12710
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)\nnumpy.nonzero((x == 0))[0]'
p12711
(F-2.2047993586613583
F-3.5828164418538413
tp12712
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])'
p12713
(F-1.6109883785247803
F-3.633817990620931
tp12714
sS'(x == 0)'
p12715
(F-3.3381383078438893
F-4.1014359792073565
tp12716
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)'
p12717
(F-2.0924602307771383
F-3.633946100870768
tp12718
sS'a = np.asarray([0, 1, 2, 3, 4])'
p12719
(F-1.517449188232422
F-3.5407482782999673
tp12720
ss.